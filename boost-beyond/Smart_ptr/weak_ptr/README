两种从weak_ptr创建shared_ptr的惯用法

如果拥有一个观察某种资源的智能指针weak_ptr，那么最终还是希望访问这个资源的。为此，weak_ptr必须转换为shared_ptr，因为单独一个weak_ptr是不允许直接访问资源的。
有两种方法可以从weak_ptr创建shared_ptr：一种方法是将weak_ptr传递给shared_ptr的构造函数（见eg3.cpp），另一种方法是调用weak_ptr的成员函数lock，该函数将返回一个shared_ptr。选择哪一种方法取决于是否将空的weak_ptr是一种错误时才可以使用这种方法。当使用weak_ptr的成员函数lock时，如果weak_ptr是空的，那么所返回的shared_ptr将为空。这种方法可以用于测试一个资源是否有效――....也就是说空的weak_ptr是预期中的行为。另外在使用lock函数时，使用资源的通常做法是同时初始化并测试资源。

eg2.cpp对应于lock生成，eg3.cpp对应于构造生成

其中eg3.cpp中，函数access_the_resource从weak_ptr构造了shared_ptr sp。这时不需要测试shared_ptr是否为空，因为如果weak_ptr为空，那么程序将会抛出一个类型为bad_weak_ptr异常，函数access_the_resource就会立即结束。另外，错误会在适当的时候被捕获和处理。这样做要比显式地测试shared_ptr是否为空然后再返回好。
