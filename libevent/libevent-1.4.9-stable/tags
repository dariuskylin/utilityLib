!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACLOCAL	Makefile	/^ACLOCAL = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run aclocal-1.10$/;"	m
ACLOCAL	sample/Makefile	/^ACLOCAL = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run aclocal-1.10$/;"	m
ACLOCAL	test/Makefile	/^ACLOCAL = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run aclocal-1.10$/;"	m
ACLOCAL_M4	Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ACLOCAL_M4	sample/Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ACLOCAL_M4	test/Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ALL_DATA_READ	http-internal.h	/^	ALL_DATA_READ = 1,$/;"	e	enum:message_read_status
AMTAR	Makefile	/^AMTAR = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run tar$/;"	m
AMTAR	sample/Makefile	/^AMTAR = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run tar$/;"	m
AMTAR	test/Makefile	/^AMTAR = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run tar$/;"	m
AM_CFLAGS	sample/Makefile	/^AM_CFLAGS = -I$(top_srcdir) -I$(top_srcdir)\/compat$/;"	m
AM_CFLAGS	test/Makefile	/^AM_CFLAGS = -I$(top_srcdir) -I$(top_srcdir)\/compat$/;"	m
APPEND16	evdns.c	1357;"	d	file:
APPEND16	evdns.c	1857;"	d	file:
APPEND32	evdns.c	1364;"	d	file:
APPEND32	evdns.c	1858;"	d	file:
AR	Makefile	/^AR = ar$/;"	m
AR	sample/Makefile	/^AR = ar$/;"	m
AR	test/Makefile	/^AR = ar$/;"	m
AUTOCONF	Makefile	/^AUTOCONF = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run autoconf$/;"	m
AUTOCONF	sample/Makefile	/^AUTOCONF = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run autoconf$/;"	m
AUTOCONF	test/Makefile	/^AUTOCONF = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run autoconf$/;"	m
AUTOHEADER	Makefile	/^AUTOHEADER = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run autoheader$/;"	m
AUTOHEADER	sample/Makefile	/^AUTOHEADER = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run autoheader$/;"	m
AUTOHEADER	test/Makefile	/^AUTOHEADER = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run autoheader$/;"	m
AUTOMAKE	Makefile	/^AUTOMAKE = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run automake-1.10$/;"	m
AUTOMAKE	sample/Makefile	/^AUTOMAKE = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run automake-1.10$/;"	m
AUTOMAKE	test/Makefile	/^AUTOMAKE = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run automake-1.10$/;"	m
AUTOMAKE_OPTIONS	Makefile	/^AUTOMAKE_OPTIONS = foreign no-dependencies$/;"	m
AUTOMAKE_OPTIONS	sample/Makefile	/^AUTOMAKE_OPTIONS = foreign no-dependencies$/;"	m
AUTOMAKE_OPTIONS	test/Makefile	/^AUTOMAKE_OPTIONS = foreign no-dependencies$/;"	m
AWK	Makefile	/^AWK = mawk$/;"	m
AWK	sample/Makefile	/^AWK = mawk$/;"	m
AWK	test/Makefile	/^AWK = mawk$/;"	m
AddDeclaration	event_rpcgen.py	/^    def AddDeclaration(self, funcname):$/;"	m	class:EntryArray	access:public
AddEntry	event_rpcgen.py	/^    def AddEntry(self, entry):$/;"	m	class:Struct	access:public
AddFuncName	event_rpcgen.py	/^    def AddFuncName(self):$/;"	m	class:Entry	access:public
Array	event_rpcgen.py	/^    def Array(self):$/;"	m	class:Entry	access:public
AssignDeclaration	event_rpcgen.py	/^    def AssignDeclaration(self, funcname):$/;"	m	class:Entry	access:public
AssignDeclaration	event_rpcgen.py	/^    def AssignDeclaration(self, funcname):$/;"	m	class:EntryArray	access:public
AssignDeclaration	event_rpcgen.py	/^    def AssignDeclaration(self, funcname):$/;"	m	class:EntryBytes	access:public
AssignDeclaration	event_rpcgen.py	/^    def AssignDeclaration(self, funcname):$/;"	m	class:EntryVarBytes	access:public
AssignFuncName	event_rpcgen.py	/^    def AssignFuncName(self):$/;"	m	class:Entry	access:public
BUILT_SOURCES	Makefile	/^BUILT_SOURCES = event-config.h$/;"	m
BUILT_SOURCES	test/Makefile	/^BUILT_SOURCES = regress.gen.c regress.gen.h$/;"	m
BodyPreamble	event_rpcgen.py	/^def BodyPreamble(name):$/;"	f	access:public
CC	Makefile	/^CC = gcc$/;"	m
CC	sample/Makefile	/^CC = gcc$/;"	m
CC	test/Makefile	/^CC = gcc$/;"	m
CCDEPMODE	Makefile	/^CCDEPMODE = depmode=none$/;"	m
CCDEPMODE	sample/Makefile	/^CCDEPMODE = depmode=none$/;"	m
CCDEPMODE	test/Makefile	/^CCDEPMODE = depmode=none$/;"	m
CCLD	Makefile	/^CCLD = $(CC)$/;"	m
CCLD	sample/Makefile	/^CCLD = $(CC)$/;"	m
CCLD	test/Makefile	/^CCLD = $(CC)$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -O2 -Wall$/;"	m
CFLAGS	sample/Makefile	/^CFLAGS = -g -O2 -Wall$/;"	m
CFLAGS	test/Makefile	/^CFLAGS = -g -O2 -Wall$/;"	m
CHUNKS	test/regress_http.c	/^static char const* const CHUNKS[] = {$/;"	v	file:
CIRCLEQ_EMPTY	compat/sys/queue.h	401;"	d
CIRCLEQ_END	compat/sys/queue.h	398;"	d
CIRCLEQ_ENTRY	compat/sys/queue.h	387;"	d
CIRCLEQ_FIRST	compat/sys/queue.h	396;"	d
CIRCLEQ_FOREACH	compat/sys/queue.h	404;"	d
CIRCLEQ_FOREACH_REVERSE	compat/sys/queue.h	409;"	d
CIRCLEQ_HEAD	compat/sys/queue.h	378;"	d
CIRCLEQ_HEAD_INITIALIZER	compat/sys/queue.h	384;"	d
CIRCLEQ_INIT	compat/sys/queue.h	417;"	d
CIRCLEQ_INSERT_AFTER	compat/sys/queue.h	422;"	d
CIRCLEQ_INSERT_BEFORE	compat/sys/queue.h	432;"	d
CIRCLEQ_INSERT_HEAD	compat/sys/queue.h	442;"	d
CIRCLEQ_INSERT_TAIL	compat/sys/queue.h	452;"	d
CIRCLEQ_LAST	compat/sys/queue.h	397;"	d
CIRCLEQ_NEXT	compat/sys/queue.h	399;"	d
CIRCLEQ_PREV	compat/sys/queue.h	400;"	d
CIRCLEQ_REMOVE	compat/sys/queue.h	462;"	d
CIRCLEQ_REPLACE	compat/sys/queue.h	475;"	d
CLASS_INET	evdns.c	157;"	d	file:
CLOCK_PROF	compat/sys/_time.h	156;"	d
CLOCK_REALTIME	compat/sys/_time.h	154;"	d
CLOCK_VIRTUAL	compat/sys/_time.h	155;"	d
CLOSE_SOCKET	evdns.c	377;"	d	file:
COMPILE	Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
COMPILE	sample/Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
COMPILE	test/Makefile	/^COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\$/;"	m
CONFIG_CLEAN_FILES	Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_FILES	sample/Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_FILES	test/Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_HEADER	Makefile	/^CONFIG_HEADER = config.h$/;"	m
CONFIG_HEADER	sample/Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
CONFIG_HEADER	test/Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
CORE_SRC	Makefile	/^CORE_SRC = event.c buffer.c evbuffer.c log.c evutil.c $(SYS_SRC)$/;"	m
CPP	Makefile	/^CPP = gcc -E$/;"	m
CPP	sample/Makefile	/^CPP = gcc -E$/;"	m
CPP	test/Makefile	/^CPP = gcc -E$/;"	m
CPPFLAGS	Makefile	/^CPPFLAGS = $/;"	m
CPPFLAGS	sample/Makefile	/^CPPFLAGS = $/;"	m
CPPFLAGS	test/Makefile	/^CPPFLAGS = $/;"	m
CTAGS	Makefile	/^CTAGS = ctags$/;"	m
CTAGS	sample/Makefile	/^CTAGS = ctags$/;"	m
CTAGS	test/Makefile	/^CTAGS = ctags$/;"	m
CYGPATH_W	Makefile	/^CYGPATH_W = echo$/;"	m
CYGPATH_W	sample/Makefile	/^CYGPATH_W = echo$/;"	m
CYGPATH_W	test/Makefile	/^CYGPATH_W = echo$/;"	m
CodeAdd	event_rpcgen.py	/^    def CodeAdd(self):$/;"	f	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	f	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:Entry	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:EntryBytes	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:EntryString	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:EntryStruct	access:public
CodeAssign	event_rpcgen.py	/^    def CodeAssign(self):$/;"	m	class:EntryVarBytes	access:public
CodeBase	event_rpcgen.py	/^    def CodeBase(self):$/;"	m	class:Entry	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	f	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:Entry	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:EntryBytes	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:EntryString	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:EntryStruct	access:public
CodeClear	event_rpcgen.py	/^    def CodeClear(self, structname):$/;"	m	class:EntryVarBytes	access:public
CodeComplete	event_rpcgen.py	/^    def CodeComplete(self, structname):$/;"	f	access:public
CodeComplete	event_rpcgen.py	/^    def CodeComplete(self, structname):$/;"	m	class:Entry	access:public
CodeComplete	event_rpcgen.py	/^    def CodeComplete(self, structname):$/;"	m	class:EntryStruct	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, name):$/;"	f	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, name):$/;"	m	class:Entry	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, name):$/;"	m	class:EntryString	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, name):$/;"	m	class:EntryStruct	access:public
CodeFree	event_rpcgen.py	/^    def CodeFree(self, name):$/;"	m	class:EntryVarBytes	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:Entry	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:EntryArray	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:EntryBytes	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:EntryStruct	access:public
CodeGet	event_rpcgen.py	/^    def CodeGet(self):$/;"	m	class:EntryVarBytes	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name):$/;"	f	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryBytes	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryInt	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryString	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryStruct	access:public
CodeMarshal	event_rpcgen.py	/^    def CodeMarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryVarBytes	access:public
CodeNew	event_rpcgen.py	/^    def CodeNew(self, name):$/;"	f	access:public
CodeNew	event_rpcgen.py	/^    def CodeNew(self, name):$/;"	m	class:EntryBytes	access:public
CodeNew	event_rpcgen.py	/^    def CodeNew(self, name):$/;"	m	class:EntryInt	access:public
CodeNew	event_rpcgen.py	/^    def CodeNew(self, name):$/;"	m	class:EntryString	access:public
CodeNew	event_rpcgen.py	/^    def CodeNew(self, name):$/;"	m	class:EntryStruct	access:public
CodeNew	event_rpcgen.py	/^    def CodeNew(self, name):$/;"	m	class:EntryVarBytes	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name):$/;"	f	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryBytes	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryInt	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryString	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryStruct	access:public
CodeUnmarshal	event_rpcgen.py	/^    def CodeUnmarshal(self, buf, tag_name, var_name):$/;"	m	class:EntryVarBytes	access:public
DATA_CORRUPTED	http-internal.h	/^	DATA_CORRUPTED = -1,$/;"	e	enum:message_read_status
DEFAULT_INCLUDES	Makefile	/^DEFAULT_INCLUDES = -I.$/;"	m
DEFAULT_INCLUDES	sample/Makefile	/^DEFAULT_INCLUDES = -I. -I$(top_builddir)$/;"	m
DEFAULT_INCLUDES	test/Makefile	/^DEFAULT_INCLUDES = -I. -I$(top_builddir)$/;"	m
DEFAULT_NFDS	evport.c	84;"	d	file:
DEFS	Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEFS	sample/Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEFS	test/Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEPDIR	Makefile	/^DEPDIR = .deps$/;"	m
DEPDIR	sample/Makefile	/^DEPDIR = .deps$/;"	m
DEPDIR	test/Makefile	/^DEPDIR = .deps$/;"	m
DISTCLEANFILES	Makefile	/^DISTCLEANFILES = *~ event-config.h$/;"	m
DISTCLEANFILES	sample/Makefile	/^DISTCLEANFILES = *~$/;"	m
DISTCLEANFILES	test/Makefile	/^DISTCLEANFILES = *~$/;"	m
DISTFILES	Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DISTFILES	sample/Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DISTFILES	test/Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DIST_ARCHIVES	Makefile	/^DIST_ARCHIVES = $(distdir).tar.gz$/;"	m
DIST_COMMON	Makefile	/^DIST_COMMON = README $(am__configure_deps) $(include_HEADERS) \\$/;"	m
DIST_COMMON	sample/Makefile	/^DIST_COMMON = $(srcdir)\/Makefile.am $(srcdir)\/Makefile.in$/;"	m
DIST_COMMON	test/Makefile	/^DIST_COMMON = $(srcdir)\/Makefile.am $(srcdir)\/Makefile.in$/;"	m
DIST_SOURCES	Makefile	/^DIST_SOURCES = $(am__libevent_la_SOURCES_DIST) \\$/;"	m
DIST_SOURCES	sample/Makefile	/^DIST_SOURCES = event-test.c signal-test.c time-test.c$/;"	m
DIST_SOURCES	test/Makefile	/^DIST_SOURCES = $(bench_SOURCES) $(regress_SOURCES) $(test_eof_SOURCES) \\$/;"	m
DIST_SUBDIRS	Makefile	/^DIST_SUBDIRS = . sample test$/;"	m
DNS_ERR_FORMAT	evdns.h	173;"	d
DNS_ERR_NONE	evdns.h	171;"	d
DNS_ERR_NOTEXIST	evdns.h	178;"	d
DNS_ERR_NOTIMPL	evdns.h	180;"	d
DNS_ERR_REFUSED	evdns.h	183;"	d
DNS_ERR_SERVERFAILED	evdns.h	176;"	d
DNS_ERR_SHUTDOWN	evdns.h	191;"	d
DNS_ERR_TIMEOUT	evdns.h	189;"	d
DNS_ERR_TRUNCATED	evdns.h	185;"	d
DNS_ERR_UNKNOWN	evdns.h	187;"	d
DNS_IPv4_A	evdns.h	193;"	d
DNS_IPv6_AAAA	evdns.h	195;"	d
DNS_NO_SEARCH	evdns.h	467;"	d
DNS_OPTIONS_ALL	evdns.h	202;"	d
DNS_OPTION_MISC	evdns.h	201;"	d
DNS_OPTION_NAMESERVERS	evdns.h	200;"	d
DNS_OPTION_SEARCH	evdns.h	199;"	d
DNS_PTR	evdns.h	194;"	d
DNS_QUERY_NO_SEARCH	evdns.h	197;"	d
DNS_USE_CPU_CLOCK_FOR_ID	config.h	5;"	d
DNS_USE_FTIME_FOR_ID	WIN32-Code/config.h	8;"	d
DST_AUST	compat/sys/_time.h	72;"	d
DST_CAN	compat/sys/_time.h	76;"	d
DST_EET	compat/sys/_time.h	75;"	d
DST_MET	compat/sys/_time.h	74;"	d
DST_NONE	compat/sys/_time.h	70;"	d
DST_USA	compat/sys/_time.h	71;"	d
DST_WET	compat/sys/_time.h	73;"	d
DSYMUTIL	Makefile	/^DSYMUTIL = $/;"	m
DSYMUTIL	sample/Makefile	/^DSYMUTIL = $/;"	m
DSYMUTIL	test/Makefile	/^DSYMUTIL = $/;"	m
DUMPBIN	Makefile	/^DUMPBIN = $/;"	m
DUMPBIN	sample/Makefile	/^DUMPBIN = $/;"	m
DUMPBIN	test/Makefile	/^DUMPBIN = $/;"	m
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	f	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryBytes	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryInt	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryString	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryStruct	access:public
Declaration	event_rpcgen.py	/^    def Declaration(self):$/;"	m	class:EntryVarBytes	access:public
ECHO_C	Makefile	/^ECHO_C = $/;"	m
ECHO_C	sample/Makefile	/^ECHO_C = $/;"	m
ECHO_C	test/Makefile	/^ECHO_C = $/;"	m
ECHO_N	Makefile	/^ECHO_N = -n$/;"	m
ECHO_N	sample/Makefile	/^ECHO_N = -n$/;"	m
ECHO_N	test/Makefile	/^ECHO_N = -n$/;"	m
ECHO_T	Makefile	/^ECHO_T = $/;"	m
ECHO_T	sample/Makefile	/^ECHO_T = $/;"	m
ECHO_T	test/Makefile	/^ECHO_T = $/;"	m
EGREP	Makefile	/^EGREP = \/bin\/grep -E$/;"	m
EGREP	sample/Makefile	/^EGREP = \/bin\/grep -E$/;"	m
EGREP	test/Makefile	/^EGREP = \/bin\/grep -E$/;"	m
ERR_FORMAT	http.c	1865;"	d	file:
ERR_FORMAT	http.c	1884;"	d	file:
ERR_FORMAT	http.c	2164;"	d	file:
ERR_FORMAT	http.c	2183;"	d	file:
ETAGS	Makefile	/^ETAGS = etags$/;"	m
ETAGS	sample/Makefile	/^ETAGS = etags$/;"	m
ETAGS	test/Makefile	/^ETAGS = etags$/;"	m
EVBUFFER_DATA	event.h	960;"	d
EVBUFFER_EOF	event.h	737;"	d
EVBUFFER_ERROR	event.h	738;"	d
EVBUFFER_INITIAL_LENGTH	test/regress.c	923;"	d	file:
EVBUFFER_INPUT	event.h	961;"	d
EVBUFFER_LENGTH	event.h	959;"	d
EVBUFFER_MAX_READ	buffer.c	348;"	d	file:
EVBUFFER_OUTPUT	event.h	962;"	d
EVBUFFER_READ	event.h	735;"	d
EVBUFFER_TIMEOUT	event.h	739;"	d
EVBUFFER_WRITE	event.h	736;"	d
EVCON_CONNECTING	http-internal.h	/^	EVCON_CONNECTING,	\/**< tries to currently connect *\/$/;"	e	enum:evhttp_connection_state
EVCON_DISCONNECTED	http-internal.h	/^	EVCON_DISCONNECTED,	\/**< not currently connected not trying either*\/$/;"	e	enum:evhttp_connection_state
EVCON_HTTP_EOF	http-internal.h	/^	EVCON_HTTP_EOF,$/;"	e	enum:evhttp_connection_error
EVCON_HTTP_INVALID_HEADER	http-internal.h	/^	EVCON_HTTP_INVALID_HEADER$/;"	e	enum:evhttp_connection_error
EVCON_HTTP_TIMEOUT	http-internal.h	/^	EVCON_HTTP_TIMEOUT,$/;"	e	enum:evhttp_connection_error
EVCON_IDLE	http-internal.h	/^	EVCON_IDLE,		\/**< connection is established *\/$/;"	e	enum:evhttp_connection_state
EVCON_READING_BODY	http-internal.h	/^	EVCON_READING_BODY,	\/**< reading request\/response body *\/$/;"	e	enum:evhttp_connection_state
EVCON_READING_FIRSTLINE	http-internal.h	/^	EVCON_READING_FIRSTLINE,\/**< reading Request-Line (incoming conn) or$/;"	e	enum:evhttp_connection_state
EVCON_READING_HEADERS	http-internal.h	/^	EVCON_READING_HEADERS,	\/**< reading request\/response headers *\/$/;"	e	enum:evhttp_connection_state
EVCON_READING_TRAILER	http-internal.h	/^	EVCON_READING_TRAILER,	\/**< reading request\/response chunked trailer *\/$/;"	e	enum:evhttp_connection_state
EVCON_WRITING	http-internal.h	/^	EVCON_WRITING		\/**< writing request\/response headers\/body *\/$/;"	e	enum:evhttp_connection_state
EVDNS_ADDITIONAL_SECTION	evdns.h	494;"	d
EVDNS_ANSWER_SECTION	evdns.h	492;"	d
EVDNS_AUTHORITY_SECTION	evdns.h	493;"	d
EVDNS_CLASS_INET	evdns.h	508;"	d
EVDNS_LOG_CHECK	evdns.c	404;"	d	file:
EVDNS_LOG_CHECK	evdns.c	406;"	d	file:
EVDNS_LOG_DEBUG	evdns.c	118;"	d	file:
EVDNS_LOG_WARN	evdns.c	119;"	d	file:
EVDNS_QTYPE_ALL	evdns.h	506;"	d
EVDNS_QTYPE_AXFR	evdns.h	505;"	d
EVDNS_TYPE_A	evdns.h	496;"	d
EVDNS_TYPE_AAAA	evdns.h	503;"	d
EVDNS_TYPE_CNAME	evdns.h	498;"	d
EVDNS_TYPE_MX	evdns.h	501;"	d
EVDNS_TYPE_NS	evdns.h	497;"	d
EVDNS_TYPE_PTR	evdns.h	500;"	d
EVDNS_TYPE_SOA	evdns.h	499;"	d
EVDNS_TYPE_TXT	evdns.h	502;"	d
EVENTDNS_H	evdns.h	161;"	d
EVENTS_PER_GETN	evport.c	92;"	d	file:
EVENT_FD	event.h	237;"	d
EVENT_SIGNAL	event.h	236;"	d
EVHTTP_BASE_SET	http.c	193;"	d	file:
EVHTTP_CON_CLOSEDETECT	http-internal.h	72;"	d
EVHTTP_CON_INCOMING	http-internal.h	70;"	d
EVHTTP_CON_OUTGOING	http-internal.h	71;"	d
EVHTTP_PROXY_REQUEST	evhttp.h	202;"	d
EVHTTP_REQUEST	evhttp.h	/^enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };$/;"	e	enum:evhttp_request_kind
EVHTTP_REQ_GET	evhttp.h	/^enum evhttp_cmd_type { EVHTTP_REQ_GET, EVHTTP_REQ_POST, EVHTTP_REQ_HEAD };$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_HEAD	evhttp.h	/^enum evhttp_cmd_type { EVHTTP_REQ_GET, EVHTTP_REQ_POST, EVHTTP_REQ_HEAD };$/;"	e	enum:evhttp_cmd_type
EVHTTP_REQ_OWN_CONNECTION	evhttp.h	201;"	d
EVHTTP_REQ_POST	evhttp.h	/^enum evhttp_cmd_type { EVHTTP_REQ_GET, EVHTTP_REQ_POST, EVHTTP_REQ_HEAD };$/;"	e	enum:evhttp_cmd_type
EVHTTP_RESPONSE	evhttp.h	/^enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };$/;"	e	enum:evhttp_request_kind
EVLIST_ACTIVE	event.h	188;"	d
EVLIST_ALL	event.h	193;"	d
EVLIST_INIT	event.h	190;"	d
EVLIST_INSERTED	event.h	186;"	d
EVLIST_INTERNAL	event.h	189;"	d
EVLIST_SIGNAL	event.h	187;"	d
EVLIST_TIMEOUT	event.h	185;"	d
EVLIST_X_KQINKERNEL	kqueue.c	66;"	d	file:
EVLOOP_NONBLOCK	event.h	362;"	d
EVLOOP_ONCE	event.h	361;"	d
EVRPC_GENERATE	evrpc.h	179;"	d
EVRPC_HEADER	evrpc.h	154;"	d
EVRPC_HOOK_TYPE	evrpc.h	/^enum EVRPC_HOOK_TYPE {$/;"	g
EVRPC_INPUT	evrpc.h	/^	EVRPC_INPUT,		\/**< apply the function to an input hook *\/$/;"	e	enum:EVRPC_HOOK_TYPE
EVRPC_MAKE_REQUEST	evrpc.h	387;"	d
EVRPC_OUTPUT	evrpc.h	/^	EVRPC_OUTPUT		\/**< apply the function to an output hook *\/$/;"	e	enum:EVRPC_HOOK_TYPE
EVRPC_REGISTER	evrpc.h	295;"	d
EVRPC_REGISTER_OBJECT	evrpc.h	240;"	d
EVRPC_REQUEST_DONE	evrpc.h	233;"	d
EVRPC_REQUEST_HTTP	evrpc.h	223;"	d
EVRPC_STATUS_ERR_BADPAYLOAD	evrpc.h	331;"	d
EVRPC_STATUS_ERR_HOOKABORTED	evrpc.h	333;"	d
EVRPC_STATUS_ERR_NONE	evrpc.h	329;"	d
EVRPC_STATUS_ERR_TIMEOUT	evrpc.h	330;"	d
EVRPC_STATUS_ERR_UNSTARTED	evrpc.h	332;"	d
EVRPC_STRUCT	evrpc.h	113;"	d
EVRPC_STRUCT	test/regress_rpc.c	/^MessageCb(EVRPC_STRUCT(Message)* rpc, void *arg)$/;"	f	file:
EVRPC_STRUCT	test/regress_rpc.c	/^NeverReplyCb(EVRPC_STRUCT(NeverReply)* rpc, void *arg)$/;"	f	file:
EVRPC_STRUCT	test/regress_rpc.c	/^static EVRPC_STRUCT(NeverReply) *saved_rpc;$/;"	p	file:
EVRPC_UNREGISTER	evrpc.h	314;"	d
EVRPC_URI_PREFIX	evrpc-internal.h	34;"	d
EVTAG_ADD	test/regress.gen.h	15;"	d
EVTAG_ASSIGN	test/regress.gen.h	13;"	d
EVTAG_GET	test/regress.gen.h	14;"	d
EVTAG_HAS	test/regress.gen.h	12;"	d
EVTAG_LEN	test/regress.gen.h	16;"	d
EVUTIL_CLOSESOCKET	evutil.h	104;"	d
EVUTIL_CLOSESOCKET	evutil.h	106;"	d
EVUTIL_SET_SOCKET_ERROR	evutil.h	111;"	d
EVUTIL_SET_SOCKET_ERROR	evutil.h	115;"	d
EVUTIL_SOCKET_ERROR	evutil.h	110;"	d
EVUTIL_SOCKET_ERROR	evutil.h	114;"	d
EV_CHECK_FMT	log.h	31;"	d
EV_CHECK_FMT	log.h	33;"	d
EV_CHECK_FMT	log.h	49;"	d
EV_PERSIST	event.h	199;"	d
EV_READ	event.h	196;"	d
EV_SIGNAL	event.h	198;"	d
EV_TIMEOUT	event.h	195;"	d
EV_WRITE	event.h	197;"	d
EXEEXT	Makefile	/^EXEEXT = $/;"	m
EXEEXT	sample/Makefile	/^EXEEXT = $/;"	m
EXEEXT	test/Makefile	/^EXEEXT = $/;"	m
EXTRA_DIST	Makefile	/^EXTRA_DIST = autogen.sh event.h event-internal.h log.h evsignal.h evdns.3 \\$/;"	m
EXTRA_DIST	test/Makefile	/^EXTRA_DIST = regress.rpc regress.gen.h regress.gen.c$/;"	m
EXTRA_SRC	Makefile	/^EXTRA_SRC = event_tagging.c http.c evhttp.h http-internal.h evdns.c \\$/;"	m
Entry	event_rpcgen.py	/^class Entry:$/;"	c	inherits:
EntryArray	event_rpcgen.py	/^class EntryArray(Entry):$/;"	c	inherits:Entry
EntryBytes	event_rpcgen.py	/^class EntryBytes(Entry):$/;"	c	inherits:Entry
EntryInt	event_rpcgen.py	/^class EntryInt(Entry):$/;"	c	inherits:Entry
EntryString	event_rpcgen.py	/^class EntryString(Entry):$/;"	c	inherits:Entry
EntryStruct	event_rpcgen.py	/^class EntryStruct(Entry):$/;"	c	inherits:Entry
EntryTagName	event_rpcgen.py	/^    def EntryTagName(self, entry):$/;"	m	class:Struct	access:public
EntryVarBytes	event_rpcgen.py	/^class EntryVarBytes(Entry):$/;"	c	inherits:Entry
FDI_HAS_EVENTS	evport.c	106;"	d	file:
FDI_HAS_READ	evport.c	104;"	d	file:
FDI_HAS_WRITE	evport.c	105;"	d	file:
FDI_TO_SYSEVENTS	evport.c	107;"	d	file:
FD_CLOSEONEXEC	epoll.c	89;"	d	file:
FD_CLOSEONEXEC	epoll.c	94;"	d	file:
FD_CLOSEONEXEC	signal.c	87;"	d	file:
FD_CLOSEONEXEC	signal.c	92;"	d	file:
FD_SET_ALLOC_SIZE	WIN32-Code/win32.c	126;"	d	file:
FGREP	Makefile	/^FGREP = \/bin\/grep -F$/;"	m
FGREP	sample/Makefile	/^FGREP = \/bin\/grep -F$/;"	m
FGREP	test/Makefile	/^FGREP = \/bin\/grep -F$/;"	m
GET16	evdns.c	1036;"	d	file:
GET16	evdns.c	760;"	d	file:
GET32	evdns.c	1035;"	d	file:
GET32	evdns.c	759;"	d	file:
GET8	evdns.c	1037;"	d	file:
GET8	evdns.c	761;"	d	file:
GREP	Makefile	/^GREP = \/bin\/grep$/;"	m
GREP	sample/Makefile	/^GREP = \/bin\/grep$/;"	m
GREP	test/Makefile	/^GREP = \/bin\/grep$/;"	m
GZIP_ENV	Makefile	/^GZIP_ENV = --best$/;"	m
GetDeclaration	event_rpcgen.py	/^    def GetDeclaration(self, funcname):$/;"	m	class:Entry	access:public
GetDeclaration	event_rpcgen.py	/^    def GetDeclaration(self, funcname):$/;"	m	class:EntryArray	access:public
GetDeclaration	event_rpcgen.py	/^    def GetDeclaration(self, funcname):$/;"	m	class:EntryBytes	access:public
GetDeclaration	event_rpcgen.py	/^    def GetDeclaration(self, funcname):$/;"	m	class:EntryVarBytes	access:public
GetFuncName	event_rpcgen.py	/^    def GetFuncName(self):$/;"	m	class:Entry	access:public
GetNetworkParams_fn_t	evdns.c	/^typedef DWORD(WINAPI *GetNetworkParams_fn_t)(FIXED_INFO *, DWORD*);$/;"	t	file:
GetNextStruct	event_rpcgen.py	/^def GetNextStruct(file):$/;"	f	access:public
GetTranslation	event_rpcgen.py	/^    def GetTranslation(self):$/;"	m	class:Entry	access:public
GotErrorCb	test/regress_rpc.c	/^GotErrorCb(struct evrpc_status *status,$/;"	f	file:	signature:(struct evrpc_status *status, struct msg *msg, struct kill *kill, void *arg)
GotKillCb	test/regress_rpc.c	/^GotKillCb(struct evrpc_status *status,$/;"	f	file:	signature:(struct evrpc_status *status, struct msg *msg, struct kill *kill, void *arg)
GotKillCbTwo	test/regress_rpc.c	/^GotKillCbTwo(struct evrpc_status *status,$/;"	f	file:	signature:(struct evrpc_status *status, struct msg *msg, struct kill *kill, void *arg)
GuardName	event_rpcgen.py	/^def GuardName(name):$/;"	f	access:public
HAVE_CLOCK_GETTIME	config.h	11;"	d
HAVE_DLFCN_H	config.h	17;"	d
HAVE_EPOLL	config.h	20;"	d
HAVE_EPOLL_CTL	config.h	23;"	d
HAVE_FCNTL	config.h	29;"	d
HAVE_FCNTL_H	WIN32-Code/config.h	35;"	d
HAVE_FCNTL_H	config.h	32;"	d
HAVE_GETADDRINFO	config.h	35;"	d
HAVE_GETNAMEINFO	config.h	38;"	d
HAVE_GETTIMEOFDAY	config.h	41;"	d
HAVE_INET_NTOP	config.h	44;"	d
HAVE_INTTYPES_H	config.h	47;"	d
HAVE_LIBNSL	config.h	53;"	d
HAVE_LIBRESOLV	config.h	56;"	d
HAVE_LIBRT	config.h	59;"	d
HAVE_MEMORY_H	WIN32-Code/config.h	68;"	d
HAVE_MEMORY_H	config.h	65;"	d
HAVE_POLL	config.h	71;"	d
HAVE_POLL_H	config.h	74;"	d
HAVE_SELECT	config.h	83;"	d
HAVE_SETFD	config.h	86;"	d
HAVE_SIGACTION	config.h	89;"	d
HAVE_SIGNAL	WIN32-Code/config.h	95;"	d
HAVE_SIGNAL	config.h	92;"	d
HAVE_SIGNAL_H	WIN32-Code/config.h	98;"	d
HAVE_SIGNAL_H	config.h	95;"	d
HAVE_STDARG_H	WIN32-Code/config.h	101;"	d
HAVE_STDARG_H	config.h	98;"	d
HAVE_STDINT_H	config.h	101;"	d
HAVE_STDLIB_H	WIN32-Code/config.h	107;"	d
HAVE_STDLIB_H	config.h	104;"	d
HAVE_STRINGS_H	WIN32-Code/config.h	110;"	d
HAVE_STRINGS_H	config.h	107;"	d
HAVE_STRING_H	WIN32-Code/config.h	113;"	d
HAVE_STRING_H	config.h	110;"	d
HAVE_STRSEP	config.h	116;"	d
HAVE_STRTOK_R	config.h	119;"	d
HAVE_STRTOLL	config.h	122;"	d
HAVE_STRUCT_IN6_ADDR	WIN32-Code/config.h	125;"	d
HAVE_STRUCT_IN6_ADDR	config.h	125;"	d
HAVE_SYS_EPOLL_H	config.h	131;"	d
HAVE_SYS_IOCTL_H	config.h	137;"	d
HAVE_SYS_PARAM_H	config.h	140;"	d
HAVE_SYS_QUEUE_H	config.h	143;"	d
HAVE_SYS_SELECT_H	config.h	146;"	d
HAVE_SYS_SOCKET_H	config.h	149;"	d
HAVE_SYS_STAT_H	config.h	152;"	d
HAVE_SYS_TIME_H	config.h	155;"	d
HAVE_SYS_TYPES_H	config.h	158;"	d
HAVE_TAILQFOREACH	config.h	161;"	d
HAVE_TIMERADD	config.h	164;"	d
HAVE_TIMERCLEAR	config.h	167;"	d
HAVE_TIMERCMP	WIN32-Code/config.h	167;"	d
HAVE_TIMERCMP	config.h	170;"	d
HAVE_TIMERISSET	WIN32-Code/config.h	170;"	d
HAVE_TIMERISSET	config.h	173;"	d
HAVE_UINT16_T	config.h	176;"	d
HAVE_UINT32_T	config.h	179;"	d
HAVE_UINT64_T	config.h	182;"	d
HAVE_UINT8_T	config.h	185;"	d
HAVE_UNISTD_H	config.h	188;"	d
HAVE_VASPRINTF	config.h	191;"	d
HEADERS	Makefile	/^HEADERS = $(include_HEADERS)$/;"	m
HOST_NAME_MAX	evdns.c	122;"	d	file:
HTTP_BADREQUEST	evhttp.h	60;"	d
HTTP_CONNECT_TIMEOUT	http-internal.h	13;"	d
HTTP_DEFAULTPORT	http-internal.h	18;"	d
HTTP_MOVEPERM	evhttp.h	57;"	d
HTTP_MOVETEMP	evhttp.h	58;"	d
HTTP_NOCONTENT	evhttp.h	56;"	d
HTTP_NOTFOUND	evhttp.h	61;"	d
HTTP_NOTMODIFIED	evhttp.h	59;"	d
HTTP_OK	evhttp.h	55;"	d
HTTP_PREFIX	http-internal.h	17;"	d
HTTP_READ_TIMEOUT	http-internal.h	15;"	d
HTTP_SERVUNAVAIL	evhttp.h	62;"	d
HTTP_WRITE_TIMEOUT	http-internal.h	14;"	d
HeaderPostamble	event_rpcgen.py	/^def HeaderPostamble(name):$/;"	f	access:public
HeaderPreamble	event_rpcgen.py	/^def HeaderPreamble(name):$/;"	f	access:public
INCLUDES	Makefile	/^INCLUDES = -I$(srcdir)\/compat $(SYS_INCLUDES)$/;"	m
INPUT	evrpc.h	446;"	d
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL	sample/Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL	test/Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_DATA	sample/Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_DATA	test/Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_HEADER	Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_HEADER	sample/Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_HEADER	test/Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_PROGRAM	sample/Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_PROGRAM	test/Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_SCRIPT	Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_SCRIPT	sample/Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_SCRIPT	test/Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_STRIP_PROGRAM	Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
INSTALL_STRIP_PROGRAM	sample/Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
INSTALL_STRIP_PROGRAM	test/Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
ISDIGIT	evdns.c	380;"	d	file:
ISSPACE	evdns.c	379;"	d	file:
ITIMER_PROF	compat/sys/_time.h	136;"	d
ITIMER_REAL	compat/sys/_time.h	134;"	d
ITIMER_VIRTUAL	compat/sys/_time.h	135;"	d
KILL_ACTION	test/regress.gen.h	/^  KILL_ACTION=2,$/;"	e	enum:kill_
KILL_HOW_OFTEN	test/regress.gen.h	/^  KILL_HOW_OFTEN=3,$/;"	e	enum:kill_
KILL_MAX_TAGS	test/regress.gen.h	/^  KILL_MAX_TAGS$/;"	e	enum:kill_
KILL_WEAPON	test/regress.gen.h	/^  KILL_WEAPON=65825,$/;"	e	enum:kill_
LD	Makefile	/^LD = \/usr\/bin\/ld$/;"	m
LD	sample/Makefile	/^LD = \/usr\/bin\/ld$/;"	m
LD	test/Makefile	/^LD = \/usr\/bin\/ld$/;"	m
LDADD	sample/Makefile	/^LDADD = ..\/libevent.la$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = $/;"	m
LDFLAGS	sample/Makefile	/^LDFLAGS = $/;"	m
LDFLAGS	test/Makefile	/^LDFLAGS = $/;"	m
LIBOBJS	Makefile	/^LIBOBJS =  ${LIBOBJDIR}select$U.o ${LIBOBJDIR}poll$U.o ${LIBOBJDIR}epoll$U.o ${LIBOBJDIR}signal$U.o$/;"	m
LIBOBJS	sample/Makefile	/^LIBOBJS =  ${LIBOBJDIR}select$U.o ${LIBOBJDIR}poll$U.o ${LIBOBJDIR}epoll$U.o ${LIBOBJDIR}signal$U.o$/;"	m
LIBOBJS	test/Makefile	/^LIBOBJS =  ${LIBOBJDIR}select$U.o ${LIBOBJDIR}poll$U.o ${LIBOBJDIR}epoll$U.o ${LIBOBJDIR}signal$U.o$/;"	m
LIBS	Makefile	/^LIBS = -lnsl -lrt -lresolv $/;"	m
LIBS	sample/Makefile	/^LIBS = -lnsl -lrt -lresolv $/;"	m
LIBS	test/Makefile	/^LIBS = -lnsl -lrt -lresolv $/;"	m
LIBTOOL	Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LIBTOOL	sample/Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LIBTOOL	test/Makefile	/^LIBTOOL = $(SHELL) $(top_builddir)\/libtool$/;"	m
LIBTOOL_DEPS	Makefile	/^LIBTOOL_DEPS = .\/ltmain.sh$/;"	m
LIBTOOL_DEPS	sample/Makefile	/^LIBTOOL_DEPS = .\/ltmain.sh$/;"	m
LIBTOOL_DEPS	test/Makefile	/^LIBTOOL_DEPS = .\/ltmain.sh$/;"	m
LINK	Makefile	/^LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LINK	sample/Makefile	/^LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LINK	test/Makefile	/^LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LIPO	Makefile	/^LIPO = $/;"	m
LIPO	sample/Makefile	/^LIPO = $/;"	m
LIPO	test/Makefile	/^LIPO = $/;"	m
LIST_EMPTY	compat/sys/queue.h	159;"	d
LIST_END	compat/sys/queue.h	158;"	d
LIST_ENTRY	compat/sys/queue.h	148;"	d
LIST_FIRST	compat/sys/queue.h	157;"	d
LIST_FOREACH	compat/sys/queue.h	162;"	d
LIST_HEAD	compat/sys/queue.h	140;"	d
LIST_HEAD_INITIALIZER	compat/sys/queue.h	145;"	d
LIST_INIT	compat/sys/queue.h	170;"	d
LIST_INSERT_AFTER	compat/sys/queue.h	174;"	d
LIST_INSERT_BEFORE	compat/sys/queue.h	182;"	d
LIST_INSERT_HEAD	compat/sys/queue.h	189;"	d
LIST_NEXT	compat/sys/queue.h	160;"	d
LIST_REMOVE	compat/sys/queue.h	196;"	d
LIST_REPLACE	compat/sys/queue.h	203;"	d
LN_S	Makefile	/^LN_S = ln -s$/;"	m
LN_S	sample/Makefile	/^LN_S = ln -s$/;"	m
LN_S	test/Makefile	/^LN_S = ln -s$/;"	m
LTCOMPILE	Makefile	/^LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LTCOMPILE	sample/Makefile	/^LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LTCOMPILE	test/Makefile	/^LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\$/;"	m
LTLIBOBJS	Makefile	/^LTLIBOBJS =  ${LIBOBJDIR}select$U.lo ${LIBOBJDIR}poll$U.lo ${LIBOBJDIR}epoll$U.lo ${LIBOBJDIR}signal$U.lo$/;"	m
LTLIBOBJS	sample/Makefile	/^LTLIBOBJS =  ${LIBOBJDIR}select$U.lo ${LIBOBJDIR}poll$U.lo ${LIBOBJDIR}epoll$U.lo ${LIBOBJDIR}signal$U.lo$/;"	m
LTLIBOBJS	test/Makefile	/^LTLIBOBJS =  ${LIBOBJDIR}select$U.lo ${LIBOBJDIR}poll$U.lo ${LIBOBJDIR}epoll$U.lo ${LIBOBJDIR}signal$U.lo$/;"	m
LTLIBRARIES	Makefile	/^LTLIBRARIES = $(lib_LTLIBRARIES)$/;"	m
LT_OBJDIR	config.h	198;"	d
LineCount	event_rpcgen.py	/^    def LineCount(self):$/;"	m	class:Entry	access:public
MAKEINFO	Makefile	/^MAKEINFO = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run makeinfo$/;"	m
MAKEINFO	sample/Makefile	/^MAKEINFO = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run makeinfo$/;"	m
MAKEINFO	test/Makefile	/^MAKEINFO = ${SHELL} \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/missing --run makeinfo$/;"	m
MANS	Makefile	/^MANS = $(man_MANS)$/;"	m
MAX_ADDRS	evdns.c	149;"	d	file:
MAX_EPOLL_TIMEOUT_MSEC	epoll.c	105;"	d	file:
MAX_LABELS	evdns.c	1281;"	d	file:
MIN	evdns.c	127;"	d	file:
MIN	evdns.c	128;"	d	file:
MIN	http.c	189;"	d	file:
MKDIR_P	Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
MKDIR_P	sample/Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
MKDIR_P	test/Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
MORE_DATA_EXPECTED	http-internal.h	/^	MORE_DATA_EXPECTED = 0,$/;"	e	enum:message_read_status
MSG_ATTACK	test/regress.gen.h	/^  MSG_ATTACK=3,$/;"	e	enum:msg_
MSG_FROM_NAME	test/regress.gen.h	/^  MSG_FROM_NAME=1,$/;"	e	enum:msg_
MSG_MAX_TAGS	test/regress.gen.h	/^  MSG_MAX_TAGS$/;"	e	enum:msg_
MSG_RUN	test/regress.gen.h	/^  MSG_RUN=4,$/;"	e	enum:msg_
MSG_TO_NAME	test/regress.gen.h	/^  MSG_TO_NAME=2,$/;"	e	enum:msg_
MakeArray	event_rpcgen.py	/^    def MakeArray(self, yes=1):$/;"	m	class:Entry	access:public
MakeOptional	event_rpcgen.py	/^    def MakeOptional(self):$/;"	m	class:Entry	access:public
NEVENT	WIN32-Code/win32.c	231;"	d	file:
NEVENT	devpoll.c	88;"	d	file:
NEVENT	epoll.c	97;"	d	file:
NEVENT	kqueue.c	68;"	d	file:
NEVENT	test/test-time.c	24;"	d	file:
NEXT_TOKEN	evdns.c	2674;"	d	file:
NEXT_TOKEN	evdns.c	2708;"	d	file:
NI_MAXHOST	http.c	100;"	d	file:
NI_MAXSERV	http.c	99;"	d	file:
NI_MAXSERV	test/regress_http.c	106;"	d	file:
NI_NUMERICHOST	http.c	102;"	d	file:
NI_NUMERICSERV	http.c	103;"	d	file:
NM	Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NM	sample/Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NM	test/Makefile	/^NM = \/usr\/bin\/nm -B$/;"	m
NMEDIT	Makefile	/^NMEDIT = $/;"	m
NMEDIT	sample/Makefile	/^NMEDIT = $/;"	m
NMEDIT	test/Makefile	/^NMEDIT = $/;"	m
NORMAL_INSTALL	Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_INSTALL	sample/Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_INSTALL	test/Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_UNINSTALL	Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NORMAL_UNINSTALL	sample/Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NORMAL_UNINSTALL	test/Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NROFF	Makefile	/^NROFF = nroff$/;"	m
Name	event_rpcgen.py	/^    def Name(self):$/;"	m	class:Entry	access:public
Name	event_rpcgen.py	/^    def Name(self):$/;"	m	class:Struct	access:public
NormalizeLine	event_rpcgen.py	/^def NormalizeLine(line):$/;"	f	access:public
OBJEXT	Makefile	/^OBJEXT = o$/;"	m
OBJEXT	sample/Makefile	/^OBJEXT = o$/;"	m
OBJEXT	test/Makefile	/^OBJEXT = o$/;"	m
OFFSET_OF	evdns.c	286;"	d	file:
OTOOL	Makefile	/^OTOOL = $/;"	m
OTOOL	sample/Makefile	/^OTOOL = $/;"	m
OTOOL	test/Makefile	/^OTOOL = $/;"	m
OTOOL64	Makefile	/^OTOOL64 = $/;"	m
OTOOL64	sample/Makefile	/^OTOOL64 = $/;"	m
OTOOL64	test/Makefile	/^OTOOL64 = $/;"	m
OUTPUT	evrpc.h	449;"	d
Optional	event_rpcgen.py	/^    def Optional(self):$/;"	m	class:Entry	access:public
PACKAGE	Makefile	/^PACKAGE = libevent$/;"	m
PACKAGE	WIN32-Code/config.h	182;"	d
PACKAGE	config.h	201;"	d
PACKAGE	sample/Makefile	/^PACKAGE = libevent$/;"	m
PACKAGE	test/Makefile	/^PACKAGE = libevent$/;"	m
PACKAGE_BUGREPORT	Makefile	/^PACKAGE_BUGREPORT = $/;"	m
PACKAGE_BUGREPORT	WIN32-Code/config.h	185;"	d
PACKAGE_BUGREPORT	config.h	204;"	d
PACKAGE_BUGREPORT	sample/Makefile	/^PACKAGE_BUGREPORT = $/;"	m
PACKAGE_BUGREPORT	test/Makefile	/^PACKAGE_BUGREPORT = $/;"	m
PACKAGE_NAME	Makefile	/^PACKAGE_NAME = $/;"	m
PACKAGE_NAME	WIN32-Code/config.h	188;"	d
PACKAGE_NAME	config.h	207;"	d
PACKAGE_NAME	sample/Makefile	/^PACKAGE_NAME = $/;"	m
PACKAGE_NAME	test/Makefile	/^PACKAGE_NAME = $/;"	m
PACKAGE_STRING	Makefile	/^PACKAGE_STRING = $/;"	m
PACKAGE_STRING	WIN32-Code/config.h	191;"	d
PACKAGE_STRING	config.h	210;"	d
PACKAGE_STRING	sample/Makefile	/^PACKAGE_STRING = $/;"	m
PACKAGE_STRING	test/Makefile	/^PACKAGE_STRING = $/;"	m
PACKAGE_TARNAME	Makefile	/^PACKAGE_TARNAME = $/;"	m
PACKAGE_TARNAME	WIN32-Code/config.h	194;"	d
PACKAGE_TARNAME	config.h	213;"	d
PACKAGE_TARNAME	sample/Makefile	/^PACKAGE_TARNAME = $/;"	m
PACKAGE_TARNAME	test/Makefile	/^PACKAGE_TARNAME = $/;"	m
PACKAGE_URL	config.h	216;"	d
PACKAGE_VERSION	Makefile	/^PACKAGE_VERSION = $/;"	m
PACKAGE_VERSION	WIN32-Code/config.h	197;"	d
PACKAGE_VERSION	config.h	219;"	d
PACKAGE_VERSION	sample/Makefile	/^PACKAGE_VERSION = $/;"	m
PACKAGE_VERSION	test/Makefile	/^PACKAGE_VERSION = $/;"	m
PATH_SEPARATOR	Makefile	/^PATH_SEPARATOR = :$/;"	m
PATH_SEPARATOR	sample/Makefile	/^PATH_SEPARATOR = :$/;"	m
PATH_SEPARATOR	test/Makefile	/^PATH_SEPARATOR = :$/;"	m
POST_DATA	test/regress_http.c	671;"	d	file:
POST_INSTALL	Makefile	/^POST_INSTALL = :$/;"	m
POST_INSTALL	sample/Makefile	/^POST_INSTALL = :$/;"	m
POST_INSTALL	test/Makefile	/^POST_INSTALL = :$/;"	m
POST_UNINSTALL	Makefile	/^POST_UNINSTALL = :$/;"	m
POST_UNINSTALL	sample/Makefile	/^POST_UNINSTALL = :$/;"	m
POST_UNINSTALL	test/Makefile	/^POST_UNINSTALL = :$/;"	m
PRE_INSTALL	Makefile	/^PRE_INSTALL = :$/;"	m
PRE_INSTALL	sample/Makefile	/^PRE_INSTALL = :$/;"	m
PRE_INSTALL	test/Makefile	/^PRE_INSTALL = :$/;"	m
PRE_UNINSTALL	Makefile	/^PRE_UNINSTALL = :$/;"	m
PRE_UNINSTALL	sample/Makefile	/^PRE_UNINSTALL = :$/;"	m
PRE_UNINSTALL	test/Makefile	/^PRE_UNINSTALL = :$/;"	m
PROGRAMS	sample/Makefile	/^PROGRAMS = $(noinst_PROGRAMS)$/;"	m
PROGRAMS	test/Makefile	/^PROGRAMS = $(noinst_PROGRAMS)$/;"	m
PTR_TO_UDATA	kqueue.c	56;"	d	file:
PTR_TO_UDATA	kqueue.c	58;"	d	file:
Parse	event_rpcgen.py	/^def Parse(file):$/;"	f	access:public
PrintCode	event_rpcgen.py	/^    def PrintCode(self, file):$/;"	m	class:Struct	access:public
PrintDeclaration	event_rpcgen.py	/^    def PrintDeclaration(self, file):$/;"	m	class:Struct	access:public
PrintForwardDeclaration	event_rpcgen.py	/^    def PrintForwardDeclaration(self, file):$/;"	m	class:Struct	access:public
PrintIdented	event_rpcgen.py	/^    def PrintIdented(self, file, ident, code):$/;"	m	class:Struct	access:public
PrintTags	event_rpcgen.py	/^    def PrintTags(self, file):$/;"	m	class:Struct	access:public
ProcessOneEntry	event_rpcgen.py	/^def ProcessOneEntry(newstruct, entry):$/;"	f	access:public
ProcessStruct	event_rpcgen.py	/^def ProcessStruct(data):$/;"	f	access:public
RANLIB	Makefile	/^RANLIB = ranlib$/;"	m
RANLIB	sample/Makefile	/^RANLIB = ranlib$/;"	m
RANLIB	test/Makefile	/^RANLIB = ranlib$/;"	m
RB_AUGMENT	WIN32-Code/tree.h	1009;"	d
RB_AUGMENT	WIN32-Code/tree.h	332;"	d
RB_AUGMENT	WIN32-Code/win32.c	46;"	d	file:
RB_BLACK	WIN32-Code/tree.h	303;"	d
RB_BLACK	WIN32-Code/tree.h	980;"	d
RB_COLOR	WIN32-Code/tree.h	316;"	d
RB_COLOR	WIN32-Code/tree.h	993;"	d
RB_EMPTY	WIN32-Code/tree.h	318;"	d
RB_EMPTY	WIN32-Code/tree.h	995;"	d
RB_ENTRY	WIN32-Code/tree.h	305;"	d
RB_ENTRY	WIN32-Code/tree.h	982;"	d
RB_ENTRY	WIN32-Code/win32.c	/^	RB_ENTRY(event_entry) node;$/;"	p	struct:event_entry	file:	access:public
RB_FIND	WIN32-Code/tree.h	1344;"	d
RB_FIND	WIN32-Code/tree.h	667;"	d
RB_FOREACH	WIN32-Code/tree.h	1349;"	d
RB_FOREACH	WIN32-Code/tree.h	672;"	d
RB_GENERATE	WIN32-Code/tree.h	1066;"	d
RB_GENERATE	WIN32-Code/tree.h	389;"	d
RB_HEAD	WIN32-Code/tree.h	291;"	d
RB_HEAD	WIN32-Code/tree.h	968;"	d
RB_HEAD	WIN32-Code/win32.c	/^	RB_HEAD(event_map, event_entry) event_root;$/;"	p	struct:win32op	file:	access:public
RB_INF	WIN32-Code/tree.h	1340;"	d
RB_INF	WIN32-Code/tree.h	663;"	d
RB_INIT	WIN32-Code/tree.h	299;"	d
RB_INIT	WIN32-Code/tree.h	976;"	d
RB_INITIALIZER	WIN32-Code/tree.h	296;"	d
RB_INITIALIZER	WIN32-Code/tree.h	973;"	d
RB_INSERT	WIN32-Code/tree.h	1342;"	d
RB_INSERT	WIN32-Code/tree.h	665;"	d
RB_LEFT	WIN32-Code/tree.h	313;"	d
RB_LEFT	WIN32-Code/tree.h	990;"	d
RB_MAX	WIN32-Code/tree.h	1347;"	d
RB_MAX	WIN32-Code/tree.h	670;"	d
RB_MIN	WIN32-Code/tree.h	1346;"	d
RB_MIN	WIN32-Code/tree.h	669;"	d
RB_NEGINF	WIN32-Code/tree.h	1339;"	d
RB_NEGINF	WIN32-Code/tree.h	662;"	d
RB_NEXT	WIN32-Code/tree.h	1345;"	d
RB_NEXT	WIN32-Code/tree.h	668;"	d
RB_PARENT	WIN32-Code/tree.h	315;"	d
RB_PARENT	WIN32-Code/tree.h	992;"	d
RB_PROTOTYPE	WIN32-Code/tree.h	1053;"	d
RB_PROTOTYPE	WIN32-Code/tree.h	376;"	d
RB_RED	WIN32-Code/tree.h	304;"	d
RB_RED	WIN32-Code/tree.h	981;"	d
RB_REMOVE	WIN32-Code/tree.h	1343;"	d
RB_REMOVE	WIN32-Code/tree.h	666;"	d
RB_RIGHT	WIN32-Code/tree.h	314;"	d
RB_RIGHT	WIN32-Code/tree.h	991;"	d
RB_ROOT	WIN32-Code/tree.h	317;"	d
RB_ROOT	WIN32-Code/tree.h	994;"	d
RB_ROTATE_LEFT	WIN32-Code/tree.h	1012;"	d
RB_ROTATE_LEFT	WIN32-Code/tree.h	335;"	d
RB_ROTATE_RIGHT	WIN32-Code/tree.h	1032;"	d
RB_ROTATE_RIGHT	WIN32-Code/tree.h	355;"	d
RB_SET	WIN32-Code/tree.h	320;"	d
RB_SET	WIN32-Code/tree.h	997;"	d
RB_SET_BLACKRED	WIN32-Code/tree.h	1003;"	d
RB_SET_BLACKRED	WIN32-Code/tree.h	326;"	d
RECURSIVE_CLEAN_TARGETS	Makefile	/^RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\\$/;"	m
RECURSIVE_TARGETS	Makefile	/^RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\$/;"	m
RELEASE	Makefile	/^RELEASE = 1.4$/;"	m
REQUEST_CANCELED	http-internal.h	/^	REQUEST_CANCELED = -2$/;"	e	enum:message_read_status
RUN_FIXED_BYTES	test/regress.gen.h	/^  RUN_FIXED_BYTES=3,$/;"	e	enum:run_
RUN_HOW	test/regress.gen.h	/^  RUN_HOW=1,$/;"	e	enum:run_
RUN_MAX_TAGS	test/regress.gen.h	/^  RUN_MAX_TAGS$/;"	e	enum:run_
RUN_SOME_BYTES	test/regress.gen.h	/^  RUN_SOME_BYTES=2,$/;"	e	enum:run_
SCRIPTS	Makefile	/^SCRIPTS = $(bin_SCRIPTS)$/;"	m
SECONDS	test/regress.c	81;"	d	file:
SED	Makefile	/^SED = \/bin\/sed$/;"	m
SED	sample/Makefile	/^SED = \/bin\/sed$/;"	m
SED	test/Makefile	/^SED = \/bin\/sed$/;"	m
SERVICES_KEY	evdns.c	2910;"	d	file:
SET_MAKE	Makefile	/^SET_MAKE = $/;"	m
SET_MAKE	sample/Makefile	/^SET_MAKE = $/;"	m
SET_MAKE	test/Makefile	/^SET_MAKE = $/;"	m
SHELL	Makefile	/^SHELL = \/bin\/bash$/;"	m
SHELL	sample/Makefile	/^SHELL = \/bin\/bash$/;"	m
SHELL	test/Makefile	/^SHELL = \/bin\/bash$/;"	m
SHUT_WR	test/regress.c	84;"	d	file:
SHUT_WR	test/test-eof.c	53;"	d	file:
SIGFPE_REQ	WIN32-Code/win32.c	/^volatile double SIGFPE_REQ = 0.0f;$/;"	v
SIMPLEQ_EMPTY	compat/sys/queue.h	233;"	d
SIMPLEQ_END	compat/sys/queue.h	232;"	d
SIMPLEQ_ENTRY	compat/sys/queue.h	223;"	d
SIMPLEQ_FIRST	compat/sys/queue.h	231;"	d
SIMPLEQ_FOREACH	compat/sys/queue.h	236;"	d
SIMPLEQ_HEAD	compat/sys/queue.h	214;"	d
SIMPLEQ_HEAD_INITIALIZER	compat/sys/queue.h	220;"	d
SIMPLEQ_INIT	compat/sys/queue.h	244;"	d
SIMPLEQ_INSERT_AFTER	compat/sys/queue.h	261;"	d
SIMPLEQ_INSERT_HEAD	compat/sys/queue.h	249;"	d
SIMPLEQ_INSERT_TAIL	compat/sys/queue.h	255;"	d
SIMPLEQ_NEXT	compat/sys/queue.h	234;"	d
SIMPLEQ_REMOVE_HEAD	compat/sys/queue.h	267;"	d
SIZEOF_INT	config.h	222;"	d
SIZEOF_LONG	config.h	225;"	d
SIZEOF_LONG_LONG	config.h	228;"	d
SIZEOF_SHORT	config.h	231;"	d
SKIP_NAME	evdns.c	1034;"	d	file:
SKIP_NAME	evdns.c	848;"	d	file:
SLIST_EMPTY	compat/sys/queue.h	108;"	d
SLIST_END	compat/sys/queue.h	107;"	d
SLIST_ENTRY	compat/sys/queue.h	97;"	d
SLIST_FIRST	compat/sys/queue.h	106;"	d
SLIST_FOREACH	compat/sys/queue.h	111;"	d
SLIST_HEAD	compat/sys/queue.h	88;"	d
SLIST_HEAD_INITIALIZER	compat/sys/queue.h	93;"	d
SLIST_INIT	compat/sys/queue.h	119;"	d
SLIST_INSERT_AFTER	compat/sys/queue.h	123;"	d
SLIST_INSERT_HEAD	compat/sys/queue.h	128;"	d
SLIST_NEXT	compat/sys/queue.h	109;"	d
SLIST_REMOVE_HEAD	compat/sys/queue.h	133;"	d
SOURCES	Makefile	/^SOURCES = $(libevent_la_SOURCES) $(libevent_core_la_SOURCES) \\$/;"	m
SOURCES	sample/Makefile	/^SOURCES = event-test.c signal-test.c time-test.c$/;"	m
SOURCES	test/Makefile	/^SOURCES = $(bench_SOURCES) $(regress_SOURCES) $(test_eof_SOURCES) \\$/;"	m
SPLAY_ASSEMBLE	WIN32-Code/tree.h	105;"	d
SPLAY_ASSEMBLE	WIN32-Code/tree.h	782;"	d
SPLAY_EMPTY	WIN32-Code/tree.h	755;"	d
SPLAY_EMPTY	WIN32-Code/tree.h	78;"	d
SPLAY_ENTRY	WIN32-Code/tree.h	69;"	d
SPLAY_ENTRY	WIN32-Code/tree.h	746;"	d
SPLAY_FIND	WIN32-Code/tree.h	278;"	d
SPLAY_FIND	WIN32-Code/tree.h	955;"	d
SPLAY_FOREACH	WIN32-Code/tree.h	285;"	d
SPLAY_FOREACH	WIN32-Code/tree.h	962;"	d
SPLAY_GENERATE	WIN32-Code/tree.h	156;"	d
SPLAY_GENERATE	WIN32-Code/tree.h	833;"	d
SPLAY_HEAD	WIN32-Code/tree.h	57;"	d
SPLAY_HEAD	WIN32-Code/tree.h	734;"	d
SPLAY_INF	WIN32-Code/tree.h	274;"	d
SPLAY_INF	WIN32-Code/tree.h	951;"	d
SPLAY_INIT	WIN32-Code/tree.h	65;"	d
SPLAY_INIT	WIN32-Code/tree.h	742;"	d
SPLAY_INITIALIZER	WIN32-Code/tree.h	62;"	d
SPLAY_INITIALIZER	WIN32-Code/tree.h	739;"	d
SPLAY_INSERT	WIN32-Code/tree.h	276;"	d
SPLAY_INSERT	WIN32-Code/tree.h	953;"	d
SPLAY_LEFT	WIN32-Code/tree.h	752;"	d
SPLAY_LEFT	WIN32-Code/tree.h	75;"	d
SPLAY_LINKLEFT	WIN32-Code/tree.h	770;"	d
SPLAY_LINKLEFT	WIN32-Code/tree.h	93;"	d
SPLAY_LINKRIGHT	WIN32-Code/tree.h	776;"	d
SPLAY_LINKRIGHT	WIN32-Code/tree.h	99;"	d
SPLAY_MAX	WIN32-Code/tree.h	282;"	d
SPLAY_MAX	WIN32-Code/tree.h	959;"	d
SPLAY_MIN	WIN32-Code/tree.h	280;"	d
SPLAY_MIN	WIN32-Code/tree.h	957;"	d
SPLAY_NEGINF	WIN32-Code/tree.h	273;"	d
SPLAY_NEGINF	WIN32-Code/tree.h	950;"	d
SPLAY_NEXT	WIN32-Code/tree.h	279;"	d
SPLAY_NEXT	WIN32-Code/tree.h	956;"	d
SPLAY_PROTOTYPE	WIN32-Code/tree.h	114;"	d
SPLAY_PROTOTYPE	WIN32-Code/tree.h	791;"	d
SPLAY_REMOVE	WIN32-Code/tree.h	277;"	d
SPLAY_REMOVE	WIN32-Code/tree.h	954;"	d
SPLAY_RIGHT	WIN32-Code/tree.h	753;"	d
SPLAY_RIGHT	WIN32-Code/tree.h	76;"	d
SPLAY_ROOT	WIN32-Code/tree.h	754;"	d
SPLAY_ROOT	WIN32-Code/tree.h	77;"	d
SPLAY_ROTATE_LEFT	WIN32-Code/tree.h	764;"	d
SPLAY_ROTATE_LEFT	WIN32-Code/tree.h	87;"	d
SPLAY_ROTATE_RIGHT	WIN32-Code/tree.h	758;"	d
SPLAY_ROTATE_RIGHT	WIN32-Code/tree.h	81;"	d
STDC_HEADERS	WIN32-Code/config.h	200;"	d
STDC_HEADERS	config.h	234;"	d
STRIP	Makefile	/^STRIP = strip$/;"	m
STRIP	sample/Makefile	/^STRIP = strip$/;"	m
STRIP	test/Makefile	/^STRIP = strip$/;"	m
SUBDIRS	Makefile	/^SUBDIRS = . sample test$/;"	m
SWAP	buffer.c	91;"	d	file:
SYS_INCLUDES	Makefile	/^SYS_INCLUDES = $/;"	m
SYS_LIBS	Makefile	/^SYS_LIBS = $/;"	m
SYS_SRC	Makefile	/^SYS_SRC = $/;"	m
SetLineCount	event_rpcgen.py	/^    def SetLineCount(self, number):$/;"	m	class:Entry	access:public
SetStruct	event_rpcgen.py	/^    def SetStruct(self, struct):$/;"	m	class:Entry	access:public
Struct	event_rpcgen.py	/^class Struct:$/;"	c	inherits:
TAILQ_EMPTY	compat/sys/queue.h	301;"	d
TAILQ_END	compat/sys/queue.h	294;"	d
TAILQ_END	event-internal.h	76;"	d
TAILQ_ENTRY	compat/sys/queue.h	284;"	d
TAILQ_ENTRY	event.h	204;"	d
TAILQ_ENTRY	event.h	251;"	d
TAILQ_FIRST	compat/sys/queue.h	293;"	d
TAILQ_FIRST	event-internal.h	75;"	d
TAILQ_FOREACH	compat/sys/queue.h	304;"	d
TAILQ_FOREACH	event-internal.h	78;"	d
TAILQ_FOREACH_REVERSE	compat/sys/queue.h	309;"	d
TAILQ_HEAD	compat/sys/queue.h	275;"	d
TAILQ_HEAD_INITIALIZER	compat/sys/queue.h	281;"	d
TAILQ_INIT	compat/sys/queue.h	317;"	d
TAILQ_INSERT_AFTER	compat/sys/queue.h	339;"	d
TAILQ_INSERT_BEFORE	compat/sys/queue.h	349;"	d
TAILQ_INSERT_BEFORE	event-internal.h	82;"	d
TAILQ_INSERT_HEAD	compat/sys/queue.h	322;"	d
TAILQ_INSERT_TAIL	compat/sys/queue.h	332;"	d
TAILQ_LAST	compat/sys/queue.h	296;"	d
TAILQ_NEXT	compat/sys/queue.h	295;"	d
TAILQ_NEXT	event-internal.h	77;"	d
TAILQ_PREV	compat/sys/queue.h	299;"	d
TAILQ_REMOVE	compat/sys/queue.h	356;"	d
TAILQ_REPLACE	compat/sys/queue.h	365;"	d
TEST1	test/regress.c	80;"	d	file:
TEST_MAX_INT	test/regress.c	1252;"	d	file:
TEST_NAME	evdns.c	853;"	d	file:
TIMER_ABSTIME	compat/sys/_time.h	159;"	d
TIMER_RELTIME	compat/sys/_time.h	158;"	d
TIMESPEC_TO_TIMEVAL	compat/sys/_time.h	61;"	d
TIMEVAL_TO_TIMESPEC	compat/sys/_time.h	57;"	d
TIME_WITH_SYS_TIME	WIN32-Code/config.h	203;"	d
TIME_WITH_SYS_TIME	config.h	237;"	d
TO_SERVER_REQUEST	evdns.c	290;"	d	file:
TRY	evdns.c	2919;"	d	file:
TRY	evdns.c	2965;"	d	file:
TYPE_A	evdns.c	152;"	d	file:
TYPE_AAAA	evdns.c	155;"	d	file:
TYPE_CNAME	evdns.c	153;"	d	file:
TYPE_PTR	evdns.c	154;"	d	file:
Tag	event_rpcgen.py	/^    def Tag(self):$/;"	m	class:Entry	access:public
Type	event_rpcgen.py	/^    def Type(self):$/;"	m	class:Entry	access:public
VERSION	Makefile	/^VERSION = 1.4.9-stable$/;"	m
VERSION	WIN32-Code/config.h	206;"	d
VERSION	config.h	240;"	d
VERSION	sample/Makefile	/^VERSION = 1.4.9-stable$/;"	m
VERSION	test/Makefile	/^VERSION = 1.4.9-stable$/;"	m
VERSION_INFO	Makefile	/^VERSION_INFO = 3:2:1$/;"	m
Verify	event_rpcgen.py	/^    def Verify(self):$/;"	m	class:Entry	access:public
Verify	event_rpcgen.py	/^    def Verify(self):$/;"	m	class:EntryBytes	access:public
WIN32_LEAN_AND_MEAN	event.c	32;"	d	file:
WIN32_LEAN_AND_MEAN	event.c	34;"	d	file:
WIN32_LEAN_AND_MEAN	event.h	178;"	d
WIN32_LEAN_AND_MEAN	event.h	180;"	d
WIN32_LEAN_AND_MEAN	event_tagging.c	40;"	d	file:
WIN32_LEAN_AND_MEAN	event_tagging.c	43;"	d	file:
WIN32_LEAN_AND_MEAN	evhttp.h	37;"	d
WIN32_LEAN_AND_MEAN	evhttp.h	40;"	d
WIN32_LEAN_AND_MEAN	evrpc.c	32;"	d	file:
WIN32_LEAN_AND_MEAN	evrpc.c	35;"	d	file:
WIN32_LEAN_AND_MEAN	evutil.c	33;"	d	file:
WIN32_LEAN_AND_MEAN	evutil.c	35;"	d	file:
WIN32_LEAN_AND_MEAN	log.c	45;"	d	file:
WIN32_LEAN_AND_MEAN	log.c	47;"	d	file:
WIN32_LEAN_AND_MEAN	signal.c	34;"	d	file:
WIN32_LEAN_AND_MEAN	signal.c	37;"	d	file:
WIN_NS_9X_KEY	evdns.c	2911;"	d	file:
WIN_NS_NT_KEY	evdns.c	2912;"	d	file:
XFREE	WIN32-Code/win32.c	52;"	d	file:
_EVENT_CONFIG_H_	event-config.h	7;"	d
_EVENT_DEFINED_TQENTRY	event.h	203;"	d
_EVENT_DEFINED_TQENTRY	event.h	254;"	d
_EVENT_DNS_USE_CPU_CLOCK_FOR_ID	event-config.h	12;"	d
_EVENT_HAVE_CLOCK_GETTIME	event-config.h	18;"	d
_EVENT_HAVE_DLFCN_H	event-config.h	24;"	d
_EVENT_HAVE_EPOLL	event-config.h	27;"	d
_EVENT_HAVE_EPOLL_CTL	event-config.h	30;"	d
_EVENT_HAVE_FCNTL	event-config.h	36;"	d
_EVENT_HAVE_FCNTL_H	event-config.h	39;"	d
_EVENT_HAVE_GETADDRINFO	event-config.h	42;"	d
_EVENT_HAVE_GETNAMEINFO	event-config.h	45;"	d
_EVENT_HAVE_GETTIMEOFDAY	event-config.h	48;"	d
_EVENT_HAVE_INET_NTOP	event-config.h	51;"	d
_EVENT_HAVE_INTTYPES_H	event-config.h	54;"	d
_EVENT_HAVE_LIBNSL	event-config.h	60;"	d
_EVENT_HAVE_LIBRESOLV	event-config.h	63;"	d
_EVENT_HAVE_LIBRT	event-config.h	66;"	d
_EVENT_HAVE_MEMORY_H	event-config.h	72;"	d
_EVENT_HAVE_POLL	event-config.h	78;"	d
_EVENT_HAVE_POLL_H	event-config.h	81;"	d
_EVENT_HAVE_SELECT	event-config.h	90;"	d
_EVENT_HAVE_SETFD	event-config.h	93;"	d
_EVENT_HAVE_SIGACTION	event-config.h	96;"	d
_EVENT_HAVE_SIGNAL	event-config.h	99;"	d
_EVENT_HAVE_SIGNAL_H	event-config.h	102;"	d
_EVENT_HAVE_STDARG_H	event-config.h	105;"	d
_EVENT_HAVE_STDINT_H	event-config.h	108;"	d
_EVENT_HAVE_STDLIB_H	event-config.h	111;"	d
_EVENT_HAVE_STRINGS_H	event-config.h	114;"	d
_EVENT_HAVE_STRING_H	event-config.h	117;"	d
_EVENT_HAVE_STRSEP	event-config.h	123;"	d
_EVENT_HAVE_STRTOK_R	event-config.h	126;"	d
_EVENT_HAVE_STRTOLL	event-config.h	129;"	d
_EVENT_HAVE_STRUCT_IN6_ADDR	event-config.h	132;"	d
_EVENT_HAVE_SYS_EPOLL_H	event-config.h	138;"	d
_EVENT_HAVE_SYS_IOCTL_H	event-config.h	144;"	d
_EVENT_HAVE_SYS_PARAM_H	event-config.h	147;"	d
_EVENT_HAVE_SYS_QUEUE_H	event-config.h	150;"	d
_EVENT_HAVE_SYS_SELECT_H	event-config.h	153;"	d
_EVENT_HAVE_SYS_SOCKET_H	event-config.h	156;"	d
_EVENT_HAVE_SYS_STAT_H	event-config.h	159;"	d
_EVENT_HAVE_SYS_TIME_H	event-config.h	162;"	d
_EVENT_HAVE_SYS_TYPES_H	event-config.h	165;"	d
_EVENT_HAVE_TAILQFOREACH	event-config.h	168;"	d
_EVENT_HAVE_TIMERADD	event-config.h	171;"	d
_EVENT_HAVE_TIMERCLEAR	event-config.h	174;"	d
_EVENT_HAVE_TIMERCMP	event-config.h	177;"	d
_EVENT_HAVE_TIMERISSET	event-config.h	180;"	d
_EVENT_HAVE_UINT16_T	event-config.h	183;"	d
_EVENT_HAVE_UINT32_T	event-config.h	186;"	d
_EVENT_HAVE_UINT64_T	event-config.h	189;"	d
_EVENT_HAVE_UINT8_T	event-config.h	192;"	d
_EVENT_HAVE_UNISTD_H	event-config.h	195;"	d
_EVENT_HAVE_VASPRINTF	event-config.h	198;"	d
_EVENT_H_	event.h	28;"	d
_EVENT_INTERNAL_H_	event-internal.h	28;"	d
_EVENT_LOG_DEBUG	event.h	335;"	d
_EVENT_LOG_ERR	event.h	338;"	d
_EVENT_LOG_MSG	event.h	336;"	d
_EVENT_LOG_WARN	event.h	337;"	d
_EVENT_LT_OBJDIR	event-config.h	205;"	d
_EVENT_PACKAGE	event-config.h	208;"	d
_EVENT_PACKAGE_BUGREPORT	event-config.h	211;"	d
_EVENT_PACKAGE_NAME	event-config.h	214;"	d
_EVENT_PACKAGE_STRING	event-config.h	217;"	d
_EVENT_PACKAGE_TARNAME	event-config.h	220;"	d
_EVENT_PACKAGE_URL	event-config.h	223;"	d
_EVENT_PACKAGE_VERSION	event-config.h	226;"	d
_EVENT_SIZEOF_INT	event-config.h	229;"	d
_EVENT_SIZEOF_LONG	event-config.h	232;"	d
_EVENT_SIZEOF_LONG_LONG	event-config.h	235;"	d
_EVENT_SIZEOF_SHORT	event-config.h	238;"	d
_EVENT_STDC_HEADERS	event-config.h	241;"	d
_EVENT_TIME_WITH_SYS_TIME	event-config.h	244;"	d
_EVENT_VERSION	event-config.h	247;"	d
_EVHTTP_H_	evhttp.h	28;"	d
_EVRPC_H_	evrpc.h	28;"	d
_EVRPC_INTERNAL_H_	evrpc-internal.h	28;"	d
_EVSIGNAL_H_	evsignal.h	28;"	d
_EVUTIL_H_	evutil.h	28;"	d
_FORTIFY_SOURCE	evdns.c	77;"	d	file:
_GNU_SOURCE	buffer.c	39;"	d	file:
_GNU_SOURCE	evdns.c	58;"	d	file:
_HTTP_H_	http-internal.h	11;"	d
_LOG_H_	log.h	28;"	d
_MIN_HEAP_H_	min_heap.h	28;"	d
_NAME	event_rpcgen.py	/^_NAME = "event_rpcgen.py"$/;"	v
_REGRESS_H_	test/regress.h	28;"	d
_STRLCPY_INTERNAL_H_	strlcpy-internal.h	2;"	d
_STRUCT_RE	event_rpcgen.py	/^_STRUCT_RE = '[a-z][a-z_0-9]*'$/;"	v
_SYS_QUEUE_H_	compat/sys/queue.h	36;"	d
_SYS_TIME_H_	compat/sys/_time.h	36;"	d
_SYS_TREE_H_	WIN32-Code/tree.h	28;"	d
_SYS_TREE_H_	WIN32-Code/tree.h	705;"	d
_VERSION	event_rpcgen.py	/^_VERSION = "0.1"$/;"	v
___REGRESS_RPC_	test/regress.gen.h	6;"	d
__func__	WIN32-Code/config.h	210;"	d
__func__	WIN32-Code/config.h	212;"	d
__init__	event_rpcgen.py	/^    def __init__(self, entry):$/;"	m	class:EntryArray	access:public
__init__	event_rpcgen.py	/^    def __init__(self, name):$/;"	m	class:Struct	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag):$/;"	m	class:Entry	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag):$/;"	m	class:EntryInt	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag):$/;"	m	class:EntryString	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag):$/;"	m	class:EntryVarBytes	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag, length):$/;"	m	class:EntryBytes	access:public
__init__	event_rpcgen.py	/^    def __init__(self, type, name, tag, refname):$/;"	m	class:EntryStruct	access:public
__kill_base	test/regress.gen.c	/^static struct kill_access_ __kill_base = {$/;"	v	typeref:struct:kill_access_	file:
__msg_base	test/regress.gen.c	/^static struct msg_access_ __msg_base = {$/;"	v	typeref:struct:msg_access_	file:
__run_base	test/regress.gen.c	/^static struct run_access_ __run_base = {$/;"	v	typeref:struct:run_access_	file:
_buf	event_tagging.c	/^static struct evbuffer *_buf;	\/* not thread safe *\/$/;"	v	typeref:struct:evbuffer	file:
_evdns_log	evdns.c	/^_evdns_log(int warn, const char *fmt, ...)$/;"	f	file:	signature:(int warn, const char *fmt, ...)
_evdns_nameserver_add_impl	evdns.c	/^_evdns_nameserver_add_impl(unsigned long int address, int port) {$/;"	f	file:	signature:(unsigned long int address, int port)
_event_debugx	log.c	/^_event_debugx(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
_event_strlcpy	strlcpy-internal.h	/^size_t _event_strlcpy(char *dst, const char *src, size_t siz);$/;"	p	signature:(char *dst, const char *src, size_t siz)
_event_strlcpy	strlcpy.c	/^_event_strlcpy(dst, src, siz)$/;"	f
_evrpc_hooks	evrpc-internal.h	/^struct _evrpc_hooks {$/;"	s
_evrpc_hooks::in_hooks	evrpc-internal.h	/^	struct evrpc_hook_list in_hooks;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_hook_list	access:public
_evrpc_hooks::out_hooks	evrpc-internal.h	/^	struct evrpc_hook_list out_hooks;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_hook_list	access:public
_evsignal_restore_handler	event-internal.h	/^int _evsignal_restore_handler(struct event_base *base, int evsignal);$/;"	p	signature:(struct event_base *base, int evsignal)
_evsignal_restore_handler	signal.c	/^_evsignal_restore_handler(struct event_base *base, int evsignal)$/;"	f	signature:(struct event_base *base, int evsignal)
_evsignal_set_handler	event-internal.h	/^int _evsignal_set_handler(struct event_base *base, int evsignal,$/;"	p	signature:(struct event_base *base, int evsignal, void (*fn)(int))
_evsignal_set_handler	signal.c	/^_evsignal_set_handler(struct event_base *base,$/;"	f	signature:(struct event_base *base, int evsignal, void (*handler)(int))
_warn_helper	log.c	/^_warn_helper(int severity, int log_errno, const char *fmt, va_list ap)$/;"	f	file:	signature:(int severity, int log_errno, const char *fmt, va_list ap)
_warn_helper	log.c	/^static void _warn_helper(int severity, int log_errno, const char *fmt,$/;"	p	file:	signature:(int severity, int log_errno, const char *fmt, va_list ap)
a	evdns.c	/^		} a;$/;"	m	union:reply::__anon1	typeref:struct:reply::__anon1::__anon2	file:	access:public
a	min_heap.h	/^    unsigned n, a;$/;"	m	struct:min_heap	access:public
aaaa	evdns.c	/^		} aaaa;$/;"	m	union:reply::__anon1	typeref:struct:reply::__anon1::__anon3	file:	access:public
abs_builddir	Makefile	/^abs_builddir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable$/;"	m
abs_builddir	sample/Makefile	/^abs_builddir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/sample$/;"	m
abs_builddir	test/Makefile	/^abs_builddir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/test$/;"	m
abs_srcdir	Makefile	/^abs_srcdir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable$/;"	m
abs_srcdir	sample/Makefile	/^abs_srcdir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/sample$/;"	m
abs_srcdir	test/Makefile	/^abs_srcdir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/test$/;"	m
abs_top_builddir	Makefile	/^abs_top_builddir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable$/;"	m
abs_top_builddir	sample/Makefile	/^abs_top_builddir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable$/;"	m
abs_top_builddir	test/Makefile	/^abs_top_builddir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable$/;"	m
abs_top_srcdir	Makefile	/^abs_top_srcdir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable$/;"	m
abs_top_srcdir	sample/Makefile	/^abs_top_srcdir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable$/;"	m
abs_top_srcdir	test/Makefile	/^abs_top_srcdir = \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable$/;"	m
ac_ct_CC	Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_CC	sample/Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_CC	test/Makefile	/^ac_ct_CC = gcc$/;"	m
ac_ct_DUMPBIN	Makefile	/^ac_ct_DUMPBIN = $/;"	m
ac_ct_DUMPBIN	sample/Makefile	/^ac_ct_DUMPBIN = $/;"	m
ac_ct_DUMPBIN	test/Makefile	/^ac_ct_DUMPBIN = $/;"	m
ac_fn_c_check_func	configure	/^ac_fn_c_check_func ()$/;"	f
ac_fn_c_check_header_compile	configure	/^ac_fn_c_check_header_compile ()$/;"	f
ac_fn_c_check_header_mongrel	configure	/^ac_fn_c_check_header_mongrel ()$/;"	f
ac_fn_c_check_type	configure	/^ac_fn_c_check_type ()$/;"	f
ac_fn_c_compute_int	configure	/^ac_fn_c_compute_int ()$/;"	f
ac_fn_c_try_compile	configure	/^ac_fn_c_try_compile ()$/;"	f
ac_fn_c_try_cpp	configure	/^ac_fn_c_try_cpp ()$/;"	f
ac_fn_c_try_link	configure	/^ac_fn_c_try_link ()$/;"	f
ac_fn_c_try_run	configure	/^ac_fn_c_try_run ()$/;"	f
accept_socket	http.c	/^accept_socket(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
action_assign	test/regress.gen.h	/^  int (*action_assign)(struct kill *, const char *);$/;"	m	struct:kill_access_	access:public
action_data	test/regress.gen.h	/^  char *action_data;$/;"	m	struct:kill	access:public
action_get	test/regress.gen.h	/^  int (*action_get)(struct kill *, char * *);$/;"	m	struct:kill_access_	access:public
action_set	test/regress.gen.h	/^  uint8_t action_set;$/;"	m	struct:kill	access:public
activequeues	event-internal.h	/^	struct event_list **activequeues;$/;"	m	struct:event_base	typeref:struct:event_base::event_list	access:public
add	event-internal.h	/^	int (*add)(void *, struct event *);$/;"	m	struct:eventop	access:public
additional	evdns.c	/^	struct server_reply_item *additional; \/* linked list of additional RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
addr	evdns.c	/^	struct sockaddr_storage addr; \/* Where to send the response *\/$/;"	m	struct:server_request	typeref:struct:server_request::sockaddr_storage	file:	access:public
addrcount	evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon1::__anon2	file:	access:public
addrcount	evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon1::__anon3	file:	access:public
address	evdns.c	/^	u32 address;$/;"	m	struct:nameserver	file:	access:public
address	http-internal.h	/^	char *address;			\/* address to connect to *\/$/;"	m	struct:evhttp_connection	access:public
addresses	evdns.c	/^			struct in6_addr addresses[MAX_ADDRS];$/;"	m	struct:reply::__anon1::__anon3	typeref:struct:reply::__anon1::__anon3::in6_addr	file:	access:public
addresses	evdns.c	/^			u32 addresses[MAX_ADDRS];$/;"	m	struct:reply::__anon1::__anon2	file:	access:public
addrinfo	http.c	/^struct addrinfo {$/;"	s	file:
addrinfo::ai_addr	http.c	/^	struct sockaddr *ai_addr;$/;"	m	struct:addrinfo	typeref:struct:addrinfo::sockaddr	file:	access:public
addrinfo::ai_addrlen	http.c	/^	size_t ai_addrlen;$/;"	m	struct:addrinfo	file:	access:public
addrinfo::ai_family	http.c	/^	int ai_family;$/;"	m	struct:addrinfo	file:	access:public
addrinfo::ai_next	http.c	/^	struct addrinfo *ai_next;$/;"	m	struct:addrinfo	typeref:struct:addrinfo::addrinfo	file:	access:public
addrinfo::ai_protocol	http.c	/^	int ai_protocol;$/;"	m	struct:addrinfo	file:	access:public
addrinfo::ai_socktype	http.c	/^	int ai_socktype;$/;"	m	struct:addrinfo	file:	access:public
addrlen	evdns.c	/^	socklen_t addrlen; \/* length of addr *\/$/;"	m	struct:server_request	file:	access:public
ai_addr	http.c	/^	struct sockaddr *ai_addr;$/;"	m	struct:addrinfo	typeref:struct:addrinfo::sockaddr	file:	access:public
ai_addrlen	http.c	/^	size_t ai_addrlen;$/;"	m	struct:addrinfo	file:	access:public
ai_family	http.c	/^	int ai_family;$/;"	m	struct:addrinfo	file:	access:public
ai_next	http.c	/^	struct addrinfo *ai_next;$/;"	m	struct:addrinfo	typeref:struct:addrinfo::addrinfo	file:	access:public
ai_protocol	http.c	/^	int ai_protocol;$/;"	m	struct:addrinfo	file:	access:public
ai_socktype	http.c	/^	int ai_socktype;$/;"	m	struct:addrinfo	file:	access:public
am__CONFIG_DISTCLEAN_FILES	Makefile	/^am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\$/;"	m
am__DEPENDENCIES_1	Makefile	/^am__DEPENDENCIES_1 =$/;"	m
am__aclocal_m4_deps	Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/configure.in$/;"	m
am__aclocal_m4_deps	sample/Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/configure.in$/;"	m
am__aclocal_m4_deps	test/Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/configure.in$/;"	m
am__cd	Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__cd	sample/Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__cd	test/Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__configure_deps	Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__configure_deps	sample/Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__configure_deps	test/Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__depfiles_maybe	Makefile	/^am__depfiles_maybe =$/;"	m
am__depfiles_maybe	sample/Makefile	/^am__depfiles_maybe =$/;"	m
am__depfiles_maybe	test/Makefile	/^am__depfiles_maybe =$/;"	m
am__include	Makefile	/^am__include = include$/;"	m
am__include	sample/Makefile	/^am__include = include$/;"	m
am__include	test/Makefile	/^am__include = include$/;"	m
am__installdirs	Makefile	/^am__installdirs = "$(DESTDIR)$(libdir)" "$(DESTDIR)$(bindir)" \\$/;"	m
am__leading_dot	Makefile	/^am__leading_dot = .$/;"	m
am__leading_dot	sample/Makefile	/^am__leading_dot = .$/;"	m
am__leading_dot	test/Makefile	/^am__leading_dot = .$/;"	m
am__libevent_core_la_SOURCES_DIST	Makefile	/^am__libevent_core_la_SOURCES_DIST = event.c buffer.c evbuffer.c log.c \\$/;"	m
am__libevent_la_SOURCES_DIST	Makefile	/^am__libevent_la_SOURCES_DIST = event.c buffer.c evbuffer.c log.c \\$/;"	m
am__objects_2	Makefile	/^am__objects_2 = event.lo buffer.lo evbuffer.lo log.lo evutil.lo \\$/;"	m
am__objects_3	Makefile	/^am__objects_3 = event_tagging.lo http.lo evdns.lo evrpc.lo strlcpy.lo$/;"	m
am__quote	Makefile	/^am__quote = $/;"	m
am__quote	sample/Makefile	/^am__quote = $/;"	m
am__quote	test/Makefile	/^am__quote = $/;"	m
am__remove_distdir	Makefile	/^am__remove_distdir = \\$/;"	m
am__strip_dir	Makefile	/^am__strip_dir = `echo $$p | sed -e 's|^.*\/||'`;$/;"	m
am__tar	Makefile	/^am__tar = ${AMTAR} chof - "$$tardir"$/;"	m
am__tar	sample/Makefile	/^am__tar = ${AMTAR} chof - "$$tardir"$/;"	m
am__tar	test/Makefile	/^am__tar = ${AMTAR} chof - "$$tardir"$/;"	m
am__untar	Makefile	/^am__untar = ${AMTAR} xf -$/;"	m
am__untar	sample/Makefile	/^am__untar = ${AMTAR} xf -$/;"	m
am__untar	test/Makefile	/^am__untar = ${AMTAR} xf -$/;"	m
am__vpath_adj	Makefile	/^am__vpath_adj = case $$p in \\$/;"	m
am__vpath_adj_setup	Makefile	/^am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;$/;"	m
am_bench_OBJECTS	test/Makefile	/^am_bench_OBJECTS = bench.$(OBJEXT)$/;"	m
am_libevent_core_la_OBJECTS	Makefile	/^am_libevent_core_la_OBJECTS = $(am__objects_2)$/;"	m
am_libevent_extra_la_OBJECTS	Makefile	/^am_libevent_extra_la_OBJECTS = $(am__objects_3)$/;"	m
am_libevent_la_OBJECTS	Makefile	/^am_libevent_la_OBJECTS = $(am__objects_2) $(am__objects_3)$/;"	m
am_regress_OBJECTS	test/Makefile	/^am_regress_OBJECTS = regress.$(OBJEXT) regress_http.$(OBJEXT) \\$/;"	m
am_test_eof_OBJECTS	test/Makefile	/^am_test_eof_OBJECTS = test-eof.$(OBJEXT)$/;"	m
am_test_init_OBJECTS	test/Makefile	/^am_test_init_OBJECTS = test-init.$(OBJEXT)$/;"	m
am_test_time_OBJECTS	test/Makefile	/^am_test_time_OBJECTS = test-time.$(OBJEXT)$/;"	m
am_test_weof_OBJECTS	test/Makefile	/^am_test_weof_OBJECTS = test-weof.$(OBJEXT)$/;"	m
answer	evdns.c	/^	struct server_reply_item *answer; \/* linked list of answer RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
arg	event.c	/^	void *arg;$/;"	m	struct:event_once	file:	access:public
as_fn_append	config.status	/^  as_fn_append ()$/;"	f
as_fn_append	configure	/^  as_fn_append ()$/;"	f
as_fn_arith	config.status	/^  as_fn_arith ()$/;"	f
as_fn_arith	configure	/^  as_fn_arith ()$/;"	f
as_fn_error	config.status	/^as_fn_error ()$/;"	f
as_fn_error	configure	/^as_fn_error ()$/;"	f
as_fn_exit	config.status	/^as_fn_exit ()$/;"	f
as_fn_exit	configure	/^as_fn_exit ()$/;"	f
as_fn_failure	configure	/^as_fn_failure () { as_fn_return 1; }$/;"	f
as_fn_mkdir_p	config.status	/^as_fn_mkdir_p ()$/;"	f
as_fn_mkdir_p	configure	/^as_fn_mkdir_p ()$/;"	f
as_fn_ret_failure	configure	/^as_fn_ret_failure () { return 1; }$/;"	f
as_fn_ret_success	configure	/^as_fn_ret_success () { return 0; }$/;"	f
as_fn_set_status	config.status	/^as_fn_set_status ()$/;"	f
as_fn_set_status	configure	/^as_fn_set_status ()$/;"	f
as_fn_success	configure	/^as_fn_success () { as_fn_return 0; }$/;"	f
as_fn_unset	config.status	/^as_fn_unset ()$/;"	f
as_fn_unset	configure	/^as_fn_unset ()$/;"	f
attack_assign	test/regress.gen.h	/^  int (*attack_assign)(struct msg *, const struct kill*);$/;"	m	struct:msg_access_	access:public
attack_data	test/regress.gen.h	/^  struct kill* attack_data;$/;"	m	struct:msg	typeref:struct:msg::kill	access:public
attack_get	test/regress.gen.h	/^  int (*attack_get)(struct msg *, struct kill* *);$/;"	m	struct:msg_access_	access:public
attack_set	test/regress.gen.h	/^  uint8_t attack_set;$/;"	m	struct:msg	access:public
authority	evdns.c	/^	struct server_reply_item *authority; \/* linked list of authority RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
base	evdns.c	/^	struct evdns_server_request base;$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_request	file:	access:public
base	evrpc-internal.h	/^	struct event_base *base;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::event_base	access:public
base	evrpc.h	/^	struct evrpc_base *base;$/;"	m	struct:evrpc	typeref:struct:evrpc::evrpc_base	access:public
base	http-internal.h	/^	struct event_base *base;$/;"	m	struct:evhttp	typeref:struct:evhttp::event_base	access:public
base	http-internal.h	/^	struct event_base *base;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event_base	access:public
base	test/regress.gen.h	/^  struct kill_access_ *base;$/;"	m	struct:kill	typeref:struct:kill::kill_access_	access:public
base	test/regress.gen.h	/^  struct msg_access_ *base;$/;"	m	struct:msg	typeref:struct:msg::msg_access_	access:public
base	test/regress.gen.h	/^  struct run_access_ *base;$/;"	m	struct:run	typeref:struct:run::run_access_	access:public
base	test/regress_http.c	/^static struct event_base *base;$/;"	v	typeref:struct:event_base	file:
bench_DEPENDENCIES	test/Makefile	/^bench_DEPENDENCIES = ..\/libevent.la$/;"	m
bench_LDADD	test/Makefile	/^bench_LDADD = ..\/libevent.la$/;"	m
bench_OBJECTS	test/Makefile	/^bench_OBJECTS = $(am_bench_OBJECTS)$/;"	m
bench_SOURCES	test/Makefile	/^bench_SOURCES = bench.c$/;"	m
binSCRIPT_INSTALL	Makefile	/^binSCRIPT_INSTALL = $(INSTALL_SCRIPT)$/;"	m
bin_SCRIPTS	Makefile	/^bin_SCRIPTS = event_rpcgen.py$/;"	m
bind_address	http-internal.h	/^	char *bind_address;		\/* address to use for binding the src *\/$/;"	m	struct:evhttp_connection	access:public
bind_ev	http-internal.h	/^	struct event  bind_ev;$/;"	m	struct:evhttp_bound_socket	typeref:struct:evhttp_bound_socket::event	access:public
bind_port	http-internal.h	/^	u_short bind_port;		\/* local port for binding the src *\/$/;"	m	struct:evhttp_connection	access:public
bind_socket	http.c	/^bind_socket(const char *address, u_short port, int reuse)$/;"	f	file:	signature:(const char *address, u_short port, int reuse)
bind_socket	http.c	/^static int bind_socket(const char *, u_short, int reuse);$/;"	p	file:	signature:(const char *, u_short, int reuse)
bind_socket_ai	http.c	/^bind_socket_ai(struct addrinfo *ai, int reuse)$/;"	f	file:	signature:(struct addrinfo *ai, int reuse)
bind_socket_ai	http.c	/^static int bind_socket_ai(struct addrinfo *, int reuse);$/;"	p	file:	signature:(struct addrinfo *, int reuse)
bindir	Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	sample/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	test/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
both	test/regress.c	/^struct both {$/;"	s	file:
both::ev	test/regress.c	/^	struct event ev;$/;"	m	struct:both	typeref:struct:both::event	file:	access:public
both::nread	test/regress.c	/^	int nread;$/;"	m	struct:both	file:	access:public
break_cb	test/regress.c	/^break_cb(int fd, short events, void *arg)$/;"	f	file:	signature:(int fd, short events, void *arg)
buffer	event.h	/^	u_char *buffer;$/;"	m	struct:evbuffer	access:public
bufferevent	event.h	/^struct bufferevent {$/;"	s
bufferevent::cbarg	event.h	/^	void *cbarg;$/;"	m	struct:bufferevent	access:public
bufferevent::enabled	event.h	/^	short enabled;	\/* events that are currently enabled *\/$/;"	m	struct:bufferevent	access:public
bufferevent::errorcb	event.h	/^	everrorcb errorcb;$/;"	m	struct:bufferevent	access:public
bufferevent::ev_base	event.h	/^	struct event_base *ev_base;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_base	access:public
bufferevent::ev_read	event.h	/^	struct event ev_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
bufferevent::ev_write	event.h	/^	struct event ev_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
bufferevent::input	event.h	/^	struct evbuffer *input;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
bufferevent::output	event.h	/^	struct evbuffer *output;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
bufferevent::readcb	event.h	/^	evbuffercb readcb;$/;"	m	struct:bufferevent	access:public
bufferevent::timeout_read	event.h	/^	int timeout_read;	\/* in seconds *\/$/;"	m	struct:bufferevent	access:public
bufferevent::timeout_write	event.h	/^	int timeout_write;	\/* in seconds *\/$/;"	m	struct:bufferevent	access:public
bufferevent::wm_read	event.h	/^	struct event_watermark wm_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
bufferevent::wm_write	event.h	/^	struct event_watermark wm_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
bufferevent::writecb	event.h	/^	evbuffercb writecb;$/;"	m	struct:bufferevent	access:public
bufferevent_add	evbuffer.c	/^bufferevent_add(struct event *ev, int timeout)$/;"	f	file:	signature:(struct event *ev, int timeout)
bufferevent_base_set	evbuffer.c	/^bufferevent_base_set(struct event_base *base, struct bufferevent *bufev)$/;"	f	signature:(struct event_base *base, struct bufferevent *bufev)
bufferevent_base_set	event.h	/^int bufferevent_base_set(struct event_base *base, struct bufferevent *bufev);$/;"	p	signature:(struct event_base *base, struct bufferevent *bufev)
bufferevent_disable	evbuffer.c	/^bufferevent_disable(struct bufferevent *bufev, short event)$/;"	f	signature:(struct bufferevent *bufev, short event)
bufferevent_disable	event.h	/^int bufferevent_disable(struct bufferevent *bufev, short event);$/;"	p	signature:(struct bufferevent *bufev, short event)
bufferevent_enable	evbuffer.c	/^bufferevent_enable(struct bufferevent *bufev, short event)$/;"	f	signature:(struct bufferevent *bufev, short event)
bufferevent_enable	event.h	/^int bufferevent_enable(struct bufferevent *bufev, short event);$/;"	p	signature:(struct bufferevent *bufev, short event)
bufferevent_free	evbuffer.c	/^bufferevent_free(struct bufferevent *bufev)$/;"	f	signature:(struct bufferevent *bufev)
bufferevent_free	event.h	/^void bufferevent_free(struct bufferevent *bufev);$/;"	p	signature:(struct bufferevent *bufev)
bufferevent_new	evbuffer.c	/^bufferevent_new(int fd, evbuffercb readcb, evbuffercb writecb,$/;"	f	signature:(int fd, evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg)
bufferevent_new	event.h	/^struct bufferevent *bufferevent_new(int fd,$/;"	p	signature:(int fd, evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg)
bufferevent_priority_set	evbuffer.c	/^bufferevent_priority_set(struct bufferevent *bufev, int priority)$/;"	f	signature:(struct bufferevent *bufev, int priority)
bufferevent_priority_set	event.h	/^int bufferevent_priority_set(struct bufferevent *bufev, int pri);$/;"	p	signature:(struct bufferevent *bufev, int pri)
bufferevent_read	evbuffer.c	/^bufferevent_read(struct bufferevent *bufev, void *data, size_t size)$/;"	f	signature:(struct bufferevent *bufev, void *data, size_t size)
bufferevent_read	event.h	/^size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);$/;"	p	signature:(struct bufferevent *bufev, void *data, size_t size)
bufferevent_read_pressure_cb	evbuffer.c	/^bufferevent_read_pressure_cb(struct evbuffer *buf, size_t old, size_t now,$/;"	f	signature:(struct evbuffer *buf, size_t old, size_t now, void *arg)
bufferevent_read_pressure_cb	evbuffer.c	/^void bufferevent_read_pressure_cb(struct evbuffer *, size_t, size_t, void *);$/;"	p	file:	signature:(struct evbuffer *, size_t, size_t, void *)
bufferevent_readcb	evbuffer.c	/^bufferevent_readcb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
bufferevent_setcb	evbuffer.c	/^bufferevent_setcb(struct bufferevent *bufev,$/;"	f	signature:(struct bufferevent *bufev, evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg)
bufferevent_setcb	event.h	/^void bufferevent_setcb(struct bufferevent *bufev,$/;"	p	signature:(struct bufferevent *bufev, evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg)
bufferevent_setfd	evbuffer.c	/^bufferevent_setfd(struct bufferevent *bufev, int fd)$/;"	f	signature:(struct bufferevent *bufev, int fd)
bufferevent_setfd	event.h	/^void bufferevent_setfd(struct bufferevent *bufev, int fd);$/;"	p	signature:(struct bufferevent *bufev, int fd)
bufferevent_settimeout	evbuffer.c	/^bufferevent_settimeout(struct bufferevent *bufev,$/;"	f	signature:(struct bufferevent *bufev, int timeout_read, int timeout_write)
bufferevent_settimeout	event.h	/^void bufferevent_settimeout(struct bufferevent *bufev,$/;"	p	signature:(struct bufferevent *bufev, int timeout_read, int timeout_write)
bufferevent_setwatermark	evbuffer.c	/^bufferevent_setwatermark(struct bufferevent *bufev, short events,$/;"	f	signature:(struct bufferevent *bufev, short events, size_t lowmark, size_t highmark)
bufferevent_setwatermark	event.h	/^void bufferevent_setwatermark(struct bufferevent *bufev, short events,$/;"	p	signature:(struct bufferevent *bufev, short events, size_t lowmark, size_t highmark)
bufferevent_write	evbuffer.c	/^bufferevent_write(struct bufferevent *bufev, const void *data, size_t size)$/;"	f	signature:(struct bufferevent *bufev, const void *data, size_t size)
bufferevent_write	event.h	/^int bufferevent_write(struct bufferevent *bufev,$/;"	p	signature:(struct bufferevent *bufev, const void *data, size_t size)
bufferevent_write_buffer	evbuffer.c	/^bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf)$/;"	f	signature:(struct bufferevent *bufev, struct evbuffer *buf)
bufferevent_write_buffer	event.h	/^int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf);$/;"	p	signature:(struct bufferevent *bufev, struct evbuffer *buf)
bufferevent_writecb	evbuffer.c	/^bufferevent_writecb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
build	Makefile	/^build = i686-pc-linux-gnu$/;"	m
build	sample/Makefile	/^build = i686-pc-linux-gnu$/;"	m
build	test/Makefile	/^build = i686-pc-linux-gnu$/;"	m
build_alias	Makefile	/^build_alias = $/;"	m
build_alias	sample/Makefile	/^build_alias = $/;"	m
build_alias	test/Makefile	/^build_alias = $/;"	m
build_cpu	Makefile	/^build_cpu = i686$/;"	m
build_cpu	sample/Makefile	/^build_cpu = i686$/;"	m
build_cpu	test/Makefile	/^build_cpu = i686$/;"	m
build_os	Makefile	/^build_os = linux-gnu$/;"	m
build_os	sample/Makefile	/^build_os = linux-gnu$/;"	m
build_os	test/Makefile	/^build_os = linux-gnu$/;"	m
build_triplet	Makefile	/^build_triplet = i686-pc-linux-gnu$/;"	m
build_triplet	sample/Makefile	/^build_triplet = i686-pc-linux-gnu$/;"	m
build_triplet	test/Makefile	/^build_triplet = i686-pc-linux-gnu$/;"	m
build_vendor	Makefile	/^build_vendor = pc$/;"	m
build_vendor	sample/Makefile	/^build_vendor = pc$/;"	m
build_vendor	test/Makefile	/^build_vendor = pc$/;"	m
builddir	Makefile	/^builddir = .$/;"	m
builddir	sample/Makefile	/^builddir = .$/;"	m
builddir	test/Makefile	/^builddir = .$/;"	m
callbacks	http-internal.h	/^	TAILQ_HEAD(httpcbq, evhttp_cb) callbacks;$/;"	m	struct:evhttp	access:public
called	sample/signal-test.c	/^int called = 0;$/;"	v
called	test/regress.c	/^static int called;$/;"	v	file:
called	test/test-eof.c	/^int called = 0;$/;"	v
called	test/test-time.c	/^int called = 0;$/;"	v
called	test/test-weof.c	/^int called = 0;$/;"	v
cb	event.c	/^	void (*cb)(int, short, void *);$/;"	m	struct:event_once	file:	access:public
cb	event.h	/^	void (*cb)(struct evbuffer *, size_t, size_t, void *);$/;"	m	struct:evbuffer	access:public
cb	evhttp.h	/^	void (*cb)(struct evhttp_request *, void *);$/;"	m	struct:evhttp_request	access:public
cb	evrpc.h	/^	void (*cb)(struct evrpc_req_generic *, void *);$/;"	m	struct:evrpc	access:public
cb	evrpc.h	/^	void (*cb)(struct evrpc_status*, void *request, void *reply, void *arg);$/;"	m	struct:evrpc_request_wrapper	access:public
cb	http-internal.h	/^						   void (*cb)(struct evhttp_connection *, void *);$/;"	m	struct:evhttp_connection	access:public
cb	http-internal.h	/^	void (*cb)(struct evhttp_request *req, void *);$/;"	m	struct:evhttp_cb	access:public
cb_arg	evhttp.h	/^	void *cb_arg;$/;"	m	struct:evhttp_request	access:public
cb_arg	evrpc.h	/^	void *cb_arg;$/;"	m	struct:evrpc	access:public
cb_arg	evrpc.h	/^	void *cb_arg;$/;"	m	struct:evrpc_request_wrapper	access:public
cb_arg	http-internal.h	/^	void *cb_arg;$/;"	m	struct:evhttp_connection	access:public
cbarg	event.h	/^	void *cbarg;$/;"	m	struct:bufferevent	access:public
cbarg	event.h	/^	void *cbarg;$/;"	m	struct:evbuffer	access:public
cbarg	http-internal.h	/^	void *cbarg;$/;"	m	struct:evhttp_cb	access:public
changes	devpoll.c	/^	struct pollfd *changes;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:	access:public
changes	kqueue.c	/^	struct kevent *changes;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:	access:public
check_event	evport.c	/^check_event(port_event_t* pevt)$/;"	f	file:	signature:(port_event_t* pevt)
check_event	evport.c	228;"	d	file:
check_evportop	evport.c	/^check_evportop(struct evport_data *evpd)$/;"	f	file:	signature:(struct evport_data *evpd)
check_evportop	evport.c	227;"	d	file:
check_selectop	select.c	/^check_selectop(struct selectop *sop)$/;"	f	file:	signature:(struct selectop *sop)
check_selectop	select.c	134;"	d	file:
child_signal_cb	test/regress.c	/^child_signal_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
choked	evdns.c	/^	char choked;  \/* true if we have an EAGAIN from this server's socket *\/$/;"	m	struct:nameserver	file:	access:public
choked	evdns.c	/^	char choked; \/* Are we currently blocked from writing? *\/$/;"	m	struct:evdns_server_port	file:	access:public
chunk_cb	evhttp.h	/^	void (*chunk_cb)(struct evhttp_request *, void *);$/;"	m	struct:evhttp_request	access:public
chunk_req_state	test/regress_http.c	/^struct chunk_req_state {$/;"	s	file:
chunk_req_state::i	test/regress_http.c	/^	int i;$/;"	m	struct:chunk_req_state	file:	access:public
chunk_req_state::req	test/regress_http.c	/^	struct evhttp_request *req;$/;"	m	struct:chunk_req_state	typeref:struct:chunk_req_state::evhttp_request	file:	access:public
chunked	evhttp.h	/^	int chunked;$/;"	m	struct:evhttp_request	access:public
class	evdns.c	/^	u16 class : 16; \/* The RR class (usually CLASS_INET) *\/$/;"	m	struct:server_reply_item	file:	access:public
cleanup_test	test/regress.c	/^cleanup_test(void)$/;"	f	file:	signature:(void)
clockinfo	compat/sys/_time.h	/^struct clockinfo {$/;"	s
clockinfo::hz	compat/sys/_time.h	/^	int	hz;		\/* clock frequency *\/$/;"	m	struct:clockinfo	access:public
clockinfo::profhz	compat/sys/_time.h	/^	int	profhz;		\/* profiling clock frequency *\/$/;"	m	struct:clockinfo	access:public
clockinfo::stathz	compat/sys/_time.h	/^	int	stathz;		\/* statistics clock frequency *\/$/;"	m	struct:clockinfo	access:public
clockinfo::tick	compat/sys/_time.h	/^	int	tick;		\/* micro-seconds per hz tick *\/$/;"	m	struct:clockinfo	access:public
clockinfo::tickadj	compat/sys/_time.h	/^	int	tickadj;	\/* clock skew rate for adjtime() *\/$/;"	m	struct:clockinfo	access:public
close	evdns.c	145;"	d	file:
close_detect_cb	test/regress_http.c	/^close_detect_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
close_detect_done	test/regress_http.c	/^close_detect_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
close_detect_launch	test/regress_http.c	/^close_detect_launch(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
close_ev	http-internal.h	/^	struct event close_ev;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event	access:public
closecb	http-internal.h	/^	void (*closecb)(struct evhttp_connection *, void *);$/;"	m	struct:evhttp_connection	access:public
closecb_arg	http-internal.h	/^	void *closecb_arg;$/;"	m	struct:evhttp_connection	access:public
closing	evdns.c	/^	char closing; \/* Are we trying to close this port, pending writes? *\/$/;"	m	struct:evdns_server_port	file:	access:public
combined_read_cb	test/regress.c	/^combined_read_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
combined_write_cb	test/regress.c	/^combined_write_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
common	evrpc-internal.h	/^	struct _evrpc_hooks common;$/;"	m	struct:evrpc_base	typeref:struct:evrpc_base::_evrpc_hooks	access:public
common	evrpc-internal.h	/^	struct _evrpc_hooks common;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::_evrpc_hooks	access:public
compare	WIN32-Code/win32.c	/^compare(struct event_entry *a, struct event_entry *b)$/;"	f	file:	signature:(struct event_entry *a, struct event_entry *b)
config_nameserver_from_reg_key	evdns.c	/^config_nameserver_from_reg_key(HKEY key, const char *subkey)$/;"	f	file:	signature:(HKEY key, const char *subkey)
connections	evrpc-internal.h	/^	struct evconq connections;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::evconq	access:public
connections	http-internal.h	/^        struct evconq connections;$/;"	m	struct:evhttp	typeref:struct:evhttp::evconq	access:public
count	test/bench.c	/^static int count, writes, fired;$/;"	v	file:
count	test/regress.c	/^	int count;$/;"	m	struct:test_pri_event	file:	access:public
cppcomment	event_rpcgen.py	/^cppcomment = re.compile(r'\\\/\\\/.*$')$/;"	v
cppdirect	event_rpcgen.py	/^cppdirect = []$/;"	v
current_base	event.c	/^struct event_base *current_base = NULL;$/;"	v	typeref:struct:event_base
data	evdns.c	/^	void *data; \/* The contents of the RR *\/$/;"	m	struct:server_reply_item	file:	access:public
data	evdns.c	/^	} data;$/;"	m	struct:reply	typeref:union:reply::__anon1	file:	access:public
datadir	Makefile	/^datadir = ${datarootdir}$/;"	m
datadir	sample/Makefile	/^datadir = ${datarootdir}$/;"	m
datadir	test/Makefile	/^datadir = ${datarootdir}$/;"	m
datalen	evdns.c	/^	u16 datalen; \/* Length of data; -1 if data is a label *\/$/;"	m	struct:server_reply_item	file:	access:public
datarootdir	Makefile	/^datarootdir = ${prefix}\/share$/;"	m
datarootdir	sample/Makefile	/^datarootdir = ${prefix}\/share$/;"	m
datarootdir	test/Makefile	/^datarootdir = ${prefix}\/share$/;"	m
dc_install_base	Makefile	/^	dc_install_base=`$(am__cd) $(distdir)\/_inst && pwd | sed -e 's,^[^:\\\\\/]:[\\\\\/],\/,'` \\$/;"	m
dealloc	event-internal.h	/^	void (*dealloc)(struct event_base *, void *);$/;"	m	struct:eventop	access:public
debug_ntoa	evdns.c	/^debug_ntoa(u32 address)$/;"	f	file:	signature:(u32 address)
decode_int_internal	event_tagging.c	/^decode_int_internal(ev_uint32_t *pnumber, struct evbuffer *evbuf, int dodrain)$/;"	f	file:	signature:(ev_uint32_t *pnumber, struct evbuffer *evbuf, int dodrain)
decode_tag_internal	event_tagging.c	/^decode_tag_internal(ev_uint32_t *ptag, struct evbuffer *evbuf, int dodrain)$/;"	f	file:	signature:(ev_uint32_t *ptag, struct evbuffer *evbuf, int dodrain)
default_transaction_id_fn	evdns.c	/^default_transaction_id_fn(void)$/;"	f	file:	signature:(void)
del	event-internal.h	/^	int (*del)(void *, struct event *);$/;"	m	struct:eventop	access:public
delayed_client	test/regress_http.c	/^static struct evhttp_connection *delayed_client;$/;"	v	typeref:struct:evhttp_connection	file:
depcomp	Makefile	/^depcomp =$/;"	m
depcomp	sample/Makefile	/^depcomp =$/;"	m
depcomp	test/Makefile	/^depcomp =$/;"	m
detect_monotonic	event.c	/^detect_monotonic(void)$/;"	f	file:	signature:(void)
devpoll_add	devpoll.c	/^devpoll_add(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
devpoll_add	devpoll.c	/^static int devpoll_add	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
devpoll_commit	devpoll.c	/^devpoll_commit(struct devpollop *devpollop)$/;"	f	file:	signature:(struct devpollop *devpollop)
devpoll_dealloc	devpoll.c	/^devpoll_dealloc(struct event_base *base, void *arg)$/;"	f	file:	signature:(struct event_base *base, void *arg)
devpoll_dealloc	devpoll.c	/^static void devpoll_dealloc	(struct event_base *, void *);$/;"	p	file:	signature:(struct event_base *, void *)
devpoll_del	devpoll.c	/^devpoll_del(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
devpoll_del	devpoll.c	/^static int devpoll_del	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
devpoll_dispatch	devpoll.c	/^devpoll_dispatch(struct event_base *base, void *arg, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, void *arg, struct timeval *tv)
devpoll_dispatch	devpoll.c	/^static int devpoll_dispatch	(struct event_base *, void *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, void *, struct timeval *)
devpoll_init	devpoll.c	/^devpoll_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
devpoll_init	devpoll.c	/^static void *devpoll_init	(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
devpoll_queue	devpoll.c	/^devpoll_queue(struct devpollop *devpollop, int fd, int events) {$/;"	f	file:	signature:(struct devpollop *devpollop, int fd, int events)
devpoll_recalc	devpoll.c	/^devpoll_recalc(struct event_base *base, void *arg, int max)$/;"	f	file:	signature:(struct event_base *base, void *arg, int max)
devpollop	devpoll.c	/^struct devpollop {$/;"	s	file:
devpollop::changes	devpoll.c	/^	struct pollfd *changes;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:	access:public
devpollop::dpfd	devpoll.c	/^	int dpfd;$/;"	m	struct:devpollop	file:	access:public
devpollop::events	devpoll.c	/^	struct pollfd *events;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:	access:public
devpollop::fds	devpoll.c	/^	struct evdevpoll *fds;$/;"	m	struct:devpollop	typeref:struct:devpollop::evdevpoll	file:	access:public
devpollop::nchanges	devpoll.c	/^	int nchanges;$/;"	m	struct:devpollop	file:	access:public
devpollop::nevents	devpoll.c	/^	int nevents;$/;"	m	struct:devpollop	file:	access:public
devpollop::nfds	devpoll.c	/^	int nfds;$/;"	m	struct:devpollop	file:	access:public
devpollops	devpoll.c	/^const struct eventop devpollops = {$/;"	v	typeref:struct:eventop
dispatch	event-internal.h	/^	int (*dispatch)(struct event_base *, void *, struct timeval *);$/;"	m	struct:eventop	access:public
distcleancheck_listfiles	Makefile	/^distcleancheck_listfiles = find . -type f -print$/;"	m
distdir	Makefile	/^distdir = $(PACKAGE)-$(VERSION)$/;"	m
distuninstallcheck_listfiles	Makefile	/^distuninstallcheck_listfiles = find . -type f -print$/;"	m
dns_err	test/regress_dns.c	/^static int dns_err = 0;$/;"	v	file:
dns_gethostbyaddr	test/regress_dns.c	/^dns_gethostbyaddr(void)$/;"	f	file:	signature:(void)
dns_gethostbyname	test/regress_dns.c	/^dns_gethostbyname(void)$/;"	f	file:	signature:(void)
dns_gethostbyname6	test/regress_dns.c	/^dns_gethostbyname6(void)$/;"	f	file:	signature:(void)
dns_gethostbyname_cb	test/regress_dns.c	/^dns_gethostbyname_cb(int result, char type, int count, int ttl,$/;"	f	file:	signature:(int result, char type, int count, int ttl, void *addresses, void *arg)
dns_ok	test/regress_dns.c	/^static int dns_ok = 0;$/;"	v	file:
dns_question_class	evdns.h	/^	int dns_question_class;$/;"	m	struct:evdns_server_question	access:public
dns_question_class	evdns.h	487;"	d
dns_server	test/regress_dns.c	/^dns_server(void)$/;"	f	file:	signature:(void)
dns_server_gethostbyname_cb	test/regress_dns.c	/^dns_server_gethostbyname_cb(int result, char type, int count, int ttl,$/;"	f	file:	signature:(int result, char type, int count, int ttl, void *addresses, void *arg)
dns_server_request_cb	test/regress_dns.c	/^dns_server_request_cb(struct evdns_server_request *req, void *data)$/;"	f	file:	signature:(struct evdns_server_request *req, void *data)
dns_suite	test/regress.h	/^void dns_suite(void);$/;"	p	signature:(void)
dns_suite	test/regress_dns.c	/^dns_suite(void)$/;"	f	signature:(void)
dns_suite	test/regress_dns.c	/^void dns_suite(void);$/;"	p	file:	signature:(void)
dnslabel_clear	evdns.c	/^dnslabel_clear(struct dnslabel_table *table)$/;"	f	file:	signature:(struct dnslabel_table *table)
dnslabel_entry	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	s	file:
dnslabel_entry::pos	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:	access:public
dnslabel_entry::v	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:	access:public
dnslabel_table	evdns.c	/^struct dnslabel_table {$/;"	s	file:
dnslabel_table::labels	evdns.c	/^	struct dnslabel_entry labels[MAX_LABELS];$/;"	m	struct:dnslabel_table	typeref:struct:dnslabel_table::dnslabel_entry	file:	access:public
dnslabel_table::n_labels	evdns.c	/^	int n_labels; \/* number of current entries *\/$/;"	m	struct:dnslabel_table	file:	access:public
dnslabel_table_add	evdns.c	/^dnslabel_table_add(struct dnslabel_table *table, const char *label, off_t pos)$/;"	f	file:	signature:(struct dnslabel_table *table, const char *label, off_t pos)
dnslabel_table_get_pos	evdns.c	/^dnslabel_table_get_pos(const struct dnslabel_table *table, const char *label)$/;"	f	file:	signature:(const struct dnslabel_table *table, const char *label)
dnslabel_table_init	evdns.c	/^dnslabel_table_init(struct dnslabel_table *table)$/;"	f	file:	signature:(struct dnslabel_table *table)
dnsname_to_labels	evdns.c	/^dnsname_to_labels(u8 *const buf, size_t buf_len, off_t j,$/;"	f	file:	signature:(u8 *const buf, size_t buf_len, off_t j, const char *name, const int name_len, struct dnslabel_table *table)
do_fd_clear	WIN32-Code/win32.c	/^do_fd_clear(struct win32op *op, struct event_entry *ent, int read)$/;"	f	file:	signature:(struct win32op *op, struct event_entry *ent, int read)
do_fd_set	WIN32-Code/win32.c	/^do_fd_set(struct win32op *op, struct event_entry *ent, int read)$/;"	f	file:	signature:(struct win32op *op, struct event_entry *ent, int read)
docdir	Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE}$/;"	m
docdir	sample/Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE}$/;"	m
docdir	test/Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE}$/;"	m
done	evrpc.h	/^	void (*done)(struct evrpc_req_generic* rpc); $/;"	m	struct:evrpc_req_generic	access:public
dpfd	devpoll.c	/^	int dpfd;$/;"	m	struct:devpollop	file:	access:public
dvidir	Makefile	/^dvidir = ${docdir}$/;"	m
dvidir	sample/Makefile	/^dvidir = ${docdir}$/;"	m
dvidir	test/Makefile	/^dvidir = ${docdir}$/;"	m
ed_fds	evport.c	/^	struct fd_info *ed_fds;		\/* allocated fdi table 		 *\/$/;"	m	struct:evport_data	typeref:struct:evport_data::fd_info	file:	access:public
ed_nevents	evport.c	/^	int		ed_nevents;	\/* number of allocated fdi's 	 *\/$/;"	m	struct:evport_data	file:	access:public
ed_pending	evport.c	/^	int ed_pending[EVENTS_PER_GETN]; \/* fd's with pending events *\/$/;"	m	struct:evport_data	file:	access:public
ed_port	evport.c	/^	int 		ed_port;	\/* event port for system events  *\/$/;"	m	struct:evport_data	file:	access:public
enabled	event.h	/^	short enabled;	\/* events that are currently enabled *\/$/;"	m	struct:bufferevent	access:public
encode_int	event.h	/^void encode_int(struct evbuffer *evbuf, ev_uint32_t number);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t number)
encode_int	event_tagging.c	/^encode_int(struct evbuffer *evbuf, ev_uint32_t number)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t number)
epfd	epoll.c	/^	int epfd;$/;"	m	struct:epollop	file:	access:public
epoll_add	epoll.c	/^epoll_add(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
epoll_add	epoll.c	/^static int epoll_add	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
epoll_create	epoll_sub.c	/^epoll_create(int size)$/;"	f	signature:(int size)
epoll_ctl	epoll_sub.c	/^epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)$/;"	f	signature:(int epfd, int op, int fd, struct epoll_event *event)
epoll_dealloc	epoll.c	/^epoll_dealloc(struct event_base *base, void *arg)$/;"	f	file:	signature:(struct event_base *base, void *arg)
epoll_dealloc	epoll.c	/^static void epoll_dealloc	(struct event_base *, void *);$/;"	p	file:	signature:(struct event_base *, void *)
epoll_del	epoll.c	/^epoll_del(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
epoll_del	epoll.c	/^static int epoll_del	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
epoll_dispatch	epoll.c	/^epoll_dispatch(struct event_base *base, void *arg, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, void *arg, struct timeval *tv)
epoll_dispatch	epoll.c	/^static int epoll_dispatch	(struct event_base *, void *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, void *, struct timeval *)
epoll_init	epoll.c	/^epoll_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
epoll_init	epoll.c	/^static void *epoll_init	(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
epoll_recalc	epoll.c	/^epoll_recalc(struct event_base *base, void *arg, int max)$/;"	f	file:	signature:(struct event_base *base, void *arg, int max)
epoll_wait	epoll_sub.c	/^epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)$/;"	f	signature:(int epfd, struct epoll_event *events, int maxevents, int timeout)
epollop	epoll.c	/^struct epollop {$/;"	s	file:
epollop::epfd	epoll.c	/^	int epfd;$/;"	m	struct:epollop	file:	access:public
epollop::events	epoll.c	/^	struct epoll_event *events;$/;"	m	struct:epollop	typeref:struct:epollop::epoll_event	file:	access:public
epollop::fds	epoll.c	/^	struct evepoll *fds;$/;"	m	struct:epollop	typeref:struct:epollop::evepoll	file:	access:public
epollop::nevents	epoll.c	/^	int nevents;$/;"	m	struct:epollop	file:	access:public
epollop::nfds	epoll.c	/^	int nfds;$/;"	m	struct:epollop	file:	access:public
epollops	epoll.c	/^const struct eventop epollops = {$/;"	v	typeref:struct:eventop
error	evrpc.h	/^	int error;$/;"	m	struct:evrpc_status	access:public
error_is_eagain	evdns.c	/^error_is_eagain(int err)$/;"	f	file:	signature:(int err)
error_is_eagain	evdns.c	375;"	d	file:
errorcb	event.h	/^	everrorcb errorcb;$/;"	m	struct:bufferevent	access:public
errorcb	test/regress.c	/^errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
ev	event.c	/^	struct event ev;$/;"	m	struct:event_once	typeref:struct:event_once::event	file:	access:public
ev	http-internal.h	/^	struct event ev;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event	access:public
ev	test/regress.c	/^	struct event ev;$/;"	m	struct:both	typeref:struct:both::event	file:	access:public
ev	test/regress.c	/^	struct event ev;$/;"	m	struct:test_pri_event	typeref:struct:test_pri_event::event	file:	access:public
ev	test/test-time.c	/^struct event *ev[NEVENT];$/;"	v	typeref:struct:event
ev_active_next	event.h	/^	TAILQ_ENTRY (event) ev_active_next;$/;"	m	struct:event	access:public
ev_arg	event.h	/^	void *ev_arg;$/;"	m	struct:event	access:public
ev_base	event.h	/^	struct event_base *ev_base;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_base	access:public
ev_base	event.h	/^	struct event_base *ev_base;$/;"	m	struct:event	typeref:struct:event::event_base	access:public
ev_callback	event.h	/^	void (*ev_callback)(int, short, void *arg);$/;"	m	struct:event	access:public
ev_events	event.h	/^	short ev_events;$/;"	m	struct:event	access:public
ev_fd	event.h	/^	int ev_fd;$/;"	m	struct:event	access:public
ev_flags	event.h	/^	int ev_flags;$/;"	m	struct:event	access:public
ev_int64_t	evutil.h	57;"	d
ev_int64_t	evutil.h	60;"	d
ev_int64_t	evutil.h	63;"	d
ev_int64_t	evutil.h	66;"	d
ev_ncalls	event.h	/^	short ev_ncalls;$/;"	m	struct:event	access:public
ev_next	event.h	/^	TAILQ_ENTRY (event) ev_next;$/;"	m	struct:event	access:public
ev_pncalls	event.h	/^	short *ev_pncalls;	\/* Allows deletes in callback *\/$/;"	m	struct:event	access:public
ev_pri	event.h	/^	int ev_pri;		\/* smaller numbers are higher priority *\/$/;"	m	struct:event	access:public
ev_read	event.h	/^	struct event ev_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
ev_res	event.h	/^	int ev_res;		\/* result passed to event callback *\/$/;"	m	struct:event	access:public
ev_sighandler_t	evsignal.h	/^typedef void (*ev_sighandler_t)(int);$/;"	t
ev_signal	evsignal.h	/^	struct event ev_signal;$/;"	m	struct:evsignal_info	typeref:struct:evsignal_info::event	access:public
ev_signal_added	evsignal.h	/^	int ev_signal_added;$/;"	m	struct:evsignal_info	access:public
ev_signal_next	event.h	/^	TAILQ_ENTRY (event) ev_signal_next;$/;"	m	struct:event	access:public
ev_signal_pair	evsignal.h	/^	int ev_signal_pair[2];$/;"	m	struct:evsignal_info	access:public
ev_timeout	event.h	/^	struct timeval ev_timeout;$/;"	m	struct:event	typeref:struct:event::timeval	access:public
ev_timeout	evrpc.h	/^	struct event ev_timeout;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::event	access:public
ev_uint16_t	evutil.h	84;"	d
ev_uint16_t	evutil.h	86;"	d
ev_uint16_t	evutil.h	88;"	d
ev_uint16_t	evutil.h	90;"	d
ev_uint32_t	evutil.h	72;"	d
ev_uint32_t	evutil.h	74;"	d
ev_uint32_t	evutil.h	76;"	d
ev_uint32_t	evutil.h	78;"	d
ev_uint64_t	evutil.h	56;"	d
ev_uint64_t	evutil.h	59;"	d
ev_uint64_t	evutil.h	62;"	d
ev_uint64_t	evutil.h	65;"	d
ev_uint8_t	evutil.h	96;"	d
ev_uint8_t	evutil.h	98;"	d
ev_write	event.h	/^	struct event ev_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event	access:public
evbase	event-internal.h	/^	void *evbase;$/;"	m	struct:event_base	access:public
evbuffer	event.h	/^struct evbuffer {$/;"	s
evbuffer::buffer	event.h	/^	u_char *buffer;$/;"	m	struct:evbuffer	access:public
evbuffer::cb	event.h	/^	void (*cb)(struct evbuffer *, size_t, size_t, void *);$/;"	m	struct:evbuffer	access:public
evbuffer::cbarg	event.h	/^	void *cbarg;$/;"	m	struct:evbuffer	access:public
evbuffer::misalign	event.h	/^	size_t misalign;$/;"	m	struct:evbuffer	access:public
evbuffer::off	event.h	/^	size_t off;$/;"	m	struct:evbuffer	access:public
evbuffer::orig_buffer	event.h	/^	u_char *orig_buffer;$/;"	m	struct:evbuffer	access:public
evbuffer::totallen	event.h	/^	size_t totallen;$/;"	m	struct:evbuffer	access:public
evbuffer_add	buffer.c	/^evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)$/;"	f	signature:(struct evbuffer *buf, const void *data, size_t datlen)
evbuffer_add	event.h	/^int evbuffer_add(struct evbuffer *, const void *, size_t);$/;"	p	signature:(struct evbuffer *, const void *, size_t)
evbuffer_add_buffer	buffer.c	/^evbuffer_add_buffer(struct evbuffer *outbuf, struct evbuffer *inbuf)$/;"	f	signature:(struct evbuffer *outbuf, struct evbuffer *inbuf)
evbuffer_add_buffer	event.h	/^int evbuffer_add_buffer(struct evbuffer *, struct evbuffer *);$/;"	p	signature:(struct evbuffer *, struct evbuffer *)
evbuffer_add_printf	buffer.c	/^evbuffer_add_printf(struct evbuffer *buf, const char *fmt, ...)$/;"	f	signature:(struct evbuffer *buf, const char *fmt, ...)
evbuffer_add_printf	event.h	/^int evbuffer_add_printf(struct evbuffer *, const char *fmt, ...)$/;"	p	signature:(struct evbuffer *, const char *fmt, ...)
evbuffer_add_vprintf	buffer.c	/^evbuffer_add_vprintf(struct evbuffer *buf, const char *fmt, va_list ap)$/;"	f	signature:(struct evbuffer *buf, const char *fmt, va_list ap)
evbuffer_add_vprintf	event.h	/^int evbuffer_add_vprintf(struct evbuffer *, const char *fmt, va_list ap);$/;"	p	signature:(struct evbuffer *, const char *fmt, va_list ap)
evbuffer_align	buffer.c	/^evbuffer_align(struct evbuffer *buf)$/;"	f	file:	signature:(struct evbuffer *buf)
evbuffer_drain	buffer.c	/^evbuffer_drain(struct evbuffer *buf, size_t len)$/;"	f	signature:(struct evbuffer *buf, size_t len)
evbuffer_drain	event.h	/^void evbuffer_drain(struct evbuffer *, size_t);$/;"	p	signature:(struct evbuffer *, size_t)
evbuffer_expand	buffer.c	/^evbuffer_expand(struct evbuffer *buf, size_t datlen)$/;"	f	signature:(struct evbuffer *buf, size_t datlen)
evbuffer_expand	event.h	/^int evbuffer_expand(struct evbuffer *, size_t);$/;"	p	signature:(struct evbuffer *, size_t)
evbuffer_find	buffer.c	/^evbuffer_find(struct evbuffer *buffer, const u_char *what, size_t len)$/;"	f	signature:(struct evbuffer *buffer, const u_char *what, size_t len)
evbuffer_find	event.h	/^u_char *evbuffer_find(struct evbuffer *, const u_char *, size_t);$/;"	p	signature:(struct evbuffer *, const u_char *, size_t)
evbuffer_free	buffer.c	/^evbuffer_free(struct evbuffer *buffer)$/;"	f	signature:(struct evbuffer *buffer)
evbuffer_free	event.h	/^void evbuffer_free(struct evbuffer *);$/;"	p	signature:(struct evbuffer *)
evbuffer_new	buffer.c	/^evbuffer_new(void)$/;"	f	signature:(void)
evbuffer_new	event.h	/^struct evbuffer *evbuffer_new(void);$/;"	p	signature:(void)
evbuffer_read	buffer.c	/^evbuffer_read(struct evbuffer *buf, int fd, int howmuch)$/;"	f	signature:(struct evbuffer *buf, int fd, int howmuch)
evbuffer_read	event.h	/^int evbuffer_read(struct evbuffer *, int, int);$/;"	p	signature:(struct evbuffer *, int, int)
evbuffer_readline	buffer.c	/^evbuffer_readline(struct evbuffer *buffer)$/;"	f	signature:(struct evbuffer *buffer)
evbuffer_readline	event.h	/^char *evbuffer_readline(struct evbuffer *);$/;"	p	signature:(struct evbuffer *)
evbuffer_remove	buffer.c	/^evbuffer_remove(struct evbuffer *buf, void *data, size_t datlen)$/;"	f	signature:(struct evbuffer *buf, void *data, size_t datlen)
evbuffer_remove	event.h	/^int evbuffer_remove(struct evbuffer *, void *, size_t);$/;"	p	signature:(struct evbuffer *, void *, size_t)
evbuffer_setcb	buffer.c	/^void evbuffer_setcb(struct evbuffer *buffer,$/;"	f	signature:(struct evbuffer *buffer, void (*cb)(struct evbuffer *, size_t, size_t, void *), void *cbarg)
evbuffer_setcb	event.h	/^void evbuffer_setcb(struct evbuffer *, void (*)(struct evbuffer *, size_t, size_t, void *), void *);$/;"	p	signature:(struct evbuffer *, void (*)(struct evbuffer *, size_t, size_t, void *), void *)
evbuffer_write	buffer.c	/^evbuffer_write(struct evbuffer *buffer, int fd)$/;"	f	signature:(struct evbuffer *buffer, int fd)
evbuffer_write	event.h	/^int evbuffer_write(struct evbuffer *, int);$/;"	p	signature:(struct evbuffer *, int)
evbuffercb	event.h	/^typedef void (*evbuffercb)(struct bufferevent *, void *);$/;"	t
evcon	evhttp.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evhttp_connection	access:public
evcon	evrpc.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evhttp_connection	access:public
evdevpoll	devpoll.c	/^struct evdevpoll {$/;"	s	file:
evdevpoll::evread	devpoll.c	/^	struct event *evread;$/;"	m	struct:evdevpoll	typeref:struct:evdevpoll::event	file:	access:public
evdevpoll::evwrite	devpoll.c	/^	struct event *evwrite;$/;"	m	struct:evdevpoll	typeref:struct:evdevpoll::event	file:	access:public
evdns_add_server_port	evdns.c	/^evdns_add_server_port(int socket, int is_tcp, evdns_request_callback_fn_type cb, void *user_data)$/;"	f	signature:(int socket, int is_tcp, evdns_request_callback_fn_type cb, void *user_data)
evdns_add_server_port	evdns.h	/^struct evdns_server_port *evdns_add_server_port(int socket, int is_tcp, evdns_request_callback_fn_type callback, void *user_data);$/;"	p	signature:(int socket, int is_tcp, evdns_request_callback_fn_type callback, void *user_data)
evdns_callback_type	evdns.h	/^typedef void (*evdns_callback_type) (int result, char type, int count, int ttl, void *addresses, void *arg);$/;"	t
evdns_clear_nameservers_and_suspend	evdns.c	/^evdns_clear_nameservers_and_suspend(void)$/;"	f	signature:(void)
evdns_clear_nameservers_and_suspend	evdns.h	/^int evdns_clear_nameservers_and_suspend(void);$/;"	p	signature:(void)
evdns_close_server_port	evdns.c	/^evdns_close_server_port(struct evdns_server_port *port)$/;"	f	signature:(struct evdns_server_port *port)
evdns_close_server_port	evdns.h	/^void evdns_close_server_port(struct evdns_server_port *port);$/;"	p	signature:(struct evdns_server_port *port)
evdns_config_windows_nameservers	evdns.c	/^evdns_config_windows_nameservers(void)$/;"	f	file:	signature:(void)
evdns_config_windows_nameservers	evdns.h	/^int evdns_config_windows_nameservers(void);$/;"	p	signature:(void)
evdns_count_nameservers	evdns.c	/^evdns_count_nameservers(void)$/;"	f	signature:(void)
evdns_count_nameservers	evdns.h	/^int evdns_count_nameservers(void);$/;"	p	signature:(void)
evdns_debug_log_fn_type	evdns.h	/^typedef void (*evdns_debug_log_fn_type)(int is_warning, const char *msg);$/;"	t
evdns_err_to_string	evdns.c	/^evdns_err_to_string(int err)$/;"	f	signature:(int err)
evdns_err_to_string	evdns.h	/^const char *evdns_err_to_string(int err);$/;"	p	signature:(int err)
evdns_init	evdns.c	/^evdns_init(void)$/;"	f	signature:(void)
evdns_init	evdns.h	/^int evdns_init(void);$/;"	p	signature:(void)
evdns_log_fn	evdns.c	/^static evdns_debug_log_fn_type evdns_log_fn = NULL;$/;"	v	file:
evdns_nameserver_add	evdns.c	/^evdns_nameserver_add(unsigned long int address) {$/;"	f	signature:(unsigned long int address)
evdns_nameserver_add	evdns.h	/^int evdns_nameserver_add(unsigned long int address);$/;"	p	signature:(unsigned long int address)
evdns_nameserver_ip_add	evdns.c	/^evdns_nameserver_ip_add(const char *ip_as_string) {$/;"	f	signature:(const char *ip_as_string)
evdns_nameserver_ip_add	evdns.h	/^int evdns_nameserver_ip_add(const char *ip_as_string);$/;"	p	signature:(const char *ip_as_string)
evdns_nameserver_ip_add_line	evdns.c	/^evdns_nameserver_ip_add_line(const char *ips) {$/;"	f	file:	signature:(const char *ips)
evdns_request_callback_fn_type	evdns.h	/^typedef void (*evdns_request_callback_fn_type)(struct evdns_server_request *, void *);$/;"	t
evdns_request_data_build	evdns.c	/^evdns_request_data_build(const char *const name, const int name_len,$/;"	f	file:	signature:(const char *const name, const int name_len, const u16 trans_id, const u16 type, const u16 class, u8 *const buf, size_t buf_len)
evdns_request_insert	evdns.c	/^evdns_request_insert(struct request *req, struct request **head) {$/;"	f	file:	signature:(struct request *req, struct request **head)
evdns_request_insert	evdns.c	/^static void evdns_request_insert(struct request *req, struct request **head);$/;"	p	file:	signature:(struct request *req, struct request **head)
evdns_request_len	evdns.c	/^evdns_request_len(const int name_len) {$/;"	f	file:	signature:(const int name_len)
evdns_request_timeout_callback	evdns.c	/^evdns_request_timeout_callback(int fd, short events, void *arg) {$/;"	f	file:	signature:(int fd, short events, void *arg)
evdns_request_transmit	evdns.c	/^evdns_request_transmit(struct request *req) {$/;"	f	file:	signature:(struct request *req)
evdns_request_transmit	evdns.c	/^static int evdns_request_transmit(struct request *req);$/;"	p	file:	signature:(struct request *req)
evdns_request_transmit_to	evdns.c	/^evdns_request_transmit_to(struct request *req, struct nameserver *server) {$/;"	f	file:	signature:(struct request *req, struct nameserver *server)
evdns_requests_pump_waiting_queue	evdns.c	/^evdns_requests_pump_waiting_queue(void) {$/;"	f	file:	signature:(void)
evdns_requests_pump_waiting_queue	evdns.c	/^static void evdns_requests_pump_waiting_queue(void);$/;"	p	file:	signature:(void)
evdns_resolv_conf_parse	evdns.c	/^evdns_resolv_conf_parse(int flags, const char *const filename) {$/;"	f	signature:(int flags, const char *const filename)
evdns_resolv_conf_parse	evdns.h	/^int evdns_resolv_conf_parse(int flags, const char *const filename);$/;"	p	signature:(int flags, const char *const filename)
evdns_resolv_set_defaults	evdns.c	/^evdns_resolv_set_defaults(int flags) {$/;"	f	file:	signature:(int flags)
evdns_resolve_ipv4	evdns.c	/^int evdns_resolve_ipv4(const char *name, int flags,$/;"	f	signature:(const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_ipv4	evdns.h	/^int evdns_resolve_ipv4(const char *name, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_ipv6	evdns.c	/^int evdns_resolve_ipv6(const char *name, int flags,$/;"	f	signature:(const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_ipv6	evdns.h	/^int evdns_resolve_ipv6(const char *name, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(const char *name, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_reverse	evdns.c	/^int evdns_resolve_reverse(struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f	signature:(struct in_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_reverse	evdns.h	/^int evdns_resolve_reverse(struct in_addr *in, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(struct in_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_reverse_ipv6	evdns.c	/^int evdns_resolve_reverse_ipv6(struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f	signature:(struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_resolve_reverse_ipv6	evdns.h	/^int evdns_resolve_reverse_ipv6(struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr);$/;"	p	signature:(struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr)
evdns_resume	evdns.c	/^evdns_resume(void)$/;"	f	signature:(void)
evdns_resume	evdns.h	/^int evdns_resume(void);$/;"	p	signature:(void)
evdns_search_add	evdns.c	/^evdns_search_add(const char *domain) {$/;"	f	signature:(const char *domain)
evdns_search_add	evdns.h	/^void evdns_search_add(const char *domain);$/;"	p	signature:(const char *domain)
evdns_search_clear	evdns.c	/^evdns_search_clear(void) {$/;"	f	signature:(void)
evdns_search_clear	evdns.h	/^void evdns_search_clear(void);$/;"	p	signature:(void)
evdns_search_ndots_set	evdns.c	/^evdns_search_ndots_set(const int ndots) {$/;"	f	signature:(const int ndots)
evdns_search_ndots_set	evdns.h	/^void evdns_search_ndots_set(const int ndots);$/;"	p	signature:(const int ndots)
evdns_server_callback	evdns.c	/^evdns_server_callback(struct evdns_server_request *req, void *data)$/;"	f	signature:(struct evdns_server_request *req, void *data)
evdns_server_port	evdns.c	/^struct evdns_server_port {$/;"	s	file:
evdns_server_port::choked	evdns.c	/^	char choked; \/* Are we currently blocked from writing? *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::closing	evdns.c	/^	char closing; \/* Are we trying to close this port, pending writes? *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::event	evdns.c	/^	struct event event; \/* Read\/write event *\/$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::event	file:	access:public
evdns_server_port::pending_replies	evdns.c	/^	struct server_request *pending_replies;$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::server_request	file:	access:public
evdns_server_port::refcnt	evdns.c	/^	int refcnt; \/* reference count. *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::socket	evdns.c	/^	int socket; \/* socket we use to read queries and write replies. *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::user_callback	evdns.c	/^	evdns_request_callback_fn_type user_callback; \/* Fn to handle requests *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_port::user_data	evdns.c	/^	void *user_data; \/* Opaque pointer passed to user_callback *\/$/;"	m	struct:evdns_server_port	file:	access:public
evdns_server_question	evdns.h	/^struct evdns_server_question {$/;"	s
evdns_server_question::dns_question_class	evdns.h	/^	int dns_question_class;$/;"	m	struct:evdns_server_question	access:public
evdns_server_question::name	evdns.h	/^	char name[1];$/;"	m	struct:evdns_server_question	access:public
evdns_server_question::type	evdns.h	/^	int type;$/;"	m	struct:evdns_server_question	access:public
evdns_server_request	evdns.h	/^struct evdns_server_request {$/;"	s
evdns_server_request::flags	evdns.h	/^	int flags;$/;"	m	struct:evdns_server_request	access:public
evdns_server_request::nquestions	evdns.h	/^	int nquestions;$/;"	m	struct:evdns_server_request	access:public
evdns_server_request::questions	evdns.h	/^	struct evdns_server_question **questions;$/;"	m	struct:evdns_server_request	typeref:struct:evdns_server_request::evdns_server_question	access:public
evdns_server_request_add_a_reply	evdns.c	/^evdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, void *addrs, int ttl)$/;"	f	signature:(struct evdns_server_request *req, const char *name, int n, void *addrs, int ttl)
evdns_server_request_add_a_reply	evdns.h	/^int evdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, void *addrs, int ttl);$/;"	p	signature:(struct evdns_server_request *req, const char *name, int n, void *addrs, int ttl)
evdns_server_request_add_aaaa_reply	evdns.c	/^evdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, void *addrs, int ttl)$/;"	f	signature:(struct evdns_server_request *req, const char *name, int n, void *addrs, int ttl)
evdns_server_request_add_aaaa_reply	evdns.h	/^int evdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, void *addrs, int ttl);$/;"	p	signature:(struct evdns_server_request *req, const char *name, int n, void *addrs, int ttl)
evdns_server_request_add_cname_reply	evdns.c	/^evdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl)$/;"	f	signature:(struct evdns_server_request *req, const char *name, const char *cname, int ttl)
evdns_server_request_add_cname_reply	evdns.h	/^int evdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl);$/;"	p	signature:(struct evdns_server_request *req, const char *name, const char *cname, int ttl)
evdns_server_request_add_ptr_reply	evdns.c	/^evdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)$/;"	f	signature:(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)
evdns_server_request_add_ptr_reply	evdns.h	/^int evdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl);$/;"	p	signature:(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)
evdns_server_request_add_reply	evdns.c	/^evdns_server_request_add_reply(struct evdns_server_request *_req, int section, const char *name, int type, int class, int ttl, int datalen, int is_name, const char *data)$/;"	f	signature:(struct evdns_server_request *_req, int section, const char *name, int type, int class, int ttl, int datalen, int is_name, const char *data)
evdns_server_request_add_reply	evdns.h	/^int evdns_server_request_add_reply(struct evdns_server_request *req, int section, const char *name, int type, int dns_class, int ttl, int datalen, int is_name, const char *data);$/;"	p	signature:(struct evdns_server_request *req, int section, const char *name, int type, int dns_class, int ttl, int datalen, int is_name, const char *data)
evdns_server_request_drop	evdns.c	/^evdns_server_request_drop(struct evdns_server_request *_req)$/;"	f	signature:(struct evdns_server_request *_req)
evdns_server_request_drop	evdns.h	/^int evdns_server_request_drop(struct evdns_server_request *req);$/;"	p	signature:(struct evdns_server_request *req)
evdns_server_request_format_response	evdns.c	/^evdns_server_request_format_response(struct server_request *req, int err)$/;"	f	file:	signature:(struct server_request *req, int err)
evdns_server_request_get_requesting_addr	evdns.c	/^evdns_server_request_get_requesting_addr(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len)$/;"	f	signature:(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len)
evdns_server_request_get_requesting_addr	evdns.h	/^int evdns_server_request_get_requesting_addr(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len);$/;"	p	signature:(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len)
evdns_server_request_respond	evdns.c	/^evdns_server_request_respond(struct evdns_server_request *_req, int err)$/;"	f	signature:(struct evdns_server_request *_req, int err)
evdns_server_request_respond	evdns.h	/^int evdns_server_request_respond(struct evdns_server_request *req, int err);$/;"	p	signature:(struct evdns_server_request *req, int err)
evdns_set_log_fn	evdns.c	/^evdns_set_log_fn(evdns_debug_log_fn_type fn)$/;"	f	signature:(evdns_debug_log_fn_type fn)
evdns_set_log_fn	evdns.h	/^void evdns_set_log_fn(evdns_debug_log_fn_type fn);$/;"	p	signature:(evdns_debug_log_fn_type fn)
evdns_set_option	evdns.c	/^evdns_set_option(const char *option, const char *val, int flags)$/;"	f	signature:(const char *option, const char *val, int flags)
evdns_set_option	evdns.h	/^int evdns_set_option(const char *option, const char *val, int flags);$/;"	p	signature:(const char *option, const char *val, int flags)
evdns_set_transaction_id_fn	evdns.c	/^evdns_set_transaction_id_fn(ev_uint16_t (*fn)(void))$/;"	f	signature:(ev_uint16_t (fn)void))
evdns_set_transaction_id_fn	evdns.h	/^void evdns_set_transaction_id_fn(ev_uint16_t (*fn)(void));$/;"	p	signature:(ev_uint16_t (fn)void))
evdns_shutdown	evdns.c	/^evdns_shutdown(int fail_requests)$/;"	f	signature:(int fail_requests)
evdns_shutdown	evdns.h	/^void evdns_shutdown(int fail_requests);$/;"	p	signature:(int fail_requests)
evdns_transmit	evdns.c	/^evdns_transmit(void) {$/;"	f	file:	signature:(void)
evdns_transmit	evdns.c	/^static int evdns_transmit(void);$/;"	p	file:	signature:(void)
event	evdns.c	/^	struct event event; \/* Read\/write event *\/$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::event	file:	access:public
event	evdns.c	/^	struct event event;$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:	access:public
event	event.h	/^struct event {$/;"	s
event::ev_active_next	event.h	/^	TAILQ_ENTRY (event) ev_active_next;$/;"	m	struct:event	access:public
event::ev_arg	event.h	/^	void *ev_arg;$/;"	m	struct:event	access:public
event::ev_base	event.h	/^	struct event_base *ev_base;$/;"	m	struct:event	typeref:struct:event::event_base	access:public
event::ev_callback	event.h	/^	void (*ev_callback)(int, short, void *arg);$/;"	m	struct:event	access:public
event::ev_events	event.h	/^	short ev_events;$/;"	m	struct:event	access:public
event::ev_fd	event.h	/^	int ev_fd;$/;"	m	struct:event	access:public
event::ev_flags	event.h	/^	int ev_flags;$/;"	m	struct:event	access:public
event::ev_ncalls	event.h	/^	short ev_ncalls;$/;"	m	struct:event	access:public
event::ev_next	event.h	/^	TAILQ_ENTRY (event) ev_next;$/;"	m	struct:event	access:public
event::ev_pncalls	event.h	/^	short *ev_pncalls;	\/* Allows deletes in callback *\/$/;"	m	struct:event	access:public
event::ev_pri	event.h	/^	int ev_pri;		\/* smaller numbers are higher priority *\/$/;"	m	struct:event	access:public
event::ev_res	event.h	/^	int ev_res;		\/* result passed to event callback *\/$/;"	m	struct:event	access:public
event::ev_signal_next	event.h	/^	TAILQ_ENTRY (event) ev_signal_next;$/;"	m	struct:event	access:public
event::ev_timeout	event.h	/^	struct timeval ev_timeout;$/;"	m	struct:event	typeref:struct:event::timeval	access:public
event::min_heap_idx	event.h	/^	unsigned int min_heap_idx;	\/* for managing timeouts *\/$/;"	m	struct:event	access:public
event_active	event.c	/^event_active(struct event *ev, int res, short ncalls)$/;"	f	signature:(struct event *ev, int res, short ncalls)
event_active	event.h	/^void event_active(struct event *, int, short);$/;"	p	signature:(struct event *, int, short)
event_add	event.c	/^event_add(struct event *ev, const struct timeval *tv)$/;"	f	signature:(struct event *ev, const struct timeval *tv)
event_add	event.h	/^int event_add(struct event *ev, const struct timeval *timeout);$/;"	p	signature:(struct event *ev, const struct timeval *timeout)
event_base	event-internal.h	/^struct event_base {$/;"	s
event_base::activequeues	event-internal.h	/^	struct event_list **activequeues;$/;"	m	struct:event_base	typeref:struct:event_base::event_list	access:public
event_base::evbase	event-internal.h	/^	void *evbase;$/;"	m	struct:event_base	access:public
event_base::event_break	event-internal.h	/^	int event_break;		\/* Set to terminate loop immediately *\/$/;"	m	struct:event_base	access:public
event_base::event_count	event-internal.h	/^	int event_count;		\/* counts number of total events *\/$/;"	m	struct:event_base	access:public
event_base::event_count_active	event-internal.h	/^	int event_count_active;	\/* counts number of active events *\/$/;"	m	struct:event_base	access:public
event_base::event_gotterm	event-internal.h	/^	int event_gotterm;		\/* Set to terminate loop *\/$/;"	m	struct:event_base	access:public
event_base::event_tv	event-internal.h	/^	struct timeval event_tv;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
event_base::eventqueue	event-internal.h	/^	struct event_list eventqueue;$/;"	m	struct:event_base	typeref:struct:event_base::event_list	access:public
event_base::evsel	event-internal.h	/^	const struct eventop *evsel;$/;"	m	struct:event_base	typeref:struct:event_base::eventop	access:public
event_base::nactivequeues	event-internal.h	/^	int nactivequeues;$/;"	m	struct:event_base	access:public
event_base::sig	event-internal.h	/^	struct evsignal_info sig;$/;"	m	struct:event_base	typeref:struct:event_base::evsignal_info	access:public
event_base::timeheap	event-internal.h	/^	struct min_heap timeheap;$/;"	m	struct:event_base	typeref:struct:event_base::min_heap	access:public
event_base::tv_cache	event-internal.h	/^	struct timeval tv_cache;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
event_base_dispatch	event.c	/^event_base_dispatch(struct event_base *event_base)$/;"	f	signature:(struct event_base *event_base)
event_base_dispatch	event.h	/^int event_base_dispatch(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_free	event.c	/^event_base_free(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_free	event.h	/^void event_base_free(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_get_method	event.c	/^event_base_get_method(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_base_get_method	event.h	/^const char *event_base_get_method(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_loop	event.c	/^event_base_loop(struct event_base *base, int flags)$/;"	f	signature:(struct event_base *base, int flags)
event_base_loop	event.h	/^int event_base_loop(struct event_base *, int);$/;"	p	signature:(struct event_base *, int)
event_base_loopbreak	event.c	/^event_base_loopbreak(struct event_base *event_base)$/;"	f	signature:(struct event_base *event_base)
event_base_loopbreak	event.h	/^int event_base_loopbreak(struct event_base *);$/;"	p	signature:(struct event_base *)
event_base_loopexit	event.c	/^event_base_loopexit(struct event_base *event_base, const struct timeval *tv)$/;"	f	signature:(struct event_base *event_base, const struct timeval *tv)
event_base_loopexit	event.h	/^int event_base_loopexit(struct event_base *, const struct timeval *);$/;"	p	signature:(struct event_base *, const struct timeval *)
event_base_new	event.c	/^event_base_new(void)$/;"	f	signature:(void)
event_base_new	event.h	/^struct event_base *event_base_new(void);$/;"	p	signature:(void)
event_base_once	event.c	/^event_base_once(struct event_base *base, int fd, short events,$/;"	f	signature:(struct event_base *base, int fd, short events, void (*callback)(int, short, void *), void *arg, const struct timeval *tv)
event_base_once	event.h	/^int event_base_once(struct event_base *base, int fd, short events,$/;"	p	signature:(struct event_base *base, int fd, short events, void (*callback)(int, short, void *), void *arg, const struct timeval *timeout)
event_base_priority_init	event.c	/^event_base_priority_init(struct event_base *base, int npriorities)$/;"	f	signature:(struct event_base *base, int npriorities)
event_base_priority_init	event.h	/^int	event_base_priority_init(struct event_base *, int);$/;"	p	signature:(struct event_base *, int)
event_base_set	event.c	/^event_base_set(struct event_base *base, struct event *ev)$/;"	f	signature:(struct event_base *base, struct event *ev)
event_base_set	event.h	/^int event_base_set(struct event_base *, struct event *);$/;"	p	signature:(struct event_base *, struct event *)
event_break	event-internal.h	/^	int event_break;		\/* Set to terminate loop immediately *\/$/;"	m	struct:event_base	access:public
event_count	event-internal.h	/^	int event_count;		\/* counts number of total events *\/$/;"	m	struct:event_base	access:public
event_count	poll.c	/^	int event_count;		\/* Highest number alloc *\/$/;"	m	struct:pollop	file:	access:public
event_count_active	event-internal.h	/^	int event_count_active;	\/* counts number of active events *\/$/;"	m	struct:event_base	access:public
event_debug	log.h	44;"	d
event_debug	log.h	46;"	d
event_del	event.c	/^event_del(struct event *ev)$/;"	f	signature:(struct event *ev)
event_del	event.h	/^int event_del(struct event *);$/;"	p	signature:(struct event *)
event_dispatch	event.c	/^event_dispatch(void)$/;"	f	signature:(void)
event_dispatch	event.h	/^int event_dispatch(void);$/;"	p	signature:(void)
event_entry	WIN32-Code/win32.c	/^struct event_entry {$/;"	s	file:
event_entry::RB_ENTRY	WIN32-Code/win32.c	/^	RB_ENTRY(event_entry) node;$/;"	p	struct:event_entry	file:	access:public
event_entry::read_event	WIN32-Code/win32.c	/^	struct event *read_event;$/;"	m	struct:event_entry	typeref:struct:event_entry::event	file:	access:public
event_entry::read_pos	WIN32-Code/win32.c	/^	int read_pos;$/;"	m	struct:event_entry	file:	access:public
event_entry::sock	WIN32-Code/win32.c	/^	SOCKET sock;$/;"	m	struct:event_entry	file:	access:public
event_entry::write_event	WIN32-Code/win32.c	/^	struct event *write_event;$/;"	m	struct:event_entry	typeref:struct:event_entry::event	file:	access:public
event_entry::write_pos	WIN32-Code/win32.c	/^	int write_pos;$/;"	m	struct:event_entry	file:	access:public
event_err	log.c	/^event_err(int eval, const char *fmt, ...)$/;"	f	signature:(int eval, const char *fmt, ...)
event_err	test/regress.gen.c	/^void event_err(int eval, const char *fmt, ...);$/;"	p	file:	signature:(int eval, const char *fmt, ...)
event_errx	log.c	/^event_errx(int eval, const char *fmt, ...)$/;"	f	signature:(int eval, const char *fmt, ...)
event_errx	test/regress.gen.c	/^void event_errx(int eval, const char *fmt, ...);$/;"	p	file:	signature:(int eval, const char *fmt, ...)
event_fds	select.c	/^	int event_fds;		\/* Highest fd in fd set *\/$/;"	m	struct:selectop	file:	access:public
event_fdsz	select.c	/^	int event_fdsz;$/;"	m	struct:selectop	file:	access:public
event_get_method	event.c	/^event_get_method(void)$/;"	f	signature:(void)
event_get_method	event.h	/^const char *event_get_method(void);$/;"	p	signature:(void)
event_get_version	event.c	/^event_get_version(void)$/;"	f	signature:(void)
event_get_version	event.h	/^const char *event_get_version(void);$/;"	p	signature:(void)
event_gotsig	event.c	/^volatile sig_atomic_t event_gotsig;	\/* Set in signal handler *\/$/;"	v
event_gotterm	event-internal.h	/^	int event_gotterm;		\/* Set to terminate loop *\/$/;"	m	struct:event_base	access:public
event_haveevents	event.c	/^event_haveevents(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_haveevents	event.c	/^static int	event_haveevents(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
event_init	event.c	/^event_init(void)$/;"	f	signature:(void)
event_init	event.h	/^struct event_base *event_init(void);$/;"	p	signature:(void)
event_initialized	event.h	651;"	d
event_initialized	event.h	653;"	d
event_log	log.c	/^event_log(int severity, const char *msg)$/;"	f	file:	signature:(int severity, const char *msg)
event_log	log.c	/^static void event_log(int severity, const char *msg);$/;"	p	file:	signature:(int severity, const char *msg)
event_log_cb	event.h	/^typedef void (*event_log_cb)(int severity, const char *msg);$/;"	t
event_loop	event.c	/^event_loop(int flags)$/;"	f	signature:(int flags)
event_loop	event.h	/^int event_loop(int);$/;"	p	signature:(int)
event_loopbreak	event.c	/^event_loopbreak(void)$/;"	f	signature:(void)
event_loopbreak	event.h	/^int event_loopbreak(void);$/;"	p	signature:(void)
event_loopexit	event.c	/^event_loopexit(const struct timeval *tv)$/;"	f	signature:(const struct timeval *tv)
event_loopexit	event.h	/^int event_loopexit(const struct timeval *);$/;"	p	signature:(const struct timeval *)
event_loopexit_cb	event.c	/^event_loopexit_cb(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
event_msgx	log.c	/^event_msgx(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
event_once	event.c	/^event_once(int fd, short events,$/;"	f	signature:(int fd, short events, void (*callback)(int, short, void *), void *arg, const struct timeval *tv)
event_once	event.c	/^struct event_once {$/;"	s	file:
event_once	event.h	/^int event_once(int, short, void (*)(int, short, void *), void *,$/;"	p	signature:(int, short, void (*)(int, short, void *), void *, const struct timeval *)
event_once::arg	event.c	/^	void *arg;$/;"	m	struct:event_once	file:	access:public
event_once::cb	event.c	/^	void (*cb)(int, short, void *);$/;"	m	struct:event_once	file:	access:public
event_once::ev	event.c	/^	struct event ev;$/;"	m	struct:event_once	typeref:struct:event_once::event	file:	access:public
event_once_cb	event.c	/^event_once_cb(int fd, short events, void *arg)$/;"	f	file:	signature:(int fd, short events, void *arg)
event_pending	event.c	/^event_pending(struct event *ev, short event, struct timeval *tv)$/;"	f	signature:(struct event *ev, short event, struct timeval *tv)
event_pending	event.h	/^int event_pending(struct event *ev, short event, struct timeval *tv);$/;"	p	signature:(struct event *ev, short event, struct timeval *tv)
event_priority_init	event.c	/^event_priority_init(int npriorities)$/;"	f	signature:(int npriorities)
event_priority_init	event.h	/^int	event_priority_init(int);$/;"	p	signature:(int)
event_priority_set	event.c	/^event_priority_set(struct event *ev, int pri)$/;"	f	signature:(struct event *ev, int pri)
event_priority_set	event.h	/^int	event_priority_set(struct event *, int);$/;"	p	signature:(struct event *, int)
event_process_active	event.c	/^event_process_active(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
event_process_active	event.c	/^static void	event_process_active(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
event_queue_insert	event.c	/^event_queue_insert(struct event_base *base, struct event *ev, int queue)$/;"	f	signature:(struct event_base *base, struct event *ev, int queue)
event_queue_insert	event.c	/^static void	event_queue_insert(struct event_base *, struct event *, int);$/;"	p	file:	signature:(struct event_base *, struct event *, int)
event_queue_remove	event.c	/^event_queue_remove(struct event_base *base, struct event *ev, int queue)$/;"	f	signature:(struct event_base *base, struct event *ev, int queue)
event_queue_remove	event.c	/^static void	event_queue_remove(struct event_base *, struct event *, int);$/;"	p	file:	signature:(struct event_base *, struct event *, int)
event_r_back	poll.c	/^	struct event **event_r_back;$/;"	m	struct:pollop	typeref:struct:pollop::event	file:	access:public
event_r_by_fd	select.c	/^	struct event **event_r_by_fd;$/;"	m	struct:selectop	typeref:struct:selectop::event	file:	access:public
event_readset_in	select.c	/^	fd_set *event_readset_in;$/;"	m	struct:selectop	file:	access:public
event_readset_out	select.c	/^	fd_set *event_readset_out;$/;"	m	struct:selectop	file:	access:public
event_reinit	event.c	/^event_reinit(struct event_base *base)$/;"	f	signature:(struct event_base *base)
event_reinit	event.h	/^int event_reinit(struct event_base *base);$/;"	p	signature:(struct event_base *base)
event_set	event.c	/^event_set(struct event *ev, int fd, short events,$/;"	f	signature:(struct event *ev, int fd, short events, void (*callback)(int, short, void *), void *arg)
event_set	event.h	/^void event_set(struct event *, int, short, void (*)(int, short, void *), void *);$/;"	p	signature:(struct event *, int, short, void (*)(int, short, void *), void *)
event_set	poll.c	/^	struct pollfd *event_set;$/;"	m	struct:pollop	typeref:struct:pollop::pollfd	file:	access:public
event_set_log_callback	event.h	/^void event_set_log_callback(event_log_cb cb);$/;"	p	signature:(event_log_cb cb)
event_set_log_callback	log.c	/^event_set_log_callback(event_log_cb cb)$/;"	f	signature:(event_log_cb cb)
event_sigcb	event.c	/^int (*event_sigcb)(void);		\/* Signal callback when gotsig is set *\/$/;"	v
event_test_DEPENDENCIES	sample/Makefile	/^event_test_DEPENDENCIES = ..\/libevent.la$/;"	m
event_test_LDADD	sample/Makefile	/^event_test_LDADD = $(LDADD)$/;"	m
event_test_OBJECTS	sample/Makefile	/^event_test_OBJECTS = event-test.$(OBJEXT)$/;"	m
event_test_SOURCES	sample/Makefile	/^event_test_SOURCES = event-test.c$/;"	m
event_test_sources	sample/Makefile	/^event_test_sources = event-test.c$/;"	m
event_tv	event-internal.h	/^	struct timeval event_tv;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
event_w_back	poll.c	/^	struct event **event_w_back;$/;"	m	struct:pollop	typeref:struct:pollop::event	file:	access:public
event_w_by_fd	select.c	/^	struct event **event_w_by_fd;$/;"	m	struct:selectop	typeref:struct:selectop::event	file:	access:public
event_warn	log.c	/^event_warn(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
event_warn	test/regress.gen.c	/^void event_warn(const char *fmt, ...);$/;"	p	file:	signature:(const char *fmt, ...)
event_warnx	log.c	/^event_warnx(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
event_warnx	test/regress.gen.c	/^void event_warnx(const char *fmt, ...);$/;"	p	file:	signature:(const char *fmt, ...)
event_watermark	event.h	/^struct event_watermark {$/;"	s
event_watermark::high	event.h	/^	size_t high;$/;"	m	struct:event_watermark	access:public
event_watermark::low	event.h	/^	size_t low;$/;"	m	struct:event_watermark	access:public
event_writeset_in	select.c	/^	fd_set *event_writeset_in;$/;"	m	struct:selectop	file:	access:public
event_writeset_out	select.c	/^	fd_set *event_writeset_out;$/;"	m	struct:selectop	file:	access:public
eventop	event-internal.h	/^struct eventop {$/;"	s
eventop::add	event-internal.h	/^	int (*add)(void *, struct event *);$/;"	m	struct:eventop	access:public
eventop::dealloc	event-internal.h	/^	void (*dealloc)(struct event_base *, void *);$/;"	m	struct:eventop	access:public
eventop::del	event-internal.h	/^	int (*del)(void *, struct event *);$/;"	m	struct:eventop	access:public
eventop::dispatch	event-internal.h	/^	int (*dispatch)(struct event_base *, void *, struct timeval *);$/;"	m	struct:eventop	access:public
eventop::init	event-internal.h	/^	void *(*init)(struct event_base *);$/;"	m	struct:eventop	access:public
eventop::name	event-internal.h	/^	const char *name;$/;"	m	struct:eventop	access:public
eventop::need_reinit	event-internal.h	/^	int need_reinit;$/;"	m	struct:eventop	access:public
eventops	event.c	/^static const struct eventop *eventops[] = {$/;"	v	typeref:struct:eventop	file:
eventqueue	event-internal.h	/^	struct event_list eventqueue;$/;"	m	struct:event_base	typeref:struct:event_base::event_list	access:public
events	devpoll.c	/^	struct pollfd *events;$/;"	m	struct:devpollop	typeref:struct:devpollop::pollfd	file:	access:public
events	epoll.c	/^	struct epoll_event *events;$/;"	m	struct:epollop	typeref:struct:epollop::epoll_event	file:	access:public
events	kqueue.c	/^	struct kevent *events;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:	access:public
events	test/bench.c	/^static struct event *events;$/;"	v	typeref:struct:event	file:
evepoll	epoll.c	/^struct evepoll {$/;"	s	file:
evepoll::evread	epoll.c	/^	struct event *evread;$/;"	m	struct:evepoll	typeref:struct:evepoll::event	file:	access:public
evepoll::evwrite	epoll.c	/^	struct event *evwrite;$/;"	m	struct:evepoll	typeref:struct:evepoll::event	file:	access:public
everrorcb	event.h	/^typedef void (*everrorcb)(struct bufferevent *, short what, void *);$/;"	t
evhttp	http-internal.h	/^struct evhttp {$/;"	s
evhttp::base	http-internal.h	/^	struct event_base *base;$/;"	m	struct:evhttp	typeref:struct:evhttp::event_base	access:public
evhttp::callbacks	http-internal.h	/^	TAILQ_HEAD(httpcbq, evhttp_cb) callbacks;$/;"	m	struct:evhttp	access:public
evhttp::connections	http-internal.h	/^        struct evconq connections;$/;"	m	struct:evhttp	typeref:struct:evhttp::evconq	access:public
evhttp::gencb	http-internal.h	/^	void (*gencb)(struct evhttp_request *req, void *);$/;"	m	struct:evhttp	access:public
evhttp::gencbarg	http-internal.h	/^	void *gencbarg;$/;"	m	struct:evhttp	access:public
evhttp::sockets	http-internal.h	/^	TAILQ_HEAD(boundq, evhttp_bound_socket) sockets;$/;"	m	struct:evhttp	access:public
evhttp::timeout	http-internal.h	/^        int timeout;$/;"	m	struct:evhttp	access:public
evhttp_accept_socket	evhttp.h	/^int evhttp_accept_socket(struct evhttp *http, int fd);$/;"	p	signature:(struct evhttp *http, int fd)
evhttp_accept_socket	http.c	/^evhttp_accept_socket(struct evhttp *http, int fd)$/;"	f	signature:(struct evhttp *http, int fd)
evhttp_add_event	http.c	/^evhttp_add_event(struct event *ev, int timeout, int default_timeout)$/;"	f	file:	signature:(struct event *ev, int timeout, int default_timeout)
evhttp_add_header	evhttp.h	/^int evhttp_add_header(struct evkeyvalq *, const char *, const char *);$/;"	p	signature:(struct evkeyvalq *, const char *, const char *)
evhttp_add_header	http.c	/^evhttp_add_header(struct evkeyvalq *headers,$/;"	f	signature:(struct evkeyvalq *headers, const char *key, const char *value)
evhttp_append_to_last_header	http.c	/^evhttp_append_to_last_header(struct evkeyvalq *headers, const char *line)$/;"	f	file:	signature:(struct evkeyvalq *headers, const char *line)
evhttp_associate_new_request_with_connection	http.c	/^evhttp_associate_new_request_with_connection(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_associate_new_request_with_connection	http.c	/^static int evhttp_associate_new_request_with_connection($/;"	p	file:	signature:( struct evhttp_connection *evcon)
evhttp_bind_socket	evhttp.h	/^int evhttp_bind_socket(struct evhttp *http, const char *address, u_short port);$/;"	p	signature:(struct evhttp *http, const char *address, u_short port)
evhttp_bind_socket	http.c	/^evhttp_bind_socket(struct evhttp *http, const char *address, u_short port)$/;"	f	signature:(struct evhttp *http, const char *address, u_short port)
evhttp_bound_socket	http-internal.h	/^	TAILQ_ENTRY(evhttp_bound_socket) (next);$/;"	p	struct:evhttp_bound_socket	access:public	signature:(next)
evhttp_bound_socket	http-internal.h	/^struct evhttp_bound_socket {$/;"	s
evhttp_bound_socket::bind_ev	http-internal.h	/^	struct event  bind_ev;$/;"	m	struct:evhttp_bound_socket	typeref:struct:evhttp_bound_socket::event	access:public
evhttp_bound_socket::evhttp_bound_socket	http-internal.h	/^	TAILQ_ENTRY(evhttp_bound_socket) (next);$/;"	p	struct:evhttp_bound_socket	access:public	signature:(next)
evhttp_cb	http-internal.h	/^struct evhttp_cb {$/;"	s
evhttp_cb::cb	http-internal.h	/^	void (*cb)(struct evhttp_request *req, void *);$/;"	m	struct:evhttp_cb	access:public
evhttp_cb::cbarg	http-internal.h	/^	void *cbarg;$/;"	m	struct:evhttp_cb	access:public
evhttp_cb::next	http-internal.h	/^	TAILQ_ENTRY(evhttp_cb) next;$/;"	m	struct:evhttp_cb	access:public
evhttp_cb::what	http-internal.h	/^	char *what;$/;"	m	struct:evhttp_cb	access:public
evhttp_clear_headers	evhttp.h	/^void evhttp_clear_headers(struct evkeyvalq *);$/;"	p	signature:(struct evkeyvalq *)
evhttp_clear_headers	http.c	/^evhttp_clear_headers(struct evkeyvalq *headers)$/;"	f	signature:(struct evkeyvalq *headers)
evhttp_cmd_type	evhttp.h	/^enum evhttp_cmd_type { EVHTTP_REQ_GET, EVHTTP_REQ_POST, EVHTTP_REQ_HEAD };$/;"	g
evhttp_connected	http.c	/^evhttp_connected(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_connection	http-internal.h	/^	TAILQ_ENTRY(evhttp_connection) (next);$/;"	p	struct:evhttp_connection	access:public	signature:(next)
evhttp_connection	http-internal.h	/^struct evhttp_connection {$/;"	s
evhttp_connection::address	http-internal.h	/^	char *address;			\/* address to connect to *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::base	http-internal.h	/^	struct event_base *base;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event_base	access:public
evhttp_connection::bind_address	http-internal.h	/^	char *bind_address;		\/* address to use for binding the src *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::bind_port	http-internal.h	/^	u_short bind_port;		\/* local port for binding the src *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::cb	http-internal.h	/^						   void (*cb)(struct evhttp_connection *, void *);$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::cb_arg	http-internal.h	/^	void *cb_arg;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::close_ev	http-internal.h	/^	struct event close_ev;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event	access:public
evhttp_connection::closecb	http-internal.h	/^	void (*closecb)(struct evhttp_connection *, void *);$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::closecb_arg	http-internal.h	/^	void *closecb_arg;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::ev	http-internal.h	/^	struct event ev;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::event	access:public
evhttp_connection::evhttp_connection	http-internal.h	/^	TAILQ_ENTRY(evhttp_connection) (next);$/;"	p	struct:evhttp_connection	access:public	signature:(next)
evhttp_connection::fd	http-internal.h	/^	int fd;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::flags	http-internal.h	/^	int flags;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::http_server	http-internal.h	/^	struct evhttp *http_server;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evhttp	access:public
evhttp_connection::input_buffer	http-internal.h	/^	struct evbuffer *input_buffer;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evbuffer	access:public
evhttp_connection::output_buffer	http-internal.h	/^	struct evbuffer *output_buffer;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evbuffer	access:public
evhttp_connection::port	http-internal.h	/^	u_short port;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::requests	http-internal.h	/^	TAILQ_HEAD(evcon_requestq, evhttp_request) requests;$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::retry_cnt	http-internal.h	/^	int retry_cnt;			\/* retry count *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::retry_max	http-internal.h	/^	int retry_max;			\/* maximum number of retries *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection::state	http-internal.h	/^	enum evhttp_connection_state state;$/;"	m	struct:evhttp_connection	typeref:enum:evhttp_connection::evhttp_connection_state	access:public
evhttp_connection::timeout	http-internal.h	/^	int timeout;			\/* timeout in seconds for events *\/$/;"	m	struct:evhttp_connection	access:public
evhttp_connection_connect	http-internal.h	/^int evhttp_connection_connect(struct evhttp_connection *);$/;"	p	signature:(struct evhttp_connection *)
evhttp_connection_connect	http.c	/^evhttp_connection_connect(struct evhttp_connection *evcon)$/;"	f	signature:(struct evhttp_connection *evcon)
evhttp_connection_done	http.c	/^evhttp_connection_done(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_connection_error	http-internal.h	/^enum evhttp_connection_error {$/;"	g
evhttp_connection_fail	http-internal.h	/^void evhttp_connection_fail(struct evhttp_connection *,$/;"	p	signature:(struct evhttp_connection *, enum evhttp_connection_error error)
evhttp_connection_fail	http.c	/^evhttp_connection_fail(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, enum evhttp_connection_error error)
evhttp_connection_free	evhttp.h	/^void evhttp_connection_free(struct evhttp_connection *evcon);$/;"	p	signature:(struct evhttp_connection *evcon)
evhttp_connection_free	http.c	/^evhttp_connection_free(struct evhttp_connection *evcon)$/;"	f	signature:(struct evhttp_connection *evcon)
evhttp_connection_get_peer	evhttp.h	/^void evhttp_connection_get_peer(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, char **address, u_short *port)
evhttp_connection_get_peer	http.c	/^evhttp_connection_get_peer(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, char **address, u_short *port)
evhttp_connection_incoming_fail	http.c	/^evhttp_connection_incoming_fail(struct evhttp_request *req,$/;"	f	file:	signature:(struct evhttp_request *req, enum evhttp_connection_error error)
evhttp_connection_new	evhttp.h	/^struct evhttp_connection *evhttp_connection_new($/;"	p	signature:( const char *address, unsigned short port)
evhttp_connection_new	http.c	/^evhttp_connection_new(const char *address, unsigned short port)$/;"	f	signature:(const char *address, unsigned short port)
evhttp_connection_reset	http-internal.h	/^void evhttp_connection_reset(struct evhttp_connection *);$/;"	p	signature:(struct evhttp_connection *)
evhttp_connection_reset	http.c	/^evhttp_connection_reset(struct evhttp_connection *evcon)$/;"	f	signature:(struct evhttp_connection *evcon)
evhttp_connection_retry	http.c	/^evhttp_connection_retry(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
evhttp_connection_set_base	evhttp.h	/^void evhttp_connection_set_base(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, struct event_base *base)
evhttp_connection_set_base	http.c	/^void evhttp_connection_set_base(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, struct event_base *base)
evhttp_connection_set_closecb	evhttp.h	/^void evhttp_connection_set_closecb(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, void (*)(struct evhttp_connection *, void *), void *)
evhttp_connection_set_closecb	http.c	/^evhttp_connection_set_closecb(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, void (*cb)(struct evhttp_connection *, void *), void *cbarg)
evhttp_connection_set_local_address	evhttp.h	/^void evhttp_connection_set_local_address(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, const char *address)
evhttp_connection_set_local_address	http.c	/^evhttp_connection_set_local_address(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, const char *address)
evhttp_connection_set_local_port	evhttp.h	/^void evhttp_connection_set_local_port(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, unsigned short port)
evhttp_connection_set_local_port	http.c	/^evhttp_connection_set_local_port(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, unsigned short port)
evhttp_connection_set_retries	evhttp.h	/^void evhttp_connection_set_retries(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, int retry_max)
evhttp_connection_set_retries	http.c	/^evhttp_connection_set_retries(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, int retry_max)
evhttp_connection_set_timeout	evhttp.h	/^void evhttp_connection_set_timeout(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, int timeout_in_secs)
evhttp_connection_set_timeout	http.c	/^evhttp_connection_set_timeout(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, int timeout_in_secs)
evhttp_connection_start_detectclose	http.c	/^evhttp_connection_start_detectclose(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_connection_start_detectclose	http.c	/^static void evhttp_connection_start_detectclose($/;"	p	file:	signature:( struct evhttp_connection *evcon)
evhttp_connection_state	http-internal.h	/^enum evhttp_connection_state {$/;"	g
evhttp_connection_stop_detectclose	http.c	/^evhttp_connection_stop_detectclose(struct evhttp_connection *evcon)$/;"	f	file:	signature:(struct evhttp_connection *evcon)
evhttp_connection_stop_detectclose	http.c	/^static void evhttp_connection_stop_detectclose($/;"	p	file:	signature:( struct evhttp_connection *evcon)
evhttp_connectioncb	http.c	/^evhttp_connectioncb(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
evhttp_decode_uri	evhttp.h	/^char *evhttp_decode_uri(const char *uri);$/;"	p	signature:(const char *uri)
evhttp_decode_uri	http.c	/^evhttp_decode_uri(const char *uri)$/;"	f	signature:(const char *uri)
evhttp_del_cb	evhttp.h	/^int evhttp_del_cb(struct evhttp *, const char *);$/;"	p	signature:(struct evhttp *, const char *)
evhttp_del_cb	http.c	/^evhttp_del_cb(struct evhttp *http, const char *uri)$/;"	f	signature:(struct evhttp *http, const char *uri)
evhttp_detect_close_cb	http.c	/^evhttp_detect_close_cb(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
evhttp_dispatch_callback	http.c	/^evhttp_dispatch_callback(struct httpcbq *callbacks, struct evhttp_request *req)$/;"	f	file:	signature:(struct httpcbq *callbacks, struct evhttp_request *req)
evhttp_encode_uri	evhttp.h	/^char *evhttp_encode_uri(const char *uri);$/;"	p	signature:(const char *uri)
evhttp_encode_uri	http.c	/^evhttp_encode_uri(const char *uri)$/;"	f	signature:(const char *uri)
evhttp_find_header	evhttp.h	/^const char *evhttp_find_header(const struct evkeyvalq *, const char *);$/;"	p	signature:(const struct evkeyvalq *, const char *)
evhttp_find_header	http.c	/^evhttp_find_header(const struct evkeyvalq *headers, const char *key)$/;"	f	signature:(const struct evkeyvalq *headers, const char *key)
evhttp_free	evhttp.h	/^void evhttp_free(struct evhttp* http);$/;"	p	signature:(struct evhttp* http)
evhttp_free	http.c	/^evhttp_free(struct evhttp* http)$/;"	f	signature:(struct evhttp* http)
evhttp_get_body	http.c	/^evhttp_get_body(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_get_body_length	http.c	/^evhttp_get_body_length(struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_request *req)
evhttp_get_request	http-internal.h	/^void evhttp_get_request(struct evhttp *, int, struct sockaddr *, socklen_t);$/;"	p	signature:(struct evhttp *, int, struct sockaddr *, socklen_t)
evhttp_get_request	http.c	/^evhttp_get_request(struct evhttp *http, int fd,$/;"	f	signature:(struct evhttp *http, int fd, struct sockaddr *sa, socklen_t salen)
evhttp_get_request_connection	http.c	/^evhttp_get_request_connection($/;"	f	file:	signature:( struct evhttp* http, int fd, struct sockaddr *sa, socklen_t salen)
evhttp_handle_chunked_read	http.c	/^evhttp_handle_chunked_read(struct evhttp_request *req, struct evbuffer *buf)$/;"	f	file:	signature:(struct evhttp_request *req, struct evbuffer *buf)
evhttp_handle_request	http.c	/^evhttp_handle_request(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
evhttp_hostportfile	http-internal.h	/^int evhttp_hostportfile(char *, char **, u_short *, char **);$/;"	p	signature:(char *, char **, u_short *, char **)
evhttp_hostportfile	http.c	/^evhttp_hostportfile(char *url, char **phost, u_short *pport, char **pfile)$/;"	f	signature:(char *url, char **phost, u_short *pport, char **pfile)
evhttp_htmlescape	evhttp.h	/^char *evhttp_htmlescape(const char *html);$/;"	p	signature:(const char *html)
evhttp_htmlescape	http.c	/^evhttp_htmlescape(const char *html)$/;"	f	signature:(const char *html)
evhttp_is_connection_close	http.c	/^evhttp_is_connection_close(int flags, struct evkeyvalq* headers)$/;"	f	file:	signature:(int flags, struct evkeyvalq* headers)
evhttp_is_connection_keepalive	http.c	/^evhttp_is_connection_keepalive(struct evkeyvalq* headers)$/;"	f	file:	signature:(struct evkeyvalq* headers)
evhttp_make_header	http-internal.h	/^void evhttp_make_header(struct evhttp_connection *, struct evhttp_request *);$/;"	p	signature:(struct evhttp_connection *, struct evhttp_request *)
evhttp_make_header	http.c	/^evhttp_make_header(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_make_header_request	http.c	/^evhttp_make_header_request(struct evhttp_connection *evcon,$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_make_header_response	http.c	/^evhttp_make_header_response(struct evhttp_connection *evcon,$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_make_request	evhttp.h	/^int evhttp_make_request(struct evhttp_connection *evcon,$/;"	p	signature:(struct evhttp_connection *evcon, struct evhttp_request *req, enum evhttp_cmd_type type, const char *uri)
evhttp_make_request	http.c	/^evhttp_make_request(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, struct evhttp_request *req, enum evhttp_cmd_type type, const char *uri)
evhttp_maybe_add_content_length_header	http.c	/^evhttp_maybe_add_content_length_header(struct evkeyvalq *headers,$/;"	f	file:	signature:(struct evkeyvalq *headers, long content_length)
evhttp_maybe_add_date_header	http.c	/^evhttp_maybe_add_date_header(struct evkeyvalq *headers)$/;"	f	file:	signature:(struct evkeyvalq *headers)
evhttp_method	http.c	/^evhttp_method(enum evhttp_cmd_type type)$/;"	f	file:	signature:(enum evhttp_cmd_type type)
evhttp_new	evhttp.h	/^struct evhttp *evhttp_new(struct event_base *base);$/;"	p	signature:(struct event_base *base)
evhttp_new	http.c	/^evhttp_new(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evhttp_new_object	http.c	/^evhttp_new_object(void)$/;"	f	file:	signature:(void)
evhttp_parse_firstline	http-internal.h	/^int evhttp_parse_firstline(struct evhttp_request *, struct evbuffer*);$/;"	p	signature:(struct evhttp_request *, struct evbuffer*)
evhttp_parse_firstline	http.c	/^evhttp_parse_firstline(struct evhttp_request *req, struct evbuffer *buffer)$/;"	f	signature:(struct evhttp_request *req, struct evbuffer *buffer)
evhttp_parse_headers	http-internal.h	/^int evhttp_parse_headers(struct evhttp_request *, struct evbuffer*);$/;"	p	signature:(struct evhttp_request *, struct evbuffer*)
evhttp_parse_headers	http.c	/^evhttp_parse_headers(struct evhttp_request *req, struct evbuffer* buffer)$/;"	f	signature:(struct evhttp_request *req, struct evbuffer* buffer)
evhttp_parse_query	evhttp.h	/^void evhttp_parse_query(const char *uri, struct evkeyvalq *);$/;"	p	signature:(const char *uri, struct evkeyvalq *)
evhttp_parse_query	http.c	/^evhttp_parse_query(const char *uri, struct evkeyvalq *headers)$/;"	f	signature:(const char *uri, struct evkeyvalq *headers)
evhttp_parse_request_line	http.c	/^evhttp_parse_request_line(struct evhttp_request *req, char *line)$/;"	f	file:	signature:(struct evhttp_request *req, char *line)
evhttp_parse_response_line	http.c	/^evhttp_parse_response_line(struct evhttp_request *req, char *line)$/;"	f	file:	signature:(struct evhttp_request *req, char *line)
evhttp_read	http.c	/^evhttp_read(int fd, short what, void *arg)$/;"	f	signature:(int fd, short what, void *arg)
evhttp_read	http.c	/^void evhttp_read(int, short, void *);$/;"	p	file:	signature:(int, short, void *)
evhttp_read_body	http.c	/^evhttp_read_body(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_firstline	http.c	/^evhttp_read_firstline(struct evhttp_connection *evcon,$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_firstline	http.c	/^static void evhttp_read_firstline(struct evhttp_connection *evcon,$/;"	p	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_header	http.c	/^evhttp_read_header(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_header	http.c	/^static void evhttp_read_header(struct evhttp_connection *evcon,$/;"	p	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_read_trailer	http.c	/^evhttp_read_trailer(struct evhttp_connection *evcon, struct evhttp_request *req)$/;"	f	file:	signature:(struct evhttp_connection *evcon, struct evhttp_request *req)
evhttp_remove_header	evhttp.h	/^int evhttp_remove_header(struct evkeyvalq *, const char *);$/;"	p	signature:(struct evkeyvalq *, const char *)
evhttp_remove_header	http.c	/^evhttp_remove_header(struct evkeyvalq *headers, const char *key)$/;"	f	signature:(struct evkeyvalq *headers, const char *key)
evhttp_request	evhttp.h	/^struct evhttp_request {$/;"	s
evhttp_request::cb	evhttp.h	/^	void (*cb)(struct evhttp_request *, void *);$/;"	m	struct:evhttp_request	access:public
evhttp_request::cb_arg	evhttp.h	/^	void *cb_arg;$/;"	m	struct:evhttp_request	access:public
evhttp_request::chunk_cb	evhttp.h	/^	void (*chunk_cb)(struct evhttp_request *, void *);$/;"	m	struct:evhttp_request	access:public
evhttp_request::chunked	evhttp.h	/^	int chunked;$/;"	m	struct:evhttp_request	access:public
evhttp_request::evcon	evhttp.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evhttp_connection	access:public
evhttp_request::flags	evhttp.h	/^	int flags;$/;"	m	struct:evhttp_request	access:public
evhttp_request::input_buffer	evhttp.h	/^	struct evbuffer *input_buffer;	\/* read data *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evbuffer	access:public
evhttp_request::input_headers	evhttp.h	/^	struct evkeyvalq *input_headers;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evkeyvalq	access:public
evhttp_request::kind	evhttp.h	/^	enum evhttp_request_kind kind;$/;"	m	struct:evhttp_request	typeref:enum:evhttp_request::evhttp_request_kind	access:public
evhttp_request::major	evhttp.h	/^	char major;			\/* HTTP Major number *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::minor	evhttp.h	/^	char minor;			\/* HTTP Minor number *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::next	evhttp.h	/^	TAILQ_ENTRY(evhttp_request) next;$/;"	m	struct:evhttp_request	access:public
evhttp_request::ntoread	evhttp.h	/^	ev_int64_t ntoread;$/;"	m	struct:evhttp_request	access:public
evhttp_request::output_buffer	evhttp.h	/^	struct evbuffer *output_buffer;	\/* outgoing post or data *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evbuffer	access:public
evhttp_request::output_headers	evhttp.h	/^	struct evkeyvalq *output_headers;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evkeyvalq	access:public
evhttp_request::remote_host	evhttp.h	/^	char *remote_host;$/;"	m	struct:evhttp_request	access:public
evhttp_request::remote_port	evhttp.h	/^	u_short remote_port;$/;"	m	struct:evhttp_request	access:public
evhttp_request::response_code	evhttp.h	/^	int response_code;		\/* HTTP Response code *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::response_code_line	evhttp.h	/^	char *response_code_line;	\/* Readable response *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request::type	evhttp.h	/^	enum evhttp_cmd_type type;$/;"	m	struct:evhttp_request	typeref:enum:evhttp_request::evhttp_cmd_type	access:public
evhttp_request::uri	evhttp.h	/^	char *uri;			\/* uri after HTTP request was parsed *\/$/;"	m	struct:evhttp_request	access:public
evhttp_request_dispatch	http.c	/^evhttp_request_dispatch(struct evhttp_connection* evcon)$/;"	f	file:	signature:(struct evhttp_connection* evcon)
evhttp_request_dispatch	http.c	/^static void evhttp_request_dispatch(struct evhttp_connection* evcon);$/;"	p	file:	signature:(struct evhttp_connection* evcon)
evhttp_request_free	evhttp.h	/^void evhttp_request_free(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_free	http.c	/^evhttp_request_free(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_request_kind	evhttp.h	/^enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };$/;"	g
evhttp_request_new	evhttp.h	/^struct evhttp_request *evhttp_request_new($/;"	p	signature:( void (*cb)(struct evhttp_request *, void *), void *arg)
evhttp_request_new	http.c	/^evhttp_request_new(void (*cb)(struct evhttp_request *, void *), void *arg)$/;"	f	signature:(void (*cb)(struct evhttp_request *, void *), void *arg)
evhttp_request_set_chunked_cb	evhttp.h	/^void evhttp_request_set_chunked_cb(struct evhttp_request *,$/;"	p	signature:(struct evhttp_request *, void (*cb)(struct evhttp_request *, void *))
evhttp_request_set_chunked_cb	http.c	/^evhttp_request_set_chunked_cb(struct evhttp_request *req,$/;"	f	signature:(struct evhttp_request *req, void (*cb)(struct evhttp_request *, void *))
evhttp_request_uri	evhttp.h	/^const char *evhttp_request_uri(struct evhttp_request *req);$/;"	p	signature:(struct evhttp_request *req)
evhttp_request_uri	http.c	/^evhttp_request_uri(struct evhttp_request *req) {$/;"	f	signature:(struct evhttp_request *req)
evhttp_response_code	http-internal.h	/^void evhttp_response_code(struct evhttp_request *, int, const char *);$/;"	p	signature:(struct evhttp_request *, int, const char *)
evhttp_response_code	http.c	/^evhttp_response_code(struct evhttp_request *req, int code, const char *reason)$/;"	f	signature:(struct evhttp_request *req, int code, const char *reason)
evhttp_send	http.c	/^evhttp_send(struct evhttp_request *req, struct evbuffer *databuf)$/;"	f	file:	signature:(struct evhttp_request *req, struct evbuffer *databuf)
evhttp_send_done	http.c	/^evhttp_send_done(struct evhttp_connection *evcon, void *arg)$/;"	f	file:	signature:(struct evhttp_connection *evcon, void *arg)
evhttp_send_error	evhttp.h	/^void evhttp_send_error(struct evhttp_request *req, int error,$/;"	p	signature:(struct evhttp_request *req, int error, const char *reason)
evhttp_send_error	http.c	/^evhttp_send_error(struct evhttp_request *req, int error, const char *reason)$/;"	f	signature:(struct evhttp_request *req, int error, const char *reason)
evhttp_send_page	http-internal.h	/^void evhttp_send_page(struct evhttp_request *, struct evbuffer *);$/;"	p	signature:(struct evhttp_request *, struct evbuffer *)
evhttp_send_page	http.c	/^evhttp_send_page(struct evhttp_request *req, struct evbuffer *databuf)$/;"	f	signature:(struct evhttp_request *req, struct evbuffer *databuf)
evhttp_send_reply	evhttp.h	/^void evhttp_send_reply(struct evhttp_request *req, int code,$/;"	p	signature:(struct evhttp_request *req, int code, const char *reason, struct evbuffer *databuf)
evhttp_send_reply	http.c	/^evhttp_send_reply(struct evhttp_request *req, int code, const char *reason,$/;"	f	signature:(struct evhttp_request *req, int code, const char *reason, struct evbuffer *databuf)
evhttp_send_reply_chunk	evhttp.h	/^void evhttp_send_reply_chunk(struct evhttp_request *, struct evbuffer *);$/;"	p	signature:(struct evhttp_request *, struct evbuffer *)
evhttp_send_reply_chunk	http.c	/^evhttp_send_reply_chunk(struct evhttp_request *req, struct evbuffer *databuf)$/;"	f	signature:(struct evhttp_request *req, struct evbuffer *databuf)
evhttp_send_reply_end	evhttp.h	/^void evhttp_send_reply_end(struct evhttp_request *);$/;"	p	signature:(struct evhttp_request *)
evhttp_send_reply_end	http.c	/^evhttp_send_reply_end(struct evhttp_request *req)$/;"	f	signature:(struct evhttp_request *req)
evhttp_send_reply_start	evhttp.h	/^void evhttp_send_reply_start(struct evhttp_request *, int, const char *);$/;"	p	signature:(struct evhttp_request *, int, const char *)
evhttp_send_reply_start	http.c	/^evhttp_send_reply_start(struct evhttp_request *req, int code,$/;"	f	signature:(struct evhttp_request *req, int code, const char *reason)
evhttp_set_cb	evhttp.h	/^void evhttp_set_cb(struct evhttp *, const char *,$/;"	p	signature:(struct evhttp *, const char *, void (*)(struct evhttp_request *, void *), void *)
evhttp_set_cb	http.c	/^evhttp_set_cb(struct evhttp *http, const char *uri,$/;"	f	signature:(struct evhttp *http, const char *uri, void (*cb)(struct evhttp_request *, void *), void *cbarg)
evhttp_set_gencb	evhttp.h	/^void evhttp_set_gencb(struct evhttp *,$/;"	p	signature:(struct evhttp *, void (*)(struct evhttp_request *, void *), void *)
evhttp_set_gencb	http.c	/^evhttp_set_gencb(struct evhttp *http,$/;"	f	signature:(struct evhttp *http, void (*cb)(struct evhttp_request *, void *), void *cbarg)
evhttp_set_timeout	evhttp.h	/^void evhttp_set_timeout(struct evhttp *, int timeout_in_secs);$/;"	p	signature:(struct evhttp *, int timeout_in_secs)
evhttp_set_timeout	http.c	/^evhttp_set_timeout(struct evhttp* http, int timeout_in_secs)$/;"	f	signature:(struct evhttp* http, int timeout_in_secs)
evhttp_start	evhttp.h	/^struct evhttp *evhttp_start(const char *address, u_short port);$/;"	p	signature:(const char *address, u_short port)
evhttp_start	http.c	/^evhttp_start(const char *address, u_short port)$/;"	f	signature:(const char *address, u_short port)
evhttp_start_read	http-internal.h	/^void evhttp_start_read(struct evhttp_connection *);$/;"	p	signature:(struct evhttp_connection *)
evhttp_start_read	http.c	/^evhttp_start_read(struct evhttp_connection *evcon)$/;"	f	signature:(struct evhttp_connection *evcon)
evhttp_valid_response_code	http.c	/^evhttp_valid_response_code(int code)$/;"	f	file:	signature:(int code)
evhttp_write	http.c	/^evhttp_write(int fd, short what, void *arg)$/;"	f	signature:(int fd, short what, void *arg)
evhttp_write	http.c	/^void evhttp_write(int, short, void *);$/;"	p	file:	signature:(int, short, void *)
evhttp_write_buffer	http-internal.h	/^void evhttp_write_buffer(struct evhttp_connection *,$/;"	p	signature:(struct evhttp_connection *, void (*)(struct evhttp_connection *, void *), void *)
evhttp_write_buffer	http.c	/^evhttp_write_buffer(struct evhttp_connection *evcon,$/;"	f	signature:(struct evhttp_connection *evcon, void (*cb)(struct evhttp_connection *, void *), void *arg)
evhttp_write_connectioncb	http.c	/^evhttp_write_connectioncb(struct evhttp_connection *evcon, void *arg)$/;"	f	file:	signature:(struct evhttp_connection *evcon, void *arg)
evkeyval	event.h	/^struct evkeyval {$/;"	s
evkeyval::key	event.h	/^	char *key;$/;"	m	struct:evkeyval	access:public
evkeyval::next	event.h	/^	TAILQ_ENTRY(evkeyval) next;$/;"	m	struct:evkeyval	access:public
evkeyval::value	event.h	/^	char *value;$/;"	m	struct:evkeyval	access:public
evport_add	evport.c	/^evport_add(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
evport_add	evport.c	/^static int 	evport_add	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
evport_data	evport.c	/^struct evport_data {$/;"	s	file:
evport_data::ed_fds	evport.c	/^	struct fd_info *ed_fds;		\/* allocated fdi table 		 *\/$/;"	m	struct:evport_data	typeref:struct:evport_data::fd_info	file:	access:public
evport_data::ed_nevents	evport.c	/^	int		ed_nevents;	\/* number of allocated fdi's 	 *\/$/;"	m	struct:evport_data	file:	access:public
evport_data::ed_pending	evport.c	/^	int ed_pending[EVENTS_PER_GETN]; \/* fd's with pending events *\/$/;"	m	struct:evport_data	file:	access:public
evport_data::ed_port	evport.c	/^	int 		ed_port;	\/* event port for system events  *\/$/;"	m	struct:evport_data	file:	access:public
evport_dealloc	evport.c	/^evport_dealloc(struct event_base *base, void *arg)$/;"	f	file:	signature:(struct event_base *base, void *arg)
evport_dealloc	evport.c	/^static void	evport_dealloc	(struct event_base *, void *);$/;"	p	file:	signature:(struct event_base *, void *)
evport_del	evport.c	/^evport_del(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
evport_del	evport.c	/^static int 	evport_del	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
evport_dispatch	evport.c	/^evport_dispatch(struct event_base *base, void *arg, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, void *arg, struct timeval *tv)
evport_dispatch	evport.c	/^static int 	evport_dispatch	(struct event_base *, void *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, void *, struct timeval *)
evport_init	evport.c	/^evport_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
evport_init	evport.c	/^static void*	evport_init	(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
evportops	evport.c	/^const struct eventop evportops = {$/;"	v	typeref:struct:eventop
evread	devpoll.c	/^	struct event *evread;$/;"	m	struct:evdevpoll	typeref:struct:evdevpoll::event	file:	access:public
evread	epoll.c	/^	struct event *evread;$/;"	m	struct:evepoll	typeref:struct:evepoll::event	file:	access:public
evrpc	evrpc.h	/^struct evrpc {$/;"	s
evrpc::base	evrpc.h	/^	struct evrpc_base *base;$/;"	m	struct:evrpc	typeref:struct:evrpc::evrpc_base	access:public
evrpc::cb	evrpc.h	/^	void (*cb)(struct evrpc_req_generic *, void *);$/;"	m	struct:evrpc	access:public
evrpc::cb_arg	evrpc.h	/^	void *cb_arg;$/;"	m	struct:evrpc	access:public
evrpc::next	evrpc.h	/^	TAILQ_ENTRY(evrpc) next;$/;"	m	struct:evrpc	access:public
evrpc::reply_complete	evrpc.h	/^	int (*reply_complete)(void *);$/;"	m	struct:evrpc	access:public
evrpc::reply_free	evrpc.h	/^	void (*reply_free)(void *);$/;"	m	struct:evrpc	access:public
evrpc::reply_marshal	evrpc.h	/^	void (*reply_marshal)(struct evbuffer*, void *);$/;"	m	struct:evrpc	access:public
evrpc::reply_new	evrpc.h	/^	void *(*reply_new)(void);$/;"	m	struct:evrpc	access:public
evrpc::request_free	evrpc.h	/^	void (*request_free)(void *);$/;"	m	struct:evrpc	access:public
evrpc::request_new	evrpc.h	/^	void *(*request_new)(void);$/;"	m	struct:evrpc	access:public
evrpc::request_unmarshal	evrpc.h	/^	int (*request_unmarshal)(void *, struct evbuffer *);$/;"	m	struct:evrpc	access:public
evrpc::uri	evrpc.h	/^	const char* uri;$/;"	m	struct:evrpc	access:public
evrpc_add_hook	evrpc.c	/^evrpc_add_hook(void *vbase,$/;"	f	signature:(void *vbase, enum EVRPC_HOOK_TYPE hook_type, int (*cb)(struct evhttp_request *, struct evbuffer *, void *), void *cb_arg)
evrpc_add_hook	evrpc.h	/^void *evrpc_add_hook(void *vbase,$/;"	p	signature:(void *vbase, enum EVRPC_HOOK_TYPE hook_type, int (*cb)(struct evhttp_request *, struct evbuffer *, void *), void *cb_arg)
evrpc_base	evrpc-internal.h	/^struct evrpc_base {$/;"	s
evrpc_base::common	evrpc-internal.h	/^	struct _evrpc_hooks common;$/;"	m	struct:evrpc_base	typeref:struct:evrpc_base::_evrpc_hooks	access:public
evrpc_base::http_server	evrpc-internal.h	/^	struct evhttp* http_server;$/;"	m	struct:evrpc_base	typeref:struct:evrpc_base::evhttp	access:public
evrpc_base::registered_rpcs	evrpc-internal.h	/^	TAILQ_HEAD(evrpc_list, evrpc) registered_rpcs;$/;"	m	struct:evrpc_base	access:public
evrpc_construct_uri	evrpc.c	/^evrpc_construct_uri(const char *uri)$/;"	f	file:	signature:(const char *uri)
evrpc_free	evrpc.c	/^evrpc_free(struct evrpc_base *base)$/;"	f	signature:(struct evrpc_base *base)
evrpc_free	evrpc.h	/^void evrpc_free(struct evrpc_base *base);$/;"	p	signature:(struct evrpc_base *base)
evrpc_hook	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_hook) (next);$/;"	p	struct:evrpc_hook	access:public	signature:(next)
evrpc_hook	evrpc-internal.h	/^struct evrpc_hook {$/;"	s
evrpc_hook::evrpc_hook	evrpc-internal.h	/^	TAILQ_ENTRY(evrpc_hook) (next);$/;"	p	struct:evrpc_hook	access:public	signature:(next)
evrpc_hook::process	evrpc-internal.h	/^	int (*process)(struct evhttp_request *, struct evbuffer *, void *);$/;"	m	struct:evrpc_hook	access:public
evrpc_hook::process_arg	evrpc-internal.h	/^	void *process_arg;$/;"	m	struct:evrpc_hook	access:public
evrpc_init	evrpc.c	/^evrpc_init(struct evhttp *http_server)$/;"	f	signature:(struct evhttp *http_server)
evrpc_init	evrpc.h	/^struct evrpc_base *evrpc_init(struct evhttp *server);$/;"	p	signature:(struct evhttp *server)
evrpc_make_request	evrpc.c	/^evrpc_make_request(struct evrpc_request_wrapper *ctx)$/;"	f	signature:(struct evrpc_request_wrapper *ctx)
evrpc_make_request	evrpc.h	/^int evrpc_make_request(struct evrpc_request_wrapper *);$/;"	p	signature:(struct evrpc_request_wrapper *)
evrpc_pool	evrpc-internal.h	/^struct evrpc_pool {$/;"	s
evrpc_pool::base	evrpc-internal.h	/^	struct event_base *base;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::event_base	access:public
evrpc_pool::common	evrpc-internal.h	/^	struct _evrpc_hooks common;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::_evrpc_hooks	access:public
evrpc_pool::connections	evrpc-internal.h	/^	struct evconq connections;$/;"	m	struct:evrpc_pool	typeref:struct:evrpc_pool::evconq	access:public
evrpc_pool::requests	evrpc-internal.h	/^	TAILQ_HEAD(evrpc_requestq, evrpc_request_wrapper) requests;$/;"	m	struct:evrpc_pool	access:public
evrpc_pool::timeout	evrpc-internal.h	/^	int timeout;$/;"	m	struct:evrpc_pool	access:public
evrpc_pool_add_connection	evrpc.c	/^evrpc_pool_add_connection(struct evrpc_pool *pool,$/;"	f	signature:(struct evrpc_pool *pool, struct evhttp_connection *connection)
evrpc_pool_add_connection	evrpc.h	/^void evrpc_pool_add_connection(struct evrpc_pool *, $/;"	p	signature:(struct evrpc_pool *, struct evhttp_connection *)
evrpc_pool_find_connection	evrpc.c	/^evrpc_pool_find_connection(struct evrpc_pool *pool)$/;"	f	file:	signature:(struct evrpc_pool *pool)
evrpc_pool_free	evrpc.c	/^evrpc_pool_free(struct evrpc_pool *pool)$/;"	f	signature:(struct evrpc_pool *pool)
evrpc_pool_free	evrpc.h	/^void evrpc_pool_free(struct evrpc_pool *pool);$/;"	p	signature:(struct evrpc_pool *pool)
evrpc_pool_new	evrpc.c	/^evrpc_pool_new(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evrpc_pool_new	evrpc.h	/^struct evrpc_pool *evrpc_pool_new(struct event_base *base);$/;"	p	signature:(struct event_base *base)
evrpc_pool_schedule	evrpc.c	/^evrpc_pool_schedule(struct evrpc_pool *pool)$/;"	f	file:	signature:(struct evrpc_pool *pool)
evrpc_pool_schedule	evrpc.c	/^static void evrpc_pool_schedule(struct evrpc_pool *pool);$/;"	p	file:	signature:(struct evrpc_pool *pool)
evrpc_pool_set_timeout	evrpc.c	/^evrpc_pool_set_timeout(struct evrpc_pool *pool, int timeout_in_secs)$/;"	f	signature:(struct evrpc_pool *pool, int timeout_in_secs)
evrpc_pool_set_timeout	evrpc.h	/^void evrpc_pool_set_timeout(struct evrpc_pool *pool, int timeout_in_secs);$/;"	p	signature:(struct evrpc_pool *pool, int timeout_in_secs)
evrpc_process_hooks	evrpc.c	/^evrpc_process_hooks(struct evrpc_hook_list *head,$/;"	f	file:	signature:(struct evrpc_hook_list *head, struct evhttp_request *req, struct evbuffer *evbuf)
evrpc_register_rpc	evrpc.c	/^evrpc_register_rpc(struct evrpc_base *base, struct evrpc *rpc,$/;"	f	signature:(struct evrpc_base *base, struct evrpc *rpc, void (*cb)(struct evrpc_req_generic *, void *), void *cb_arg)
evrpc_register_rpc	evrpc.h	/^int evrpc_register_rpc(struct evrpc_base *, struct evrpc *,$/;"	p	signature:(struct evrpc_base *, struct evrpc *, void (*)(struct evrpc_req_generic*, void *), void *)
evrpc_remove_hook	evrpc.c	/^evrpc_remove_hook(void *vbase, enum EVRPC_HOOK_TYPE hook_type, void *handle)$/;"	f	signature:(void *vbase, enum EVRPC_HOOK_TYPE hook_type, void *handle)
evrpc_remove_hook	evrpc.h	/^int evrpc_remove_hook(void *vbase,$/;"	p	signature:(void *vbase, enum EVRPC_HOOK_TYPE hook_type, void *handle)
evrpc_remove_hook_internal	evrpc.c	/^evrpc_remove_hook_internal(struct evrpc_hook_list *head, void *handle)$/;"	f	file:	signature:(struct evrpc_hook_list *head, void *handle)
evrpc_reply_done	evrpc.c	/^evrpc_reply_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
evrpc_reply_done	evrpc.c	/^static void evrpc_reply_done(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
evrpc_req_generic	evrpc.h	/^struct evrpc_req_generic {$/;"	s
evrpc_req_generic::done	evrpc.h	/^	void (*done)(struct evrpc_req_generic* rpc); $/;"	m	struct:evrpc_req_generic	access:public
evrpc_req_generic::http_req	evrpc.h	/^	struct evhttp_request* http_req;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evhttp_request	access:public
evrpc_req_generic::reply	evrpc.h	/^	void *reply;$/;"	m	struct:evrpc_req_generic	access:public
evrpc_req_generic::request	evrpc.h	/^	void *request;$/;"	m	struct:evrpc_req_generic	access:public
evrpc_req_generic::rpc	evrpc.h	/^	struct evrpc *rpc;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evrpc	access:public
evrpc_reqstate_free	evrpc-internal.h	/^void evrpc_reqstate_free(struct evrpc_req_generic* rpc_state);$/;"	p	signature:(struct evrpc_req_generic* rpc_state)
evrpc_reqstate_free	evrpc.c	/^evrpc_reqstate_free(struct evrpc_req_generic* rpc_state)$/;"	f	signature:(struct evrpc_req_generic* rpc_state)
evrpc_request_cb	evrpc.c	/^evrpc_request_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
evrpc_request_cb	evrpc.c	/^static void evrpc_request_cb(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
evrpc_request_done	evrpc.c	/^evrpc_request_done(struct evrpc_req_generic* rpc_state)$/;"	f	signature:(struct evrpc_req_generic* rpc_state)
evrpc_request_done	evrpc.c	/^void evrpc_request_done(struct evrpc_req_generic*);$/;"	p	file:	signature:(struct evrpc_req_generic*)
evrpc_request_timeout	evrpc.c	/^evrpc_request_timeout(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
evrpc_request_timeout	evrpc.c	/^static void evrpc_request_timeout(int, short, void *);$/;"	p	file:	signature:(int, short, void *)
evrpc_request_wrapper	evrpc.h	/^struct evrpc_request_wrapper {$/;"	s
evrpc_request_wrapper::cb	evrpc.h	/^	void (*cb)(struct evrpc_status*, void *request, void *reply, void *arg);$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::cb_arg	evrpc.h	/^	void *cb_arg;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::ev_timeout	evrpc.h	/^	struct event ev_timeout;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::event	access:public
evrpc_request_wrapper::evcon	evrpc.h	/^	struct evhttp_connection *evcon;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evhttp_connection	access:public
evrpc_request_wrapper::name	evrpc.h	/^	char *name;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::next	evrpc.h	/^	TAILQ_ENTRY(evrpc_request_wrapper) next;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::pool	evrpc.h	/^        struct evrpc_pool *pool;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evrpc_pool	access:public
evrpc_request_wrapper::reply	evrpc.h	/^	void *reply;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::reply_clear	evrpc.h	/^	void (*reply_clear)(void *);$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::reply_unmarshal	evrpc.h	/^	int (*reply_unmarshal)(void *, struct evbuffer*);$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::request	evrpc.h	/^	void *request;$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper::request_marshal	evrpc.h	/^	void (*request_marshal)(struct evbuffer *, void *);$/;"	m	struct:evrpc_request_wrapper	access:public
evrpc_request_wrapper_free	evrpc.c	/^evrpc_request_wrapper_free(struct evrpc_request_wrapper *request)$/;"	f	file:	signature:(struct evrpc_request_wrapper *request)
evrpc_schedule_request	evrpc.c	/^evrpc_schedule_request(struct evhttp_connection *connection,$/;"	f	file:	signature:(struct evhttp_connection *connection, struct evrpc_request_wrapper *ctx)
evrpc_schedule_request	evrpc.c	/^static int evrpc_schedule_request(struct evhttp_connection *connection,$/;"	p	file:	signature:(struct evhttp_connection *connection, struct evrpc_request_wrapper *ctx)
evrpc_status	evrpc.h	/^struct evrpc_status {$/;"	s
evrpc_status::error	evrpc.h	/^	int error;$/;"	m	struct:evrpc_status	access:public
evrpc_status::http_req	evrpc.h	/^	struct evhttp_request *http_req;$/;"	m	struct:evrpc_status	typeref:struct:evrpc_status::evhttp_request	access:public
evrpc_unregister_rpc	evrpc.c	/^evrpc_unregister_rpc(struct evrpc_base *base, const char *name)$/;"	f	signature:(struct evrpc_base *base, const char *name)
evrpc_unregister_rpc	evrpc.h	/^int evrpc_unregister_rpc(struct evrpc_base *base, const char *name);$/;"	p	signature:(struct evrpc_base *base, const char *name)
evsel	event-internal.h	/^	const struct eventop *evsel;$/;"	m	struct:event_base	typeref:struct:event_base::eventop	access:public
evsigcaught	WIN32-Code/win32.c	/^int evsigcaught[NSIG];$/;"	v
evsigcaught	evsignal.h	/^	sig_atomic_t evsigcaught[NSIG];$/;"	m	struct:evsignal_info	access:public
evsigevents	evsignal.h	/^	struct event_list evsigevents[NSIG];$/;"	m	struct:evsignal_info	typeref:struct:evsignal_info::event_list	access:public
evsigevents	kqueue.c	/^	struct event_list evsigevents[NSIG];$/;"	m	struct:kqop	typeref:struct:kqop::event_list	file:	access:public
evsignal_add	evsignal.h	/^int evsignal_add(struct event *);$/;"	p	signature:(struct event *)
evsignal_add	signal.c	/^evsignal_add(struct event *ev)$/;"	f	signature:(struct event *ev)
evsignal_base	signal.c	/^struct event_base *evsignal_base = NULL;$/;"	v	typeref:struct:event_base
evsignal_caught	evsignal.h	/^	volatile sig_atomic_t evsignal_caught;$/;"	m	struct:evsignal_info	access:public
evsignal_cb	signal.c	/^evsignal_cb(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
evsignal_dealloc	evsignal.h	/^void evsignal_dealloc(struct event_base *);$/;"	p	signature:(struct event_base *)
evsignal_dealloc	signal.c	/^evsignal_dealloc(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evsignal_del	evsignal.h	/^int evsignal_del(struct event *);$/;"	p	signature:(struct event *)
evsignal_del	signal.c	/^evsignal_del(struct event *ev)$/;"	f	signature:(struct event *ev)
evsignal_handler	signal.c	/^evsignal_handler(int sig)$/;"	f	file:	signature:(int sig)
evsignal_handler	signal.c	/^static void evsignal_handler(int sig);$/;"	p	file:	signature:(int sig)
evsignal_info	evsignal.h	/^struct evsignal_info {$/;"	s
evsignal_info::ev_signal	evsignal.h	/^	struct event ev_signal;$/;"	m	struct:evsignal_info	typeref:struct:evsignal_info::event	access:public
evsignal_info::ev_signal_added	evsignal.h	/^	int ev_signal_added;$/;"	m	struct:evsignal_info	access:public
evsignal_info::ev_signal_pair	evsignal.h	/^	int ev_signal_pair[2];$/;"	m	struct:evsignal_info	access:public
evsignal_info::evsigcaught	evsignal.h	/^	sig_atomic_t evsigcaught[NSIG];$/;"	m	struct:evsignal_info	access:public
evsignal_info::evsigevents	evsignal.h	/^	struct event_list evsigevents[NSIG];$/;"	m	struct:evsignal_info	typeref:struct:evsignal_info::event_list	access:public
evsignal_info::evsignal_caught	evsignal.h	/^	volatile sig_atomic_t evsignal_caught;$/;"	m	struct:evsignal_info	access:public
evsignal_info::sh_old	evsignal.h	/^	ev_sighandler_t **sh_old;$/;"	m	struct:evsignal_info	access:public
evsignal_info::sh_old	evsignal.h	/^	struct sigaction **sh_old;$/;"	m	struct:evsignal_info	typeref:struct:evsignal_info::sigaction	access:public
evsignal_info::sh_old_max	evsignal.h	/^	int sh_old_max;$/;"	m	struct:evsignal_info	access:public
evsignal_init	evsignal.h	/^void evsignal_init(struct event_base *);$/;"	p	signature:(struct event_base *)
evsignal_init	signal.c	/^evsignal_init(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evsignal_process	evsignal.h	/^void evsignal_process(struct event_base *);$/;"	p	signature:(struct event_base *)
evsignal_process	signal.c	/^evsignal_process(struct event_base *base)$/;"	f	signature:(struct event_base *base)
evtag_consume	event.h	/^int evtag_consume(struct evbuffer *evbuf);$/;"	p	signature:(struct evbuffer *evbuf)
evtag_consume	event_tagging.c	/^evtag_consume(struct evbuffer *evbuf)$/;"	f	signature:(struct evbuffer *evbuf)
evtag_decode_int	event_tagging.c	/^evtag_decode_int(ev_uint32_t *pnumber, struct evbuffer *evbuf)$/;"	f	signature:(ev_uint32_t *pnumber, struct evbuffer *evbuf)
evtag_decode_int	event_tagging.c	/^int evtag_decode_int(ev_uint32_t *pnumber, struct evbuffer *evbuf);$/;"	p	file:	signature:(ev_uint32_t *pnumber, struct evbuffer *evbuf)
evtag_decode_int	test/regress.c	/^int evtag_decode_int(uint32_t *pnumber, struct evbuffer *evbuf);$/;"	p	file:	signature:(uint32_t *pnumber, struct evbuffer *evbuf)
evtag_decode_tag	event_tagging.c	/^evtag_decode_tag(ev_uint32_t *ptag, struct evbuffer *evbuf)$/;"	f	signature:(ev_uint32_t *ptag, struct evbuffer *evbuf)
evtag_decode_tag	event_tagging.c	/^int evtag_decode_tag(ev_uint32_t *ptag, struct evbuffer *evbuf);$/;"	p	file:	signature:(ev_uint32_t *ptag, struct evbuffer *evbuf)
evtag_decode_tag	test/regress.c	/^int evtag_decode_tag(uint32_t *pnumber, struct evbuffer *evbuf);$/;"	p	file:	signature:(uint32_t *pnumber, struct evbuffer *evbuf)
evtag_encode_tag	event_tagging.c	/^evtag_encode_tag(struct evbuffer *evbuf, ev_uint32_t tag)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag)
evtag_encode_tag	event_tagging.c	/^int evtag_encode_tag(struct evbuffer *evbuf, ev_uint32_t tag);$/;"	p	file:	signature:(struct evbuffer *evbuf, ev_uint32_t tag)
evtag_encode_tag	test/regress.c	/^int evtag_encode_tag(struct evbuffer *evbuf, uint32_t number);$/;"	p	file:	signature:(struct evbuffer *evbuf, uint32_t number)
evtag_fuzz	test/regress.c	/^evtag_fuzz(void)$/;"	f	file:	signature:(void)
evtag_init	event.h	/^void evtag_init(void);$/;"	p	signature:(void)
evtag_init	event_tagging.c	/^evtag_init(void)$/;"	f	signature:(void)
evtag_int_test	test/regress.c	/^evtag_int_test(void)$/;"	f	file:	signature:(void)
evtag_marshal	event.h	/^void evtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag, const void *data,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t tag, const void *data, ev_uint32_t len)
evtag_marshal	event_tagging.c	/^evtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag, const void *data, ev_uint32_t len)
evtag_marshal_int	event.h	/^void evtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint32_t integer)
evtag_marshal_int	event_tagging.c	/^evtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint32_t integer)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag, ev_uint32_t integer)
evtag_marshal_kill	test/regress.gen.c	/^evtag_marshal_kill(struct evbuffer *evbuf, uint32_t tag, const struct kill *msg)$/;"	f	signature:(struct evbuffer *evbuf, uint32_t tag, const struct kill *msg)
evtag_marshal_kill	test/regress.gen.h	/^void evtag_marshal_kill(struct evbuffer *, uint32_t, $/;"	p	signature:(struct evbuffer *, uint32_t, const struct kill *)
evtag_marshal_msg	test/regress.gen.c	/^evtag_marshal_msg(struct evbuffer *evbuf, uint32_t tag, const struct msg *msg)$/;"	f	signature:(struct evbuffer *evbuf, uint32_t tag, const struct msg *msg)
evtag_marshal_msg	test/regress.gen.h	/^void evtag_marshal_msg(struct evbuffer *, uint32_t, $/;"	p	signature:(struct evbuffer *, uint32_t, const struct msg *)
evtag_marshal_run	test/regress.gen.c	/^evtag_marshal_run(struct evbuffer *evbuf, uint32_t tag, const struct run *msg)$/;"	f	signature:(struct evbuffer *evbuf, uint32_t tag, const struct run *msg)
evtag_marshal_run	test/regress.gen.h	/^void evtag_marshal_run(struct evbuffer *, uint32_t, $/;"	p	signature:(struct evbuffer *, uint32_t, const struct run *)
evtag_marshal_string	event.h	/^void evtag_marshal_string(struct evbuffer *buf, ev_uint32_t tag,$/;"	p	signature:(struct evbuffer *buf, ev_uint32_t tag, const char *string)
evtag_marshal_string	event_tagging.c	/^evtag_marshal_string(struct evbuffer *buf, ev_uint32_t tag, const char *string)$/;"	f	signature:(struct evbuffer *buf, ev_uint32_t tag, const char *string)
evtag_marshal_timeval	event.h	/^void evtag_marshal_timeval(struct evbuffer *evbuf, ev_uint32_t tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t tag, struct timeval *tv)
evtag_marshal_timeval	event_tagging.c	/^evtag_marshal_timeval(struct evbuffer *evbuf, ev_uint32_t tag, struct timeval *tv)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t tag, struct timeval *tv)
evtag_payload_length	event.h	/^int evtag_payload_length(struct evbuffer *evbuf, ev_uint32_t *plength);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t *plength)
evtag_payload_length	event_tagging.c	/^evtag_payload_length(struct evbuffer *evbuf, ev_uint32_t *plength)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t *plength)
evtag_peek	event.h	/^int evtag_peek(struct evbuffer *evbuf, ev_uint32_t *ptag);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t *ptag)
evtag_peek	event_tagging.c	/^evtag_peek(struct evbuffer *evbuf, ev_uint32_t *ptag)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t *ptag)
evtag_peek_length	event.h	/^int evtag_peek_length(struct evbuffer *evbuf, ev_uint32_t *plength);$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t *plength)
evtag_peek_length	event_tagging.c	/^evtag_peek_length(struct evbuffer *evbuf, ev_uint32_t *plength)$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t *plength)
evtag_tag_encoding	test/regress.c	/^evtag_tag_encoding(void)$/;"	f	file:	signature:(void)
evtag_test	test/regress.c	/^evtag_test(void)$/;"	f	file:	signature:(void)
evtag_unmarshal	event.h	/^int evtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag,$/;"	p	signature:(struct evbuffer *src, ev_uint32_t *ptag, struct evbuffer *dst)
evtag_unmarshal	event_tagging.c	/^evtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag, struct evbuffer *dst)$/;"	f	signature:(struct evbuffer *src, ev_uint32_t *ptag, struct evbuffer *dst)
evtag_unmarshal_fixed	event.h	/^int evtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag,$/;"	p	signature:(struct evbuffer *src, ev_uint32_t need_tag, void *data, size_t len)
evtag_unmarshal_fixed	event_tagging.c	/^evtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag, void *data,$/;"	f	signature:(struct evbuffer *src, ev_uint32_t need_tag, void *data, size_t len)
evtag_unmarshal_int	event.h	/^int evtag_unmarshal_int(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, ev_uint32_t *pinteger)
evtag_unmarshal_int	event_tagging.c	/^evtag_unmarshal_int(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, ev_uint32_t *pinteger)
evtag_unmarshal_kill	test/regress.gen.c	/^evtag_unmarshal_kill(struct evbuffer *evbuf, uint32_t need_tag, struct kill *msg)$/;"	f	signature:(struct evbuffer *evbuf, uint32_t need_tag, struct kill *msg)
evtag_unmarshal_kill	test/regress.gen.h	/^int evtag_unmarshal_kill(struct evbuffer *, uint32_t,$/;"	p	signature:(struct evbuffer *, uint32_t, struct kill *)
evtag_unmarshal_msg	test/regress.gen.c	/^evtag_unmarshal_msg(struct evbuffer *evbuf, uint32_t need_tag, struct msg *msg)$/;"	f	signature:(struct evbuffer *evbuf, uint32_t need_tag, struct msg *msg)
evtag_unmarshal_msg	test/regress.gen.h	/^int evtag_unmarshal_msg(struct evbuffer *, uint32_t,$/;"	p	signature:(struct evbuffer *, uint32_t, struct msg *)
evtag_unmarshal_run	test/regress.gen.c	/^evtag_unmarshal_run(struct evbuffer *evbuf, uint32_t need_tag, struct run *msg)$/;"	f	signature:(struct evbuffer *evbuf, uint32_t need_tag, struct run *msg)
evtag_unmarshal_run	test/regress.gen.h	/^int evtag_unmarshal_run(struct evbuffer *, uint32_t,$/;"	p	signature:(struct evbuffer *, uint32_t, struct run *)
evtag_unmarshal_string	event.h	/^int evtag_unmarshal_string(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, char **pstring)
evtag_unmarshal_string	event_tagging.c	/^evtag_unmarshal_string(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, char **pstring)
evtag_unmarshal_timeval	event.h	/^int evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	p	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, struct timeval *ptv)
evtag_unmarshal_timeval	event_tagging.c	/^evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,$/;"	f	signature:(struct evbuffer *evbuf, ev_uint32_t need_tag, struct timeval *ptv)
evtimer_add	event.h	458;"	d
evtimer_del	event.h	476;"	d
evtimer_initialized	event.h	478;"	d
evtimer_pending	event.h	477;"	d
evtimer_set	event.h	468;"	d
evutil_gettimeofday	evutil.c	/^evutil_gettimeofday(struct timeval *tv, struct timezone *tz)$/;"	f	signature:(struct timeval *tv, struct timezone *tz)
evutil_gettimeofday	evutil.h	/^int evutil_gettimeofday(struct timeval *tv, struct timezone *tz);$/;"	p	signature:(struct timeval *tv, struct timezone *tz)
evutil_gettimeofday	evutil.h	169;"	d
evutil_make_socket_nonblocking	evutil.c	/^evutil_make_socket_nonblocking(int fd)$/;"	f	signature:(int fd)
evutil_make_socket_nonblocking	evutil.h	/^int evutil_make_socket_nonblocking(int sock);$/;"	p	signature:(int sock)
evutil_snprintf	evutil.c	/^evutil_snprintf(char *buf, size_t buflen, const char *format, ...)$/;"	f	signature:(char *buf, size_t buflen, const char *format, ...)
evutil_snprintf	evutil.h	/^int evutil_snprintf(char *buf, size_t buflen, const char *format, ...)$/;"	p	signature:(char *buf, size_t buflen, const char *format, ...)
evutil_socketpair	evutil.c	/^evutil_socketpair(int family, int type, int protocol, int fd[2])$/;"	f	signature:(int family, int type, int protocol, int fd[2])
evutil_socketpair	evutil.h	/^int evutil_socketpair(int d, int type, int protocol, int sv[2]);$/;"	p	signature:(int d, int type, int protocol, int sv[2])
evutil_strtoll	evutil.c	/^evutil_strtoll(const char *s, char **endptr, int base)$/;"	f	signature:(const char *s, char **endptr, int base)
evutil_strtoll	evutil.h	/^ev_int64_t evutil_strtoll(const char *s, char **endptr, int base);$/;"	p	signature:(const char *s, char **endptr, int base)
evutil_timeradd	evutil.h	123;"	d
evutil_timeradd	evutil.h	126;"	d
evutil_timerclear	evutil.h	147;"	d
evutil_timerclear	evutil.h	149;"	d
evutil_timercmp	evutil.h	152;"	d
evutil_timerisset	evutil.h	158;"	d
evutil_timerisset	evutil.h	160;"	d
evutil_timersub	evutil.h	124;"	d
evutil_timersub	evutil.h	135;"	d
evutil_vsnprintf	evutil.c	/^evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)$/;"	f	signature:(char *buf, size_t buflen, const char *format, va_list ap)
evutil_vsnprintf	evutil.h	/^int evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap);$/;"	p	signature:(char *buf, size_t buflen, const char *format, va_list ap)
evwrite	devpoll.c	/^	struct event *evwrite;$/;"	m	struct:evdevpoll	typeref:struct:evdevpoll::event	file:	access:public
evwrite	epoll.c	/^	struct event *evwrite;$/;"	m	struct:evepoll	typeref:struct:evepoll::event	file:	access:public
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	sample/Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	test/Makefile	/^exec_prefix = ${prefix}$/;"	m
exset_out	WIN32-Code/win32.c	/^	struct win_fd_set *exset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
fail_cb	test/regress.c	/^fail_cb(int fd, short events, void *arg)$/;"	f	file:	signature:(int fd, short events, void *arg)
failed_times	evdns.c	/^	int failed_times;  \/* number of times which we have given this server a chance *\/$/;"	m	struct:nameserver	file:	access:public
fake_freeaddrinfo	http.c	/^fake_freeaddrinfo(struct addrinfo *ai)$/;"	f	file:	signature:(struct addrinfo *ai)
fake_getaddrinfo	http.c	/^fake_getaddrinfo(const char *hostname, struct addrinfo *ai)$/;"	f	file:	signature:(const char *hostname, struct addrinfo *ai)
fake_getnameinfo	http.c	/^fake_getnameinfo(const struct sockaddr *sa, size_t salen, char *host, $/;"	f	signature:(const struct sockaddr *sa, size_t salen, char *host, size_t hostlen, char *serv, size_t servlen, int flags)
fd	http-internal.h	/^	int fd;$/;"	m	struct:evhttp_connection	access:public
fd_array	WIN32-Code/win32.c	/^	SOCKET fd_array[1];$/;"	m	struct:win_fd_set	file:	access:public
fd_count	WIN32-Code/win32.c	/^	u_int fd_count;$/;"	m	struct:win_fd_set	file:	access:public
fd_count	poll.c	/^	int fd_count;                   \/* Size of idxplus1_by_fd *\/$/;"	m	struct:pollop	file:	access:public
fd_info	evport.c	/^struct fd_info {$/;"	s	file:
fd_info::fdi_revt	evport.c	/^	struct event* fdi_revt; \/* the event responsible for the "read"  *\/$/;"	m	struct:fd_info	typeref:struct:fd_info::event	file:	access:public
fd_info::fdi_wevt	evport.c	/^	struct event* fdi_wevt; \/* the event responsible for the "write" *\/$/;"	m	struct:fd_info	typeref:struct:fd_info::event	file:	access:public
fd_set_copy	WIN32-Code/win32.c	/^fd_set_copy(struct win_fd_set *out, const struct win_fd_set *in)$/;"	f	file:	signature:(struct win_fd_set *out, const struct win_fd_set *in)
fd_setsz	WIN32-Code/win32.c	/^	int fd_setsz;$/;"	m	struct:win32op	file:	access:public
fdi_revt	evport.c	/^	struct event* fdi_revt; \/* the event responsible for the "read"  *\/$/;"	m	struct:fd_info	typeref:struct:fd_info::event	file:	access:public
fdi_wevt	evport.c	/^	struct event* fdi_wevt; \/* the event responsible for the "write" *\/$/;"	m	struct:fd_info	typeref:struct:fd_info::event	file:	access:public
fds	devpoll.c	/^	struct evdevpoll *fds;$/;"	m	struct:devpollop	typeref:struct:devpollop::evdevpoll	file:	access:public
fds	epoll.c	/^	struct evepoll *fds;$/;"	m	struct:epollop	typeref:struct:epollop::evepoll	file:	access:public
fifo_read	sample/event-test.c	/^fifo_read(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
fired	test/bench.c	/^static int count, writes, fired;$/;"	v	file:
fixed_bytes_assign	test/regress.gen.h	/^  int (*fixed_bytes_assign)(struct run *, const uint8_t *);$/;"	m	struct:run_access_	access:public
fixed_bytes_data	test/regress.gen.h	/^  uint8_t fixed_bytes_data[24];$/;"	m	struct:run	access:public
fixed_bytes_get	test/regress.gen.h	/^  int (*fixed_bytes_get)(struct run *, uint8_t **);$/;"	m	struct:run_access_	access:public
fixed_bytes_set	test/regress.gen.h	/^  uint8_t fixed_bytes_set;$/;"	m	struct:run	access:public
flags	evdns.h	/^	int flags;$/;"	m	struct:evdns_server_request	access:public
flags	evhttp.h	/^	int flags;$/;"	m	struct:evhttp_request	access:public
flags	http-internal.h	/^	int flags;$/;"	m	struct:evhttp_connection	access:public
from_name_assign	test/regress.gen.h	/^  int (*from_name_assign)(struct msg *, const char *);$/;"	m	struct:msg_access_	access:public
from_name_data	test/regress.gen.h	/^  char *from_name_data;$/;"	m	struct:msg	access:public
from_name_get	test/regress.gen.h	/^  int (*from_name_get)(struct msg *, char * *);$/;"	m	struct:msg_access_	access:public
from_name_set	test/regress.gen.h	/^  uint8_t from_name_set;$/;"	m	struct:msg	access:public
func_append	config.status	/^func_append ()$/;"	f
func_append	configure	/^func_append ()$/;"	f
func_append	libtool	/^func_append ()$/;"	f
func_arith	config.status	/^func_arith ()$/;"	f
func_arith	configure	/^func_arith ()$/;"	f
func_arith	libtool	/^func_arith ()$/;"	f
func_basename	config.status	/^func_basename ()$/;"	f
func_basename	configure	/^func_basename ()$/;"	f
func_basename	libtool	/^func_basename ()$/;"	f
func_check_version_match	libtool	/^func_check_version_match ()$/;"	f
func_check_version_match	ltmain.sh	/^func_check_version_match ()$/;"	f
func_config	libtool	/^func_config ()$/;"	f
func_config	ltmain.sh	/^func_config ()$/;"	f
func_dirname	config.status	/^func_dirname ()$/;"	f
func_dirname	configure	/^func_dirname ()$/;"	f
func_dirname	libtool	/^func_dirname ()$/;"	f
func_dirname_and_basename	config.status	/^func_dirname_and_basename ()$/;"	f
func_dirname_and_basename	configure	/^func_dirname_and_basename ()$/;"	f
func_dirname_and_basename	libtool	/^func_dirname_and_basename ()$/;"	f
func_dirname_and_basename	ltmain.sh	/^func_dirname_and_basename ()$/;"	f
func_echo	libtool	/^func_echo ()$/;"	f
func_echo	ltmain.sh	/^func_echo ()$/;"	f
func_emit_cwrapperexe_src	libtool	/^func_emit_cwrapperexe_src ()$/;"	f
func_emit_cwrapperexe_src	ltmain.sh	/^func_emit_cwrapperexe_src ()$/;"	f
func_emit_wrapper	libtool	/^func_emit_wrapper ()$/;"	f
func_emit_wrapper	ltmain.sh	/^func_emit_wrapper ()$/;"	f
func_enable_tag	libtool	/^func_enable_tag ()$/;"	f
func_enable_tag	ltmain.sh	/^func_enable_tag ()$/;"	f
func_error	libtool	/^func_error ()$/;"	f
func_error	ltmain.sh	/^func_error ()$/;"	f
func_execute_cmds	libtool	/^func_execute_cmds ()$/;"	f
func_execute_cmds	ltmain.sh	/^func_execute_cmds ()$/;"	f
func_extract_an_archive	libtool	/^func_extract_an_archive ()$/;"	f
func_extract_an_archive	ltmain.sh	/^func_extract_an_archive ()$/;"	f
func_extract_archives	libtool	/^func_extract_archives ()$/;"	f
func_extract_archives	ltmain.sh	/^func_extract_archives ()$/;"	f
func_fatal_configuration	libtool	/^func_fatal_configuration ()$/;"	f
func_fatal_configuration	ltmain.sh	/^func_fatal_configuration ()$/;"	f
func_fatal_error	libtool	/^func_fatal_error ()$/;"	f
func_fatal_error	ltmain.sh	/^func_fatal_error ()$/;"	f
func_fatal_help	libtool	/^func_fatal_help ()$/;"	f
func_fatal_help	ltmain.sh	/^func_fatal_help ()$/;"	f
func_features	libtool	/^func_features ()$/;"	f
func_features	ltmain.sh	/^func_features ()$/;"	f
func_generate_dlsyms	libtool	/^func_generate_dlsyms ()$/;"	f
func_generate_dlsyms	ltmain.sh	/^func_generate_dlsyms ()$/;"	f
func_grep	libtool	/^func_grep ()$/;"	f
func_grep	ltmain.sh	/^func_grep ()$/;"	f
func_help	libtool	/^func_help ()$/;"	f
func_help	ltmain.sh	/^func_help ()$/;"	f
func_infer_tag	libtool	/^func_infer_tag ()$/;"	f
func_infer_tag	ltmain.sh	/^func_infer_tag ()$/;"	f
func_lalib_p	libtool	/^func_lalib_p ()$/;"	f
func_lalib_p	ltmain.sh	/^func_lalib_p ()$/;"	f
func_lalib_unsafe_p	libtool	/^func_lalib_unsafe_p ()$/;"	f
func_lalib_unsafe_p	ltmain.sh	/^func_lalib_unsafe_p ()$/;"	f
func_len	config.status	/^func_len ()$/;"	f
func_len	configure	/^func_len ()$/;"	f
func_len	libtool	/^func_len ()$/;"	f
func_lo2o	config.status	/^func_lo2o ()$/;"	f
func_lo2o	configure	/^func_lo2o ()$/;"	f
func_lo2o	libtool	/^func_lo2o ()$/;"	f
func_ltwrapper_executable_p	libtool	/^func_ltwrapper_executable_p ()$/;"	f
func_ltwrapper_executable_p	ltmain.sh	/^func_ltwrapper_executable_p ()$/;"	f
func_ltwrapper_p	libtool	/^func_ltwrapper_p ()$/;"	f
func_ltwrapper_p	ltmain.sh	/^func_ltwrapper_p ()$/;"	f
func_ltwrapper_script_p	libtool	/^func_ltwrapper_script_p ()$/;"	f
func_ltwrapper_script_p	ltmain.sh	/^func_ltwrapper_script_p ()$/;"	f
func_ltwrapper_scriptname	libtool	/^func_ltwrapper_scriptname ()$/;"	f
func_ltwrapper_scriptname	ltmain.sh	/^func_ltwrapper_scriptname ()$/;"	f
func_missing_arg	libtool	/^func_missing_arg ()$/;"	f
func_missing_arg	ltmain.sh	/^func_missing_arg ()$/;"	f
func_mkdir_p	libtool	/^func_mkdir_p ()$/;"	f
func_mkdir_p	ltmain.sh	/^func_mkdir_p ()$/;"	f
func_mktempdir	libtool	/^func_mktempdir ()$/;"	f
func_mktempdir	ltmain.sh	/^func_mktempdir ()$/;"	f
func_mode_compile	libtool	/^func_mode_compile ()$/;"	f
func_mode_compile	ltmain.sh	/^func_mode_compile ()$/;"	f
func_mode_execute	libtool	/^func_mode_execute ()$/;"	f
func_mode_execute	ltmain.sh	/^func_mode_execute ()$/;"	f
func_mode_finish	libtool	/^func_mode_finish ()$/;"	f
func_mode_finish	ltmain.sh	/^func_mode_finish ()$/;"	f
func_mode_help	libtool	/^func_mode_help ()$/;"	f
func_mode_help	ltmain.sh	/^func_mode_help ()$/;"	f
func_mode_install	libtool	/^func_mode_install ()$/;"	f
func_mode_install	ltmain.sh	/^func_mode_install ()$/;"	f
func_mode_link	libtool	/^func_mode_link ()$/;"	f
func_mode_link	ltmain.sh	/^func_mode_link ()$/;"	f
func_mode_uninstall	libtool	/^func_mode_uninstall ()$/;"	f
func_mode_uninstall	ltmain.sh	/^func_mode_uninstall ()$/;"	f
func_opt_split	config.status	/^func_opt_split ()$/;"	f
func_opt_split	configure	/^func_opt_split ()$/;"	f
func_opt_split	libtool	/^func_opt_split ()$/;"	f
func_quote_for_eval	libtool	/^func_quote_for_eval ()$/;"	f
func_quote_for_eval	ltmain.sh	/^func_quote_for_eval ()$/;"	f
func_quote_for_expand	libtool	/^func_quote_for_expand ()$/;"	f
func_quote_for_expand	ltmain.sh	/^func_quote_for_expand ()$/;"	f
func_show_eval	libtool	/^func_show_eval ()$/;"	f
func_show_eval	ltmain.sh	/^func_show_eval ()$/;"	f
func_show_eval_locale	libtool	/^func_show_eval_locale ()$/;"	f
func_show_eval_locale	ltmain.sh	/^func_show_eval_locale ()$/;"	f
func_source	libtool	/^func_source ()$/;"	f
func_source	ltmain.sh	/^func_source ()$/;"	f
func_stripname	config.status	/^func_stripname ()$/;"	f
func_stripname	configure	/^func_stripname ()$/;"	f
func_stripname	libtool	/^func_stripname ()$/;"	f
func_usage	libtool	/^func_usage ()$/;"	f
func_usage	ltmain.sh	/^func_usage ()$/;"	f
func_verbose	libtool	/^func_verbose ()$/;"	f
func_verbose	ltmain.sh	/^func_verbose ()$/;"	f
func_version	libtool	/^func_version ()$/;"	f
func_version	ltmain.sh	/^func_version ()$/;"	f
func_warning	libtool	/^func_warning ()$/;"	f
func_warning	ltmain.sh	/^func_warning ()$/;"	f
func_win32_libid	libtool	/^func_win32_libid ()$/;"	f
func_win32_libid	ltmain.sh	/^func_win32_libid ()$/;"	f
func_write_libtool_object	libtool	/^func_write_libtool_object ()$/;"	f
func_write_libtool_object	ltmain.sh	/^func_write_libtool_object ()$/;"	f
func_xform	config.status	/^func_xform ()$/;"	f
func_xform	configure	/^func_xform ()$/;"	f
func_xform	libtool	/^func_xform ()$/;"	f
gencb	http-internal.h	/^	void (*gencb)(struct evhttp_request *req, void *);$/;"	m	struct:evhttp	access:public
gencbarg	http-internal.h	/^	void *gencbarg;$/;"	m	struct:evhttp	access:public
get_event_entry	WIN32-Code/win32.c	/^get_event_entry(struct win32op *op, SOCKET s, int create)$/;"	f	file:	signature:(struct win32op *op, SOCKET s, int create)
gettime	event.c	/^gettime(struct event_base *base, struct timeval *tp)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tp)
global_base	test/regress.c	/^static struct event_base *global_base;$/;"	v	typeref:struct:event_base	file:
global_good_nameservers	evdns.c	/^static int global_good_nameservers = 0;$/;"	v	file:
global_max_nameserver_timeout	evdns.c	/^static int global_max_nameserver_timeout = 3;$/;"	v	file:
global_max_reissues	evdns.c	/^static int global_max_reissues = 1;  \/* a reissue occurs when we get some errors from the server *\/$/;"	v	file:
global_max_requests_inflight	evdns.c	/^static int global_max_requests_inflight = 64;$/;"	v	file:
global_max_retransmits	evdns.c	/^static int global_max_retransmits = 3;  \/* number of times we'll retransmit a request which timed out *\/$/;"	v	file:
global_nameserver_timeouts	evdns.c	/^static const struct timeval global_nameserver_timeouts[] = {{10, 0}, {60, 0}, {300, 0}, {900, 0}, {3600, 0}};$/;"	v	typeref:struct:timeval	file:
global_nameserver_timeouts_length	evdns.c	/^static const int global_nameserver_timeouts_length = sizeof(global_nameserver_timeouts)\/sizeof(struct timeval);$/;"	v	file:
global_requests_inflight	evdns.c	/^static int global_requests_inflight = 0;$/;"	v	file:
global_requests_waiting	evdns.c	/^static int global_requests_waiting = 0;$/;"	v	file:
global_search_state	evdns.c	/^static struct search_state *global_search_state = NULL;$/;"	v	typeref:struct:search_state	file:
global_timeout	evdns.c	/^static struct timeval global_timeout = {5, 0};  \/* 5 seconds *\/$/;"	v	typeref:struct:timeval	file:
grow	evport.c	/^grow(struct evport_data *epdp, int factor)$/;"	f	file:	signature:(struct evport_data *epdp, int factor)
have_answer	evdns.c	/^	unsigned int have_answer;$/;"	m	struct:reply	file:	access:public
head	evdns.c	/^	struct search_domain *head;$/;"	m	struct:search_state	typeref:struct:search_state::search_domain	file:	access:public
headerdirect	event_rpcgen.py	/^headerdirect = []$/;"	v
high	event.h	/^	size_t high;$/;"	m	struct:event_watermark	access:public
host	Makefile	/^host = i686-pc-linux-gnu$/;"	m
host	sample/Makefile	/^host = i686-pc-linux-gnu$/;"	m
host	test/Makefile	/^host = i686-pc-linux-gnu$/;"	m
host_alias	Makefile	/^host_alias = $/;"	m
host_alias	sample/Makefile	/^host_alias = $/;"	m
host_alias	test/Makefile	/^host_alias = $/;"	m
host_cpu	Makefile	/^host_cpu = i686$/;"	m
host_cpu	sample/Makefile	/^host_cpu = i686$/;"	m
host_cpu	test/Makefile	/^host_cpu = i686$/;"	m
host_os	Makefile	/^host_os = linux-gnu$/;"	m
host_os	sample/Makefile	/^host_os = linux-gnu$/;"	m
host_os	test/Makefile	/^host_os = linux-gnu$/;"	m
host_triplet	Makefile	/^host_triplet = i686-pc-linux-gnu$/;"	m
host_triplet	sample/Makefile	/^host_triplet = i686-pc-linux-gnu$/;"	m
host_triplet	test/Makefile	/^host_triplet = i686-pc-linux-gnu$/;"	m
host_vendor	Makefile	/^host_vendor = pc$/;"	m
host_vendor	sample/Makefile	/^host_vendor = pc$/;"	m
host_vendor	test/Makefile	/^host_vendor = pc$/;"	m
how_assign	test/regress.gen.h	/^  int (*how_assign)(struct run *, const char *);$/;"	m	struct:run_access_	access:public
how_data	test/regress.gen.h	/^  char *how_data;$/;"	m	struct:run	access:public
how_get	test/regress.gen.h	/^  int (*how_get)(struct run *, char * *);$/;"	m	struct:run_access_	access:public
how_often_assign	test/regress.gen.h	/^  int (*how_often_assign)(struct kill *, const uint32_t);$/;"	m	struct:kill_access_	access:public
how_often_data	test/regress.gen.h	/^  uint32_t how_often_data;$/;"	m	struct:kill	access:public
how_often_get	test/regress.gen.h	/^  int (*how_often_get)(struct kill *, uint32_t *);$/;"	m	struct:kill_access_	access:public
how_often_set	test/regress.gen.h	/^  uint8_t how_often_set;$/;"	m	struct:kill	access:public
how_set	test/regress.gen.h	/^  uint8_t how_set;$/;"	m	struct:run	access:public
howmany	select.c	59;"	d	file:
html_replace	http.c	/^html_replace(char ch, char *buf)$/;"	f	file:	signature:(char ch, char *buf)
htmldir	Makefile	/^htmldir = ${docdir}$/;"	m
htmldir	sample/Makefile	/^htmldir = ${docdir}$/;"	m
htmldir	test/Makefile	/^htmldir = ${docdir}$/;"	m
http	test/regress_http.c	/^static struct evhttp *http;$/;"	v	typeref:struct:evhttp	file:
http_bad_header_test	test/regress_http.c	/^http_bad_header_test(void)$/;"	f	file:	signature:(void)
http_base_test	test/regress_http.c	/^http_base_test(void)$/;"	f	file:	signature:(void)
http_basic_cb	test/regress_http.c	/^http_basic_cb(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_basic_cb	test/regress_http.c	/^void http_basic_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_basic_test	test/regress.h	/^void http_basic_test(void);$/;"	p	signature:(void)
http_basic_test	test/regress_http.c	/^http_basic_test(void)$/;"	f	file:	signature:(void)
http_chunked_cb	test/regress_http.c	/^http_chunked_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_chunked_cb	test/regress_http.c	/^static void http_chunked_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_chunked_errorcb	test/regress_http.c	/^http_chunked_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
http_chunked_readcb	test/regress_http.c	/^http_chunked_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_chunked_request_done	test/regress_http.c	/^http_chunked_request_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_chunked_test	test/regress_http.c	/^http_chunked_test(void)$/;"	f	file:	signature:(void)
http_chunked_trickle_cb	test/regress_http.c	/^http_chunked_trickle_cb(int fd, short events, void *arg)$/;"	f	file:	signature:(int fd, short events, void *arg)
http_chunked_writecb	test/regress_http.c	/^http_chunked_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_close_detection	test/regress_http.c	/^http_close_detection(int with_delay)$/;"	f	file:	signature:(int with_delay)
http_complete_write	test/regress_http.c	/^http_complete_write(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
http_connect	test/regress_http.c	/^http_connect(const char *address, u_short port)$/;"	f	file:	signature:(const char *address, u_short port)
http_connection_test	test/regress_http.c	/^http_connection_test(int persistent)$/;"	f	file:	signature:(int persistent)
http_delay_reply	test/regress_http.c	/^http_delay_reply(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
http_dispatcher_cb	test/regress_http.c	/^http_dispatcher_cb(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_dispatcher_cb	test/regress_http.c	/^void http_dispatcher_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_dispatcher_test	test/regress_http.c	/^http_dispatcher_test(void)$/;"	f	file:	signature:(void)
http_dispatcher_test_done	test/regress_http.c	/^http_dispatcher_test_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_errorcb	test/regress_http.c	/^http_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
http_failure_readcb	test/regress_http.c	/^http_failure_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_failure_test	test/regress_http.c	/^http_failure_test(void)$/;"	f	file:	signature:(void)
http_highport_test	test/regress_http.c	/^http_highport_test(void)$/;"	f	file:	signature:(void)
http_large_delay_cb	test/regress_http.c	/^http_large_delay_cb(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_large_delay_cb	test/regress_http.c	/^static void http_large_delay_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_multi_line_header_test	test/regress_http.c	/^http_multi_line_header_test(void)$/;"	f	file:	signature:(void)
http_negative_content_length_test	test/regress_http.c	/^http_negative_content_length_test(void)$/;"	f	file:	signature:(void)
http_post_cb	test/regress_http.c	/^http_post_cb(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_post_cb	test/regress_http.c	/^void http_post_cb(struct evhttp_request *req, void *arg);$/;"	p	file:	signature:(struct evhttp_request *req, void *arg)
http_post_test	test/regress_http.c	/^http_post_test(void)$/;"	f	file:	signature:(void)
http_postrequest_done	test/regress_http.c	/^http_postrequest_done(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_postrequest_done	test/regress_http.c	/^void http_postrequest_done(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
http_readcb	test/regress_http.c	/^http_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
http_req	evrpc.h	/^	struct evhttp_request *http_req;$/;"	m	struct:evrpc_status	typeref:struct:evrpc_status::evhttp_request	access:public
http_req	evrpc.h	/^	struct evhttp_request* http_req;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evhttp_request	access:public
http_request_bad	test/regress_http.c	/^http_request_bad(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
http_request_done	test/regress_http.c	/^http_request_done(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_request_done	test/regress_http.c	/^void http_request_done(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
http_request_empty_done	test/regress_http.c	/^http_request_empty_done(struct evhttp_request *req, void *arg)$/;"	f	signature:(struct evhttp_request *req, void *arg)
http_request_empty_done	test/regress_http.c	/^void http_request_empty_done(struct evhttp_request *, void *);$/;"	p	file:	signature:(struct evhttp_request *, void *)
http_server	evrpc-internal.h	/^	struct evhttp* http_server;$/;"	m	struct:evrpc_base	typeref:struct:evrpc_base::evhttp	access:public
http_server	http-internal.h	/^	struct evhttp *http_server;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evhttp	access:public
http_setup	test/regress_http.c	/^http_setup(short *pport, struct event_base *base)$/;"	f	file:	signature:(short *pport, struct event_base *base)
http_setup	test/regress_rpc.c	/^http_setup(short *pport)$/;"	f	file:	signature:(short *pport)
http_suite	test/regress.h	/^void http_suite(void);$/;"	p	signature:(void)
http_suite	test/regress_http.c	/^http_suite(void)$/;"	f	signature:(void)
http_suite	test/regress_http.c	/^void http_suite(void);$/;"	p	file:	signature:(void)
http_writecb	test/regress_http.c	/^http_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
hz	compat/sys/_time.h	/^	int	hz;		\/* clock frequency *\/$/;"	m	struct:clockinfo	access:public
i	test/regress_http.c	/^	int i;$/;"	m	struct:chunk_req_state	file:	access:public
idxplus1_by_fd	poll.c	/^	int *idxplus1_by_fd; \/* Index into event_set by fd; we add 1 so$/;"	m	struct:pollop	file:	access:public
in6_addr	evdns.c	/^struct in6_addr {$/;"	s	file:
in6_addr::s6_addr	evdns.c	/^	u8 s6_addr[16];$/;"	m	struct:in6_addr	file:	access:public
in_hooks	evrpc-internal.h	/^	struct evrpc_hook_list in_hooks;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_hook_list	access:public
includeHEADERS_INSTALL	Makefile	/^includeHEADERS_INSTALL = $(INSTALL_HEADER)$/;"	m
include_HEADERS	Makefile	/^include_HEADERS = event.h evhttp.h evdns.h evrpc.h evutil.h event-config.h$/;"	m
includedir	Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	sample/Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	test/Makefile	/^includedir = ${prefix}\/include$/;"	m
inet_aton	evdns.c	/^inet_aton(const char *c, struct in_addr *addr)$/;"	f	file:	signature:(const char *c, struct in_addr *addr)
infodir	Makefile	/^infodir = ${datarootdir}\/info$/;"	m
infodir	sample/Makefile	/^infodir = ${datarootdir}\/info$/;"	m
infodir	test/Makefile	/^infodir = ${datarootdir}\/info$/;"	m
init	event-internal.h	/^	void *(*init)(struct event_base *);$/;"	m	struct:eventop	access:public
inline	WIN32-Code/config.h	221;"	d
input	event.h	/^	struct evbuffer *input;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
input_buffer	evhttp.h	/^	struct evbuffer *input_buffer;	\/* read data *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evbuffer	access:public
input_buffer	http-internal.h	/^	struct evbuffer *input_buffer;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evbuffer	access:public
input_headers	evhttp.h	/^	struct evkeyvalq *input_headers;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evkeyvalq	access:public
input_hooks	evrpc-internal.h	57;"	d
install_sh	Makefile	/^install_sh = $(SHELL) \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/install-sh$/;"	m
install_sh	sample/Makefile	/^install_sh = $(SHELL) \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/install-sh$/;"	m
install_sh	test/Makefile	/^install_sh = $(SHELL) \/home\/darius\/git-repository\/libevent\/libevent-1.4.9-stable\/install-sh$/;"	m
install_sh_DATA	Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_DATA	sample/Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_DATA	test/Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_PROGRAM	Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_PROGRAM	sample/Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_PROGRAM	test/Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_SCRIPT	Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
install_sh_SCRIPT	sample/Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
install_sh_SCRIPT	test/Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
is_name	evdns.c	/^	char is_name; \/* True iff data is a label *\/$/;"	m	struct:server_reply_item	file:	access:public
it_interval	compat/sys/_time.h	/^	struct	timeval it_interval;	\/* timer interval *\/$/;"	m	struct:itimerval	typeref:struct:itimerval::timeval	access:public
it_value	compat/sys/_time.h	/^	struct	timeval it_value;	\/* current value *\/$/;"	m	struct:itimerval	typeref:struct:itimerval::timeval	access:public
itimerval	compat/sys/_time.h	/^struct	itimerval {$/;"	s
itimerval::it_interval	compat/sys/_time.h	/^	struct	timeval it_interval;	\/* timer interval *\/$/;"	m	struct:itimerval	typeref:struct:itimerval::timeval	access:public
itimerval::it_value	compat/sys/_time.h	/^	struct	timeval it_value;	\/* current value *\/$/;"	m	struct:itimerval	typeref:struct:itimerval::timeval	access:public
key	event.h	/^	char *key;$/;"	m	struct:evkeyval	access:public
kill	test/regress.gen.h	/^struct kill {$/;"	s
kill::action_data	test/regress.gen.h	/^  char *action_data;$/;"	m	struct:kill	access:public
kill::action_set	test/regress.gen.h	/^  uint8_t action_set;$/;"	m	struct:kill	access:public
kill::base	test/regress.gen.h	/^  struct kill_access_ *base;$/;"	m	struct:kill	typeref:struct:kill::kill_access_	access:public
kill::how_often_data	test/regress.gen.h	/^  uint32_t how_often_data;$/;"	m	struct:kill	access:public
kill::how_often_set	test/regress.gen.h	/^  uint8_t how_often_set;$/;"	m	struct:kill	access:public
kill::weapon_data	test/regress.gen.h	/^  char *weapon_data;$/;"	m	struct:kill	access:public
kill::weapon_set	test/regress.gen.h	/^  uint8_t weapon_set;$/;"	m	struct:kill	access:public
kill_	test/regress.gen.h	/^enum kill_ {$/;"	g
kill_access_	test/regress.gen.h	/^struct kill_access_ {$/;"	s
kill_access_::action_assign	test/regress.gen.h	/^  int (*action_assign)(struct kill *, const char *);$/;"	m	struct:kill_access_	access:public
kill_access_::action_get	test/regress.gen.h	/^  int (*action_get)(struct kill *, char * *);$/;"	m	struct:kill_access_	access:public
kill_access_::how_often_assign	test/regress.gen.h	/^  int (*how_often_assign)(struct kill *, const uint32_t);$/;"	m	struct:kill_access_	access:public
kill_access_::how_often_get	test/regress.gen.h	/^  int (*how_often_get)(struct kill *, uint32_t *);$/;"	m	struct:kill_access_	access:public
kill_access_::weapon_assign	test/regress.gen.h	/^  int (*weapon_assign)(struct kill *, const char *);$/;"	m	struct:kill_access_	access:public
kill_access_::weapon_get	test/regress.gen.h	/^  int (*weapon_get)(struct kill *, char * *);$/;"	m	struct:kill_access_	access:public
kill_action_assign	test/regress.gen.c	/^kill_action_assign(struct kill *msg,$/;"	f	signature:(struct kill *msg, const char * value)
kill_action_assign	test/regress.gen.h	/^int kill_action_assign(struct kill *, const char *);$/;"	p	signature:(struct kill *, const char *)
kill_action_get	test/regress.gen.c	/^kill_action_get(struct kill *msg, char * *value)$/;"	f	signature:(struct kill *msg, char * *value)
kill_action_get	test/regress.gen.h	/^int kill_action_get(struct kill *, char * *);$/;"	p	signature:(struct kill *, char * *)
kill_clear	test/regress.gen.c	/^kill_clear(struct kill *tmp)$/;"	f	signature:(struct kill *tmp)
kill_clear	test/regress.gen.h	/^void kill_clear(struct kill *);$/;"	p	signature:(struct kill *)
kill_complete	test/regress.gen.c	/^kill_complete(struct kill *msg)$/;"	f	signature:(struct kill *msg)
kill_complete	test/regress.gen.h	/^int kill_complete(struct kill *);$/;"	p	signature:(struct kill *)
kill_free	test/regress.gen.c	/^kill_free(struct kill *tmp)$/;"	f	signature:(struct kill *tmp)
kill_free	test/regress.gen.h	/^void kill_free(struct kill *);$/;"	p	signature:(struct kill *)
kill_how_often_assign	test/regress.gen.c	/^kill_how_often_assign(struct kill *msg, const uint32_t value)$/;"	f	signature:(struct kill *msg, const uint32_t value)
kill_how_often_assign	test/regress.gen.h	/^int kill_how_often_assign(struct kill *, const uint32_t);$/;"	p	signature:(struct kill *, const uint32_t)
kill_how_often_get	test/regress.gen.c	/^kill_how_often_get(struct kill *msg, uint32_t *value)$/;"	f	signature:(struct kill *msg, uint32_t *value)
kill_how_often_get	test/regress.gen.h	/^int kill_how_often_get(struct kill *, uint32_t *);$/;"	p	signature:(struct kill *, uint32_t *)
kill_marshal	test/regress.gen.c	/^kill_marshal(struct evbuffer *evbuf, const struct kill *tmp){$/;"	f	signature:(struct evbuffer *evbuf, const struct kill *tmp)
kill_marshal	test/regress.gen.h	/^void kill_marshal(struct evbuffer *, const struct kill *);$/;"	p	signature:(struct evbuffer *, const struct kill *)
kill_new	test/regress.gen.c	/^kill_new(void)$/;"	f	signature:(void)
kill_new	test/regress.gen.h	/^struct kill *kill_new(void);$/;"	p	signature:(void)
kill_unmarshal	test/regress.gen.c	/^kill_unmarshal(struct kill *tmp,  struct evbuffer *evbuf)$/;"	f	signature:(struct kill *tmp, struct evbuffer *evbuf)
kill_unmarshal	test/regress.gen.h	/^int kill_unmarshal(struct kill *, struct evbuffer *);$/;"	p	signature:(struct kill *, struct evbuffer *)
kill_weapon_assign	test/regress.gen.c	/^kill_weapon_assign(struct kill *msg,$/;"	f	signature:(struct kill *msg, const char * value)
kill_weapon_assign	test/regress.gen.h	/^int kill_weapon_assign(struct kill *, const char *);$/;"	p	signature:(struct kill *, const char *)
kill_weapon_get	test/regress.gen.c	/^kill_weapon_get(struct kill *msg, char * *value)$/;"	f	signature:(struct kill *msg, char * *value)
kill_weapon_get	test/regress.gen.h	/^int kill_weapon_get(struct kill *, char * *);$/;"	p	signature:(struct kill *, char * *)
kind	evhttp.h	/^	enum evhttp_request_kind kind;$/;"	m	struct:evhttp_request	typeref:enum:evhttp_request::evhttp_request_kind	access:public
kq	kqueue.c	/^	int kq;$/;"	m	struct:kqop	file:	access:public
kq_add	kqueue.c	/^kq_add(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
kq_add	kqueue.c	/^static int kq_add	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
kq_dealloc	kqueue.c	/^kq_dealloc(struct event_base *base, void *arg)$/;"	f	file:	signature:(struct event_base *base, void *arg)
kq_dealloc	kqueue.c	/^static void kq_dealloc (struct event_base *, void *);$/;"	p	file:	signature:(struct event_base *, void *)
kq_del	kqueue.c	/^kq_del(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
kq_del	kqueue.c	/^static int kq_del	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
kq_dispatch	kqueue.c	/^kq_dispatch(struct event_base *base, void *arg, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, void *arg, struct timeval *tv)
kq_dispatch	kqueue.c	/^static int kq_dispatch	(struct event_base *, void *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, void *, struct timeval *)
kq_init	kqueue.c	/^kq_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
kq_init	kqueue.c	/^static void *kq_init	(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
kq_insert	kqueue.c	/^kq_insert(struct kqop *kqop, struct kevent *kev)$/;"	f	file:	signature:(struct kqop *kqop, struct kevent *kev)
kq_insert	kqueue.c	/^static int kq_insert	(struct kqop *, struct kevent *);$/;"	p	file:	signature:(struct kqop *, struct kevent *)
kq_sighandler	kqueue.c	/^kq_sighandler(int sig)$/;"	f	file:	signature:(int sig)
kqop	kqueue.c	/^struct kqop {$/;"	s	file:
kqop::changes	kqueue.c	/^	struct kevent *changes;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:	access:public
kqop::events	kqueue.c	/^	struct kevent *events;$/;"	m	struct:kqop	typeref:struct:kqop::kevent	file:	access:public
kqop::evsigevents	kqueue.c	/^	struct event_list evsigevents[NSIG];$/;"	m	struct:kqop	typeref:struct:kqop::event_list	file:	access:public
kqop::kq	kqueue.c	/^	int kq;$/;"	m	struct:kqop	file:	access:public
kqop::nchanges	kqueue.c	/^	int nchanges;$/;"	m	struct:kqop	file:	access:public
kqop::nevents	kqueue.c	/^	int nevents;$/;"	m	struct:kqop	file:	access:public
kqop::pid	kqueue.c	/^	pid_t pid;$/;"	m	struct:kqop	file:	access:public
kqops	kqueue.c	/^const struct eventop kqops = {$/;"	v	typeref:struct:eventop
labels	evdns.c	/^	struct dnslabel_entry labels[MAX_LABELS];$/;"	m	struct:dnslabel_table	typeref:struct:dnslabel_table::dnslabel_entry	file:	access:public
last_error	evdns.c	/^last_error(int sock)$/;"	f	file:	signature:(int sock)
last_error	evdns.c	374;"	d	file:
lasttime	sample/time-test.c	/^int lasttime;$/;"	v
len	evdns.c	/^	int len;$/;"	m	struct:search_domain	file:	access:public
libLTLIBRARIES_INSTALL	Makefile	/^libLTLIBRARIES_INSTALL = $(INSTALL)$/;"	m
lib_LTLIBRARIES	Makefile	/^lib_LTLIBRARIES = libevent.la libevent_core.la libevent_extra.la$/;"	m
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	sample/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	test/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libevent_core_la_DEPENDENCIES	Makefile	/^libevent_core_la_DEPENDENCIES =  ${LIBOBJDIR}select$U.lo ${LIBOBJDIR}poll$U.lo ${LIBOBJDIR}epoll$U.lo ${LIBOBJDIR}signal$U.lo $(am__DEPENDENCIES_1)$/;"	m
libevent_core_la_LDFLAGS	Makefile	/^libevent_core_la_LDFLAGS = -release $(RELEASE) -version-info $(VERSION_INFO)$/;"	m
libevent_core_la_LIBADD	Makefile	/^libevent_core_la_LIBADD =  ${LIBOBJDIR}select$U.lo ${LIBOBJDIR}poll$U.lo ${LIBOBJDIR}epoll$U.lo ${LIBOBJDIR}signal$U.lo $(SYS_LIBS)$/;"	m
libevent_core_la_LINK	Makefile	/^libevent_core_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
libevent_core_la_OBJECTS	Makefile	/^libevent_core_la_OBJECTS = $(am_libevent_core_la_OBJECTS)$/;"	m
libevent_core_la_SOURCES	Makefile	/^libevent_core_la_SOURCES = $(CORE_SRC)$/;"	m
libevent_extra_la_DEPENDENCIES	Makefile	/^libevent_extra_la_DEPENDENCIES =  ${LIBOBJDIR}select$U.lo ${LIBOBJDIR}poll$U.lo ${LIBOBJDIR}epoll$U.lo ${LIBOBJDIR}signal$U.lo $(am__DEPENDENCIES_1)$/;"	m
libevent_extra_la_LDFLAGS	Makefile	/^libevent_extra_la_LDFLAGS = -release $(RELEASE) -version-info $(VERSION_INFO)$/;"	m
libevent_extra_la_LIBADD	Makefile	/^libevent_extra_la_LIBADD =  ${LIBOBJDIR}select$U.lo ${LIBOBJDIR}poll$U.lo ${LIBOBJDIR}epoll$U.lo ${LIBOBJDIR}signal$U.lo $(SYS_LIBS)$/;"	m
libevent_extra_la_LINK	Makefile	/^libevent_extra_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
libevent_extra_la_OBJECTS	Makefile	/^libevent_extra_la_OBJECTS = $(am_libevent_extra_la_OBJECTS)$/;"	m
libevent_extra_la_SOURCES	Makefile	/^libevent_extra_la_SOURCES = $(EXTRA_SRC)$/;"	m
libevent_la_DEPENDENCIES	Makefile	/^libevent_la_DEPENDENCIES =  ${LIBOBJDIR}select$U.lo ${LIBOBJDIR}poll$U.lo ${LIBOBJDIR}epoll$U.lo ${LIBOBJDIR}signal$U.lo $(am__DEPENDENCIES_1)$/;"	m
libevent_la_LDFLAGS	Makefile	/^libevent_la_LDFLAGS = -release $(RELEASE) -version-info $(VERSION_INFO)$/;"	m
libevent_la_LIBADD	Makefile	/^libevent_la_LIBADD =  ${LIBOBJDIR}select$U.lo ${LIBOBJDIR}poll$U.lo ${LIBOBJDIR}epoll$U.lo ${LIBOBJDIR}signal$U.lo $(SYS_LIBS)$/;"	m
libevent_la_LINK	Makefile	/^libevent_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\$/;"	m
libevent_la_OBJECTS	Makefile	/^libevent_la_OBJECTS = $(am_libevent_la_OBJECTS)$/;"	m
libevent_la_SOURCES	Makefile	/^libevent_la_SOURCES = $(CORE_SRC) $(EXTRA_SRC)$/;"	m
libexecdir	Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	sample/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	test/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
line_count	event_rpcgen.py	/^line_count = 0$/;"	v
list	Makefile	/^	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \\$/;"	m
load_nameservers_from_registry	evdns.c	/^load_nameservers_from_registry(void)$/;"	f	file:	signature:(void)
load_nameservers_with_getnetworkparams	evdns.c	/^load_nameservers_with_getnetworkparams(void)$/;"	f	file:	signature:(void)
localedir	Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localedir	sample/Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localedir	test/Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localstatedir	Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	sample/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	test/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
log	evdns.c	424;"	d	file:
log_fn	log.c	/^static event_log_cb log_fn = NULL;$/;"	v	file:
logfn	evdns.c	/^logfn(int is_warn, const char *msg) {$/;"	f	signature:(int is_warn, const char *msg)
low	event.h	/^	size_t low;$/;"	m	struct:event_watermark	access:public
lt_ECHO	Makefile	/^lt_ECHO = echo$/;"	m
lt_ECHO	sample/Makefile	/^lt_ECHO = echo$/;"	m
lt_ECHO	test/Makefile	/^lt_ECHO = echo$/;"	m
main	config.guess	/^		main()$/;"	f
main	config.guess	/^	main ()$/;"	f
main	config.guess	/^main ()$/;"	f
main	evdns.c	/^main(int c, char **v) {$/;"	f	signature:(int c, char **v)
main	event_rpcgen.py	/^def main(argv):$/;"	f	access:public
main	sample/event-test.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sample/signal-test.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	sample/time-test.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/bench.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/regress.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/test-eof.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/test-init.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/test-time.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test/test-weof.c	/^main (int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main_callback	evdns.c	/^main_callback(int result, char type, int count, int ttl,$/;"	f	signature:(int result, char type, int count, int ttl, void *addrs, void *orig)
major	evhttp.h	/^	char major;			\/* HTTP Major number *\/$/;"	m	struct:evhttp_request	access:public
make_addrinfo	http.c	/^make_addrinfo(const char *address, u_short port)$/;"	f	file:	signature:(const char *address, u_short port)
man3dir	Makefile	/^man3dir = $(mandir)\/man3$/;"	m
man_MANS	Makefile	/^man_MANS = event.3 evdns.3$/;"	m
mandir	Makefile	/^mandir = ${datarootdir}\/man$/;"	m
mandir	sample/Makefile	/^mandir = ${datarootdir}\/man$/;"	m
mandir	test/Makefile	/^mandir = ${datarootdir}\/man$/;"	m
message_read_status	http-internal.h	/^enum message_read_status {$/;"	g
min_heap	min_heap.h	/^typedef struct min_heap$/;"	s
min_heap::a	min_heap.h	/^    unsigned n, a;$/;"	m	struct:min_heap	access:public
min_heap::n	min_heap.h	/^    unsigned n, a;$/;"	m	struct:min_heap	access:public
min_heap::p	min_heap.h	/^    struct event** p;$/;"	m	struct:min_heap	typeref:struct:min_heap::event	access:public
min_heap_ctor	min_heap.h	/^static inline void           min_heap_ctor(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_ctor	min_heap.h	/^void min_heap_ctor(min_heap_t* s) { s->p = 0; s->n = 0; s->a = 0; }$/;"	f	signature:(min_heap_t* s)
min_heap_dtor	min_heap.h	/^static inline void           min_heap_dtor(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_dtor	min_heap.h	/^void min_heap_dtor(min_heap_t* s) { free(s->p); }$/;"	f	signature:(min_heap_t* s)
min_heap_elem_greater	min_heap.h	/^int min_heap_elem_greater(struct event *a, struct event *b)$/;"	f	signature:(struct event *a, struct event *b)
min_heap_elem_greater	min_heap.h	/^static inline int            min_heap_elem_greater(struct event *a, struct event *b);$/;"	p	signature:(struct event *a, struct event *b)
min_heap_elem_init	min_heap.h	/^static inline void           min_heap_elem_init(struct event* e);$/;"	p	signature:(struct event* e)
min_heap_elem_init	min_heap.h	/^void min_heap_elem_init(struct event* e) { e->min_heap_idx = -1; }$/;"	f	signature:(struct event* e)
min_heap_empty	min_heap.h	/^int min_heap_empty(min_heap_t* s) { return 0u == s->n; }$/;"	f	signature:(min_heap_t* s)
min_heap_empty	min_heap.h	/^static inline int            min_heap_empty(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_erase	min_heap.h	/^int min_heap_erase(min_heap_t* s, struct event* e)$/;"	f	signature:(min_heap_t* s, struct event* e)
min_heap_erase	min_heap.h	/^static inline int            min_heap_erase(min_heap_t* s, struct event* e);$/;"	p	signature:(min_heap_t* s, struct event* e)
min_heap_idx	event.h	/^	unsigned int min_heap_idx;	\/* for managing timeouts *\/$/;"	m	struct:event	access:public
min_heap_pop	min_heap.h	/^static inline struct event*  min_heap_pop(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_pop	min_heap.h	/^struct event* min_heap_pop(min_heap_t* s)$/;"	f	signature:(min_heap_t* s)
min_heap_push	min_heap.h	/^int min_heap_push(min_heap_t* s, struct event* e)$/;"	f	signature:(min_heap_t* s, struct event* e)
min_heap_push	min_heap.h	/^static inline int            min_heap_push(min_heap_t* s, struct event* e);$/;"	p	signature:(min_heap_t* s, struct event* e)
min_heap_reserve	min_heap.h	/^int min_heap_reserve(min_heap_t* s, unsigned n)$/;"	f	signature:(min_heap_t* s, unsigned n)
min_heap_reserve	min_heap.h	/^static inline int            min_heap_reserve(min_heap_t* s, unsigned n);$/;"	p	signature:(min_heap_t* s, unsigned n)
min_heap_shift_down_	min_heap.h	/^static inline void           min_heap_shift_down_(min_heap_t* s, unsigned hole_index, struct event* e);$/;"	p	signature:(min_heap_t* s, unsigned hole_index, struct event* e)
min_heap_shift_down_	min_heap.h	/^void min_heap_shift_down_(min_heap_t* s, unsigned hole_index, struct event* e)$/;"	f	signature:(min_heap_t* s, unsigned hole_index, struct event* e)
min_heap_shift_up_	min_heap.h	/^static inline void           min_heap_shift_up_(min_heap_t* s, unsigned hole_index, struct event* e);$/;"	p	signature:(min_heap_t* s, unsigned hole_index, struct event* e)
min_heap_shift_up_	min_heap.h	/^void min_heap_shift_up_(min_heap_t* s, unsigned hole_index, struct event* e)$/;"	f	signature:(min_heap_t* s, unsigned hole_index, struct event* e)
min_heap_size	min_heap.h	/^static inline unsigned       min_heap_size(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_size	min_heap.h	/^unsigned min_heap_size(min_heap_t* s) { return s->n; }$/;"	f	signature:(min_heap_t* s)
min_heap_t	min_heap.h	/^} min_heap_t;$/;"	t	typeref:struct:min_heap
min_heap_top	min_heap.h	/^static inline struct event*  min_heap_top(min_heap_t* s);$/;"	p	signature:(min_heap_t* s)
min_heap_top	min_heap.h	/^struct event* min_heap_top(min_heap_t* s) { return s->n ? *s->p : 0; }$/;"	f	signature:(min_heap_t* s)
minor	evhttp.h	/^	char minor;			\/* HTTP Minor number *\/$/;"	m	struct:evhttp_request	access:public
misalign	event.h	/^	size_t misalign;$/;"	m	struct:evbuffer	access:public
mkdir_p	Makefile	/^mkdir_p = \/bin\/mkdir -p$/;"	m
mkdir_p	sample/Makefile	/^mkdir_p = \/bin\/mkdir -p$/;"	m
mkdir_p	test/Makefile	/^mkdir_p = \/bin\/mkdir -p$/;"	m
mkinstalldirs	Makefile	/^mkinstalldirs = $(SHELL) $(top_srcdir)\/mkinstalldirs$/;"	m
mkinstalldirs	sample/Makefile	/^mkinstalldirs = $(SHELL) $(top_srcdir)\/mkinstalldirs$/;"	m
mkinstalldirs	test/Makefile	/^mkinstalldirs = $(SHELL) $(top_srcdir)\/mkinstalldirs$/;"	m
msg	test/regress.gen.h	/^struct msg {$/;"	s
msg::attack_data	test/regress.gen.h	/^  struct kill* attack_data;$/;"	m	struct:msg	typeref:struct:msg::kill	access:public
msg::attack_set	test/regress.gen.h	/^  uint8_t attack_set;$/;"	m	struct:msg	access:public
msg::base	test/regress.gen.h	/^  struct msg_access_ *base;$/;"	m	struct:msg	typeref:struct:msg::msg_access_	access:public
msg::from_name_data	test/regress.gen.h	/^  char *from_name_data;$/;"	m	struct:msg	access:public
msg::from_name_set	test/regress.gen.h	/^  uint8_t from_name_set;$/;"	m	struct:msg	access:public
msg::run_data	test/regress.gen.h	/^  struct run **run_data;$/;"	m	struct:msg	typeref:struct:msg::run	access:public
msg::run_length	test/regress.gen.h	/^  int run_length;$/;"	m	struct:msg	access:public
msg::run_num_allocated	test/regress.gen.h	/^  int run_num_allocated;$/;"	m	struct:msg	access:public
msg::run_set	test/regress.gen.h	/^  uint8_t run_set;$/;"	m	struct:msg	access:public
msg::to_name_data	test/regress.gen.h	/^  char *to_name_data;$/;"	m	struct:msg	access:public
msg::to_name_set	test/regress.gen.h	/^  uint8_t to_name_set;$/;"	m	struct:msg	access:public
msg_	test/regress.gen.h	/^enum msg_ {$/;"	g
msg_access_	test/regress.gen.h	/^struct msg_access_ {$/;"	s
msg_access_::attack_assign	test/regress.gen.h	/^  int (*attack_assign)(struct msg *, const struct kill*);$/;"	m	struct:msg_access_	access:public
msg_access_::attack_get	test/regress.gen.h	/^  int (*attack_get)(struct msg *, struct kill* *);$/;"	m	struct:msg_access_	access:public
msg_access_::from_name_assign	test/regress.gen.h	/^  int (*from_name_assign)(struct msg *, const char *);$/;"	m	struct:msg_access_	access:public
msg_access_::from_name_get	test/regress.gen.h	/^  int (*from_name_get)(struct msg *, char * *);$/;"	m	struct:msg_access_	access:public
msg_access_::run_add	test/regress.gen.h	/^  struct run * (*run_add)(struct msg *);$/;"	m	struct:msg_access_	typeref:struct:msg_access_::run_add	access:public
msg_access_::run_assign	test/regress.gen.h	/^  int (*run_assign)(struct msg *, int, const struct run *);$/;"	m	struct:msg_access_	access:public
msg_access_::run_get	test/regress.gen.h	/^  int (*run_get)(struct msg *, int, struct run * *);$/;"	m	struct:msg_access_	access:public
msg_access_::to_name_assign	test/regress.gen.h	/^  int (*to_name_assign)(struct msg *, const char *);$/;"	m	struct:msg_access_	access:public
msg_access_::to_name_get	test/regress.gen.h	/^  int (*to_name_get)(struct msg *, char * *);$/;"	m	struct:msg_access_	access:public
msg_attack_assign	test/regress.gen.c	/^msg_attack_assign(struct msg *msg,$/;"	f	signature:(struct msg *msg, const struct kill* value)
msg_attack_assign	test/regress.gen.h	/^int msg_attack_assign(struct msg *, const struct kill*);$/;"	p	signature:(struct msg *, const struct kill*)
msg_attack_get	test/regress.gen.c	/^msg_attack_get(struct msg *msg, struct kill* *value)$/;"	f	signature:(struct msg *msg, struct kill* *value)
msg_attack_get	test/regress.gen.h	/^int msg_attack_get(struct msg *, struct kill* *);$/;"	p	signature:(struct msg *, struct kill* *)
msg_clear	test/regress.gen.c	/^msg_clear(struct msg *tmp)$/;"	f	signature:(struct msg *tmp)
msg_clear	test/regress.gen.h	/^void msg_clear(struct msg *);$/;"	p	signature:(struct msg *)
msg_complete	test/regress.gen.c	/^msg_complete(struct msg *msg)$/;"	f	signature:(struct msg *msg)
msg_complete	test/regress.gen.h	/^int msg_complete(struct msg *);$/;"	p	signature:(struct msg *)
msg_free	test/regress.gen.c	/^msg_free(struct msg *tmp)$/;"	f	signature:(struct msg *tmp)
msg_free	test/regress.gen.h	/^void msg_free(struct msg *);$/;"	p	signature:(struct msg *)
msg_from_name_assign	test/regress.gen.c	/^msg_from_name_assign(struct msg *msg,$/;"	f	signature:(struct msg *msg, const char * value)
msg_from_name_assign	test/regress.gen.h	/^int msg_from_name_assign(struct msg *, const char *);$/;"	p	signature:(struct msg *, const char *)
msg_from_name_get	test/regress.gen.c	/^msg_from_name_get(struct msg *msg, char * *value)$/;"	f	signature:(struct msg *msg, char * *value)
msg_from_name_get	test/regress.gen.h	/^int msg_from_name_get(struct msg *, char * *);$/;"	p	signature:(struct msg *, char * *)
msg_marshal	test/regress.gen.c	/^msg_marshal(struct evbuffer *evbuf, const struct msg *tmp){$/;"	f	signature:(struct evbuffer *evbuf, const struct msg *tmp)
msg_marshal	test/regress.gen.h	/^void msg_marshal(struct evbuffer *, const struct msg *);$/;"	p	signature:(struct evbuffer *, const struct msg *)
msg_new	test/regress.gen.c	/^msg_new(void)$/;"	f	signature:(void)
msg_new	test/regress.gen.h	/^struct msg *msg_new(void);$/;"	p	signature:(void)
msg_run_add	test/regress.gen.c	/^msg_run_add(struct msg *msg)$/;"	f	signature:(struct msg *msg)
msg_run_add	test/regress.gen.h	/^struct run * msg_run_add(struct msg *);$/;"	p	signature:(struct msg *)
msg_run_assign	test/regress.gen.c	/^msg_run_assign(struct msg *msg, int off,$/;"	f	signature:(struct msg *msg, int off, const struct run * value)
msg_run_assign	test/regress.gen.h	/^int msg_run_assign(struct msg *, int, const struct run *);$/;"	p	signature:(struct msg *, int, const struct run *)
msg_run_get	test/regress.gen.c	/^msg_run_get(struct msg *msg, int offset,$/;"	f	signature:(struct msg *msg, int offset, struct run * *value)
msg_run_get	test/regress.gen.h	/^int msg_run_get(struct msg *, int, struct run * *);$/;"	p	signature:(struct msg *, int, struct run * *)
msg_to_name_assign	test/regress.gen.c	/^msg_to_name_assign(struct msg *msg,$/;"	f	signature:(struct msg *msg, const char * value)
msg_to_name_assign	test/regress.gen.h	/^int msg_to_name_assign(struct msg *, const char *);$/;"	p	signature:(struct msg *, const char *)
msg_to_name_get	test/regress.gen.c	/^msg_to_name_get(struct msg *msg, char * *value)$/;"	f	signature:(struct msg *msg, char * *value)
msg_to_name_get	test/regress.gen.h	/^int msg_to_name_get(struct msg *, char * *);$/;"	p	signature:(struct msg *, char * *)
msg_unmarshal	test/regress.gen.c	/^msg_unmarshal(struct msg *tmp,  struct evbuffer *evbuf)$/;"	f	signature:(struct msg *tmp, struct evbuffer *evbuf)
msg_unmarshal	test/regress.gen.h	/^int msg_unmarshal(struct msg *, struct evbuffer *);$/;"	p	signature:(struct msg *, struct evbuffer *)
multiple_read_cb	test/regress.c	/^multiple_read_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
multiple_write_cb	test/regress.c	/^multiple_write_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
n	min_heap.h	/^    unsigned n, a;$/;"	m	struct:min_heap	access:public
n_additional	evdns.c	/^	int n_additional; \/* how many additional RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
n_answer	evdns.c	/^	int n_answer; \/* how many answer RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
n_authority	evdns.c	/^	int n_authority; \/* how many authority RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
n_labels	evdns.c	/^	int n_labels; \/* number of current entries *\/$/;"	m	struct:dnslabel_table	file:	access:public
n_server_responses	test/regress_dns.c	/^static int n_server_responses = 0;$/;"	v	file:
nactivequeues	event-internal.h	/^	int nactivequeues;$/;"	m	struct:event_base	access:public
name	evdns.c	/^			char name[HOST_NAME_MAX];$/;"	m	struct:reply::__anon1::__anon4	file:	access:public
name	evdns.c	/^	char *name; \/* name part of the RR *\/$/;"	m	struct:server_reply_item	file:	access:public
name	evdns.h	/^	char name[1];$/;"	m	struct:evdns_server_question	access:public
name	event-internal.h	/^	const char *name;$/;"	m	struct:eventop	access:public
name	evrpc.h	/^	char *name;$/;"	m	struct:evrpc_request_wrapper	access:public
name_from_addr	http.c	/^name_from_addr(struct sockaddr *sa, socklen_t salen,$/;"	f	file:	signature:(struct sockaddr *sa, socklen_t salen, char **phost, char **pport)
name_from_addr	http.c	/^static void name_from_addr(struct sockaddr *, socklen_t, char **, char **);$/;"	p	file:	signature:(struct sockaddr *, socklen_t, char **, char **)
name_parse	evdns.c	/^name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {$/;"	f	file:	signature:(u8 *packet, int length, int *idx, char *name_out, int name_out_len)
nameserver	evdns.c	/^struct nameserver {$/;"	s	file:
nameserver::address	evdns.c	/^	u32 address;$/;"	m	struct:nameserver	file:	access:public
nameserver::choked	evdns.c	/^	char choked;  \/* true if we have an EAGAIN from this server's socket *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::event	evdns.c	/^	struct event event;$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:	access:public
nameserver::failed_times	evdns.c	/^	int failed_times;  \/* number of times which we have given this server a chance *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::next	evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::nameserver	file:	access:public
nameserver::prev	evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::	file:	access:public
nameserver::socket	evdns.c	/^	int socket;  \/* a connected UDP socket *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::state	evdns.c	/^	char state;  \/* zero if we think that this server is down *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::timedout	evdns.c	/^	int timedout;  \/* number of times in a row a request has timed out *\/$/;"	m	struct:nameserver	file:	access:public
nameserver::timeout_event	evdns.c	/^	struct event timeout_event;  \/* used to keep the timeout for *\/$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:	access:public
nameserver::write_waiting	evdns.c	/^	char write_waiting;  \/* true if we are waiting for EV_WRITE events *\/$/;"	m	struct:nameserver	file:	access:public
nameserver_failed	evdns.c	/^nameserver_failed(struct nameserver *const ns, const char *msg) {$/;"	f	file:	signature:(struct nameserver *const ns, const char *msg)
nameserver_pick	evdns.c	/^nameserver_pick(void) {$/;"	f	file:	signature:(void)
nameserver_pick	evdns.c	/^static struct nameserver *nameserver_pick(void);$/;"	p	file:	signature:(void)
nameserver_probe_callback	evdns.c	/^nameserver_probe_callback(int result, char type, int count, int ttl, void *addresses, void *arg) {$/;"	f	file:	signature:(int result, char type, int count, int ttl, void *addresses, void *arg)
nameserver_probe_failed	evdns.c	/^nameserver_probe_failed(struct nameserver *const ns) {$/;"	f	file:	signature:(struct nameserver *const ns)
nameserver_prod_callback	evdns.c	/^nameserver_prod_callback(int fd, short events, void *arg) {$/;"	f	file:	signature:(int fd, short events, void *arg)
nameserver_read	evdns.c	/^nameserver_read(struct nameserver *ns) {$/;"	f	file:	signature:(struct nameserver *ns)
nameserver_ready_callback	evdns.c	/^nameserver_ready_callback(int fd, short events, void *arg) {$/;"	f	file:	signature:(int fd, short events, void *arg)
nameserver_ready_callback	evdns.c	/^static void nameserver_ready_callback(int fd, short events, void *arg);$/;"	p	file:	signature:(int fd, short events, void *arg)
nameserver_send_probe	evdns.c	/^nameserver_send_probe(struct nameserver *const ns) {$/;"	f	file:	signature:(struct nameserver *const ns)
nameserver_send_probe	evdns.c	/^static void nameserver_send_probe(struct nameserver *const ns);$/;"	p	file:	signature:(struct nameserver *const ns)
nameserver_up	evdns.c	/^nameserver_up(struct nameserver *const ns) {$/;"	f	file:	signature:(struct nameserver *const ns)
nameserver_write_waiting	evdns.c	/^nameserver_write_waiting(struct nameserver *ns, char waiting) {$/;"	f	file:	signature:(struct nameserver *ns, char waiting)
nchanges	devpoll.c	/^	int nchanges;$/;"	m	struct:devpollop	file:	access:public
nchanges	kqueue.c	/^	int nchanges;$/;"	m	struct:kqop	file:	access:public
ndots	evdns.c	/^	int ndots;$/;"	m	struct:search_state	file:	access:public
need_input_hook	test/regress_rpc.c	/^static int need_input_hook = 0;$/;"	v	file:
need_output_hook	test/regress_rpc.c	/^static int need_output_hook = 0;$/;"	v	file:
need_reinit	event-internal.h	/^	int need_reinit;$/;"	m	struct:eventop	access:public
nevents	devpoll.c	/^	int nevents;$/;"	m	struct:devpollop	file:	access:public
nevents	epoll.c	/^	int nevents;$/;"	m	struct:epollop	file:	access:public
nevents	kqueue.c	/^	int nevents;$/;"	m	struct:kqop	file:	access:public
next	evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::nameserver	file:	access:public
next	evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::request	file:	access:public
next	evdns.c	/^	struct search_domain *next;$/;"	m	struct:search_domain	typeref:struct:search_domain::search_domain	file:	access:public
next	evdns.c	/^	struct server_reply_item *next; \/* next item in sequence. *\/$/;"	m	struct:server_reply_item	typeref:struct:server_reply_item::server_reply_item	file:	access:public
next	event.h	/^	TAILQ_ENTRY(evkeyval) next;$/;"	m	struct:evkeyval	access:public
next	evhttp.h	/^	TAILQ_ENTRY(evhttp_request) next;$/;"	m	struct:evhttp_request	access:public
next	evrpc.h	/^	TAILQ_ENTRY(evrpc) next;$/;"	m	struct:evrpc	access:public
next	evrpc.h	/^	TAILQ_ENTRY(evrpc_request_wrapper) next;$/;"	m	struct:evrpc_request_wrapper	access:public
next	http-internal.h	/^	TAILQ_ENTRY(evhttp_cb) next;$/;"	m	struct:evhttp_cb	access:public
next_pending	evdns.c	/^	struct server_request *next_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:	access:public
nfds	devpoll.c	/^	int nfds;$/;"	m	struct:devpollop	file:	access:public
nfds	epoll.c	/^	int nfds;$/;"	m	struct:epollop	file:	access:public
nfds	poll.c	/^	int nfds;                       \/* Size of event_* *\/$/;"	m	struct:pollop	file:	access:public
noinst_PROGRAMS	sample/Makefile	/^noinst_PROGRAMS = event-test$(EXEEXT) time-test$(EXEEXT) \\$/;"	m
noinst_PROGRAMS	test/Makefile	/^noinst_PROGRAMS = test-init$(EXEEXT) test-eof$(EXEEXT) \\$/;"	m
nquestions	evdns.h	/^	int nquestions;$/;"	m	struct:evdns_server_request	access:public
nread	test/regress.c	/^	int nread;$/;"	m	struct:both	file:	access:public
ns	evdns.c	/^	struct nameserver *ns;  \/* the server which we last sent it *\/$/;"	m	struct:request	typeref:struct:request::nameserver	file:	access:public
ntoread	evhttp.h	/^	ev_int64_t ntoread;$/;"	m	struct:evhttp_request	access:public
num_active	test/bench.c	/^static int num_pipes, num_active, num_writes;$/;"	v	file:
num_domains	evdns.c	/^	int num_domains;$/;"	m	struct:search_state	file:	access:public
num_pipes	test/bench.c	/^static int num_pipes, num_active, num_writes;$/;"	v	file:
num_writes	test/bench.c	/^static int num_pipes, num_active, num_writes;$/;"	v	file:
off	event.h	/^	size_t off;$/;"	m	struct:evbuffer	access:public
oldincludedir	Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	sample/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	test/Makefile	/^oldincludedir = \/usr\/include$/;"	m
open	evdns.c	143;"	d	file:
orig_buffer	event.h	/^	u_char *orig_buffer;$/;"	m	struct:evbuffer	access:public
out_hooks	evrpc-internal.h	/^	struct evrpc_hook_list out_hooks;$/;"	m	struct:_evrpc_hooks	typeref:struct:_evrpc_hooks::evrpc_hook_list	access:public
output	event.h	/^	struct evbuffer *output;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::evbuffer	access:public
output_buffer	evhttp.h	/^	struct evbuffer *output_buffer;	\/* outgoing post or data *\/$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evbuffer	access:public
output_buffer	http-internal.h	/^	struct evbuffer *output_buffer;$/;"	m	struct:evhttp_connection	typeref:struct:evhttp_connection::evbuffer	access:public
output_headers	evhttp.h	/^	struct evkeyvalq *output_headers;$/;"	m	struct:evhttp_request	typeref:struct:evhttp_request::evkeyvalq	access:public
output_hooks	evrpc-internal.h	58;"	d
p	min_heap.h	/^    struct event** p;$/;"	m	struct:min_heap	typeref:struct:min_heap::event	access:public
pair	test/regress.c	/^int pair[2];$/;"	v
pair	test/test-weof.c	/^int pair[2];$/;"	v
pdfdir	Makefile	/^pdfdir = ${docdir}$/;"	m
pdfdir	sample/Makefile	/^pdfdir = ${docdir}$/;"	m
pdfdir	test/Makefile	/^pdfdir = ${docdir}$/;"	m
pending_replies	evdns.c	/^	struct server_request *pending_replies;$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::server_request	file:	access:public
pid	kqueue.c	/^	pid_t pid;$/;"	m	struct:kqop	file:	access:public
pipes	test/bench.c	/^static int *pipes;$/;"	v	file:
pkgdatadir	Makefile	/^pkgdatadir = $(datadir)\/libevent$/;"	m
pkgdatadir	sample/Makefile	/^pkgdatadir = $(datadir)\/libevent$/;"	m
pkgdatadir	test/Makefile	/^pkgdatadir = $(datadir)\/libevent$/;"	m
pkgincludedir	Makefile	/^pkgincludedir = $(includedir)\/libevent$/;"	m
pkgincludedir	sample/Makefile	/^pkgincludedir = $(includedir)\/libevent$/;"	m
pkgincludedir	test/Makefile	/^pkgincludedir = $(includedir)\/libevent$/;"	m
pkglibdir	Makefile	/^pkglibdir = $(libdir)\/libevent$/;"	m
pkglibdir	sample/Makefile	/^pkglibdir = $(libdir)\/libevent$/;"	m
pkglibdir	test/Makefile	/^pkglibdir = $(libdir)\/libevent$/;"	m
poll_add	poll.c	/^poll_add(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
poll_add	poll.c	/^static int poll_add		(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
poll_check_ok	poll.c	/^poll_check_ok(struct pollop *pop)$/;"	f	file:	signature:(struct pollop *pop)
poll_check_ok	poll.c	132;"	d	file:
poll_dealloc	poll.c	/^poll_dealloc(struct event_base *base, void *arg)$/;"	f	file:	signature:(struct event_base *base, void *arg)
poll_dealloc	poll.c	/^static void poll_dealloc	(struct event_base *, void *);$/;"	p	file:	signature:(struct event_base *, void *)
poll_del	poll.c	/^poll_del(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
poll_del	poll.c	/^static int poll_del		(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
poll_dispatch	poll.c	/^poll_dispatch(struct event_base *base, void *arg, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, void *arg, struct timeval *tv)
poll_dispatch	poll.c	/^static int poll_dispatch	(struct event_base *, void *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, void *, struct timeval *)
poll_init	poll.c	/^poll_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
poll_init	poll.c	/^static void *poll_init	(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
pollop	poll.c	/^struct pollop {$/;"	s	file:
pollop::event_count	poll.c	/^	int event_count;		\/* Highest number alloc *\/$/;"	m	struct:pollop	file:	access:public
pollop::event_r_back	poll.c	/^	struct event **event_r_back;$/;"	m	struct:pollop	typeref:struct:pollop::event	file:	access:public
pollop::event_set	poll.c	/^	struct pollfd *event_set;$/;"	m	struct:pollop	typeref:struct:pollop::pollfd	file:	access:public
pollop::event_w_back	poll.c	/^	struct event **event_w_back;$/;"	m	struct:pollop	typeref:struct:pollop::event	file:	access:public
pollop::fd_count	poll.c	/^	int fd_count;                   \/* Size of idxplus1_by_fd *\/$/;"	m	struct:pollop	file:	access:public
pollop::idxplus1_by_fd	poll.c	/^	int *idxplus1_by_fd; \/* Index into event_set by fd; we add 1 so$/;"	m	struct:pollop	file:	access:public
pollop::nfds	poll.c	/^	int nfds;                       \/* Size of event_* *\/$/;"	m	struct:pollop	file:	access:public
pollops	poll.c	/^const struct eventop pollops = {$/;"	v	typeref:struct:eventop
pool	evrpc.h	/^        struct evrpc_pool *pool;$/;"	m	struct:evrpc_request_wrapper	typeref:struct:evrpc_request_wrapper::evrpc_pool	access:public
port	evdns.c	/^	struct evdns_server_port *port; \/* Which port received this request on? *\/$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_port	file:	access:public
port	http-internal.h	/^	u_short port;$/;"	m	struct:evhttp_connection	access:public
pos	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:	access:public
prefix	Makefile	/^prefix = \/usr\/local$/;"	m
prefix	sample/Makefile	/^prefix = \/usr\/local$/;"	m
prefix	test/Makefile	/^prefix = \/usr\/local$/;"	m
prev	evdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::	file:	access:public
prev	evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::	file:	access:public
prev_pending	evdns.c	/^	struct server_request *prev_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:	access:public
process	evrpc-internal.h	/^	int (*process)(struct evhttp_request *, struct evbuffer *, void *);$/;"	m	struct:evrpc_hook	access:public
process_arg	evrpc-internal.h	/^	void *process_arg;$/;"	m	struct:evrpc_hook	access:public
profhz	compat/sys/_time.h	/^	int	profhz;		\/* profiling clock frequency *\/$/;"	m	struct:clockinfo	access:public
program_transform_name	Makefile	/^program_transform_name = s,x,x,$/;"	m
program_transform_name	sample/Makefile	/^program_transform_name = s,x,x,$/;"	m
program_transform_name	test/Makefile	/^program_transform_name = s,x,x,$/;"	m
prototypes	configure	/^   function prototypes and stuff, but not '\\xHH' hex character constants.$/;"	f
psdir	Makefile	/^psdir = ${docdir}$/;"	m
psdir	sample/Makefile	/^psdir = ${docdir}$/;"	m
psdir	test/Makefile	/^psdir = ${docdir}$/;"	m
ptr	evdns.c	/^		} ptr;$/;"	m	union:reply::__anon1	typeref:struct:reply::__anon1::__anon4	file:	access:public
questions	evdns.h	/^	struct evdns_server_question **questions;$/;"	m	struct:evdns_server_request	typeref:struct:evdns_server_request::evdns_server_question	access:public
rand_int	test/test-time.c	/^rand_int(int n)$/;"	f	file:	signature:(int n)
rbuf	test/regress.c	/^static char rbuf[4096];$/;"	v	file:
rcsid	strlcpy.c	/^static char *rcsid = "$OpenBSD: strlcpy.c,v 1.5 2001\/05\/13 15:40:16 deraadt Exp $";$/;"	v	file:
read	evdns.c	144;"	d	file:
read	test/regress.c	89;"	d	file:
read_cb	test/bench.c	/^read_cb(int fd, short which, void *arg)$/;"	f	file:	signature:(int fd, short which, void *arg)
read_cb	test/test-eof.c	/^read_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
read_event	WIN32-Code/win32.c	/^	struct event *read_event;$/;"	m	struct:event_entry	typeref:struct:event_entry::event	file:	access:public
read_once_cb	test/regress.c	/^read_once_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
read_pos	WIN32-Code/win32.c	/^	int read_pos;$/;"	m	struct:event_entry	file:	access:public
readcb	event.h	/^	evbuffercb readcb;$/;"	m	struct:bufferevent	access:public
readcb	test/regress.c	/^readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
readset_in	WIN32-Code/win32.c	/^	struct win_fd_set *readset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
readset_out	WIN32-Code/win32.c	/^	struct win_fd_set *readset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
realloc_fd_sets	WIN32-Code/win32.c	/^realloc_fd_sets(struct win32op *op, size_t new_size)$/;"	f	file:	signature:(struct win32op *op, size_t new_size)
reassociate	evport.c	/^reassociate(struct evport_data *epdp, struct fd_info *fdip, int fd)$/;"	f	file:	signature:(struct evport_data *epdp, struct fd_info *fdip, int fd)
refcnt	evdns.c	/^	int refcnt; \/* reference count. *\/$/;"	m	struct:evdns_server_port	file:	access:public
refcount	evdns.c	/^	int refcount;$/;"	m	struct:search_state	file:	access:public
registered_rpcs	evrpc-internal.h	/^	TAILQ_HEAD(evrpc_list, evrpc) registered_rpcs;$/;"	m	struct:evrpc_base	access:public
regress_DEPENDENCIES	test/Makefile	/^regress_DEPENDENCIES = ..\/libevent.la$/;"	m
regress_LDADD	test/Makefile	/^regress_LDADD = ..\/libevent.la$/;"	m
regress_OBJECTS	test/Makefile	/^regress_OBJECTS = $(am_regress_OBJECTS)$/;"	m
regress_SOURCES	test/Makefile	/^regress_SOURCES = regress.c regress.h regress_http.c regress_dns.c \\$/;"	m
reissue_count	evdns.c	/^	int reissue_count;$/;"	m	struct:request	file:	access:public
remote_host	evhttp.h	/^	char *remote_host;$/;"	m	struct:evhttp_request	access:public
remote_port	evhttp.h	/^	u_short remote_port;$/;"	m	struct:evhttp_request	access:public
reply	evdns.c	/^struct reply {$/;"	s	file:
reply	evrpc.h	/^	void *reply;$/;"	m	struct:evrpc_req_generic	access:public
reply	evrpc.h	/^	void *reply;$/;"	m	struct:evrpc_request_wrapper	access:public
reply::__anon1::__anon2::addrcount	evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon1::__anon2	file:	access:public
reply::__anon1::__anon2::addresses	evdns.c	/^			u32 addresses[MAX_ADDRS];$/;"	m	struct:reply::__anon1::__anon2	file:	access:public
reply::__anon1::__anon3::addrcount	evdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon1::__anon3	file:	access:public
reply::__anon1::__anon3::addresses	evdns.c	/^			struct in6_addr addresses[MAX_ADDRS];$/;"	m	struct:reply::__anon1::__anon3	typeref:struct:reply::__anon1::__anon3::in6_addr	file:	access:public
reply::__anon1::__anon4::name	evdns.c	/^			char name[HOST_NAME_MAX];$/;"	m	struct:reply::__anon1::__anon4	file:	access:public
reply::__anon1::a	evdns.c	/^		} a;$/;"	m	union:reply::__anon1	typeref:struct:reply::__anon1::__anon2	file:	access:public
reply::__anon1::aaaa	evdns.c	/^		} aaaa;$/;"	m	union:reply::__anon1	typeref:struct:reply::__anon1::__anon3	file:	access:public
reply::__anon1::ptr	evdns.c	/^		} ptr;$/;"	m	union:reply::__anon1	typeref:struct:reply::__anon1::__anon4	file:	access:public
reply::data	evdns.c	/^	} data;$/;"	m	struct:reply	typeref:union:reply::__anon1	file:	access:public
reply::have_answer	evdns.c	/^	unsigned int have_answer;$/;"	m	struct:reply	file:	access:public
reply::type	evdns.c	/^	unsigned int type;$/;"	m	struct:reply	file:	access:public
reply_callback	evdns.c	/^reply_callback(struct request *const req, u32 ttl, u32 err, struct reply *reply) {$/;"	f	file:	signature:(struct request *const req, u32 ttl, u32 err, struct reply *reply)
reply_clear	evrpc.h	/^	void (*reply_clear)(void *);$/;"	m	struct:evrpc_request_wrapper	access:public
reply_complete	evrpc.h	/^	int (*reply_complete)(void *);$/;"	m	struct:evrpc	access:public
reply_free	evrpc.h	/^	void (*reply_free)(void *);$/;"	m	struct:evrpc	access:public
reply_handle	evdns.c	/^reply_handle(struct request *const req, u16 flags, u32 ttl, struct reply *reply) {$/;"	f	file:	signature:(struct request *const req, u16 flags, u32 ttl, struct reply *reply)
reply_marshal	evrpc.h	/^	void (*reply_marshal)(struct evbuffer*, void *);$/;"	m	struct:evrpc	access:public
reply_new	evrpc.h	/^	void *(*reply_new)(void);$/;"	m	struct:evrpc	access:public
reply_parse	evdns.c	/^reply_parse(u8 *packet, int length) {$/;"	f	file:	signature:(u8 *packet, int length)
reply_unmarshal	evrpc.h	/^	int (*reply_unmarshal)(void *, struct evbuffer*);$/;"	m	struct:evrpc_request_wrapper	access:public
req	test/regress_http.c	/^	struct evhttp_request *req;$/;"	m	struct:chunk_req_state	typeref:struct:chunk_req_state::evhttp_request	file:	access:public
req_head	evdns.c	/^static struct request *req_head = NULL, *req_waiting_head = NULL;$/;"	v	typeref:struct:request	file:
req_waiting_head	evdns.c	/^static struct request *req_head = NULL, *req_waiting_head = NULL;$/;"	v	typeref:struct:	file:
request	evdns.c	/^	u8 *request;  \/* the dns packet data *\/$/;"	m	struct:request	file:	access:public
request	evdns.c	/^struct request {$/;"	s	file:
request	evrpc.h	/^	void *request;$/;"	m	struct:evrpc_req_generic	access:public
request	evrpc.h	/^	void *request;$/;"	m	struct:evrpc_request_wrapper	access:public
request::next	evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::request	file:	access:public
request::ns	evdns.c	/^	struct nameserver *ns;  \/* the server which we last sent it *\/$/;"	m	struct:request	typeref:struct:request::nameserver	file:	access:public
request::prev	evdns.c	/^	struct request *next, *prev;$/;"	m	struct:request	typeref:struct:request::	file:	access:public
request::reissue_count	evdns.c	/^	int reissue_count;$/;"	m	struct:request	file:	access:public
request::request	evdns.c	/^	u8 *request;  \/* the dns packet data *\/$/;"	m	struct:request	file:	access:public
request::request_appended	evdns.c	/^	char request_appended;  \/* true if the request pointer is data which follows this struct *\/$/;"	m	struct:request	file:	access:public
request::request_len	evdns.c	/^	unsigned int request_len;$/;"	m	struct:request	file:	access:public
request::request_type	evdns.c	/^	unsigned int request_type; \/* TYPE_PTR or TYPE_A *\/$/;"	m	struct:request	file:	access:public
request::search_flags	evdns.c	/^	int search_flags;$/;"	m	struct:request	file:	access:public
request::search_index	evdns.c	/^	int search_index;$/;"	m	struct:request	file:	access:public
request::search_origname	evdns.c	/^	char *search_origname;  \/* needs to be free()ed *\/$/;"	m	struct:request	file:	access:public
request::search_state	evdns.c	/^	struct search_state *search_state;$/;"	m	struct:request	typeref:struct:request::search_state	file:	access:public
request::timeout_event	evdns.c	/^	struct event timeout_event;$/;"	m	struct:request	typeref:struct:request::event	file:	access:public
request::trans_id	evdns.c	/^	u16 trans_id;  \/* the transaction id *\/$/;"	m	struct:request	file:	access:public
request::transmit_me	evdns.c	/^	char transmit_me;  \/* needs to be transmitted *\/$/;"	m	struct:request	file:	access:public
request::tx_count	evdns.c	/^	int tx_count;  \/* the number of times that this packet has been sent *\/$/;"	m	struct:request	file:	access:public
request::user_callback	evdns.c	/^	evdns_callback_type user_callback;$/;"	m	struct:request	file:	access:public
request::user_pointer	evdns.c	/^	void *user_pointer;  \/* the pointer given to us for this request *\/$/;"	m	struct:request	file:	access:public
request_appended	evdns.c	/^	char request_appended;  \/* true if the request pointer is data which follows this struct *\/$/;"	m	struct:request	file:	access:public
request_find_from_trans_id	evdns.c	/^request_find_from_trans_id(u16 trans_id) {$/;"	f	file:	signature:(u16 trans_id)
request_finished	evdns.c	/^request_finished(struct request *const req, struct request **head) {$/;"	f	file:	signature:(struct request *const req, struct request **head)
request_free	evrpc.h	/^	void (*request_free)(void *);$/;"	m	struct:evrpc	access:public
request_len	evdns.c	/^	unsigned int request_len;$/;"	m	struct:request	file:	access:public
request_marshal	evrpc.h	/^	void (*request_marshal)(struct evbuffer *, void *);$/;"	m	struct:evrpc_request_wrapper	access:public
request_new	evdns.c	/^request_new(int type, const char *name, int flags,$/;"	f	file:	signature:(int type, const char *name, int flags, evdns_callback_type callback, void *user_ptr)
request_new	evdns.c	/^static struct request *request_new(int type, const char *name, int flags, evdns_callback_type callback, void *ptr);$/;"	p	file:	signature:(int type, const char *name, int flags, evdns_callback_type callback, void *ptr)
request_new	evrpc.h	/^	void *(*request_new)(void);$/;"	m	struct:evrpc	access:public
request_parse	evdns.c	/^request_parse(u8 *packet, int length, struct evdns_server_port *port, struct sockaddr *addr, socklen_t addrlen)$/;"	f	file:	signature:(u8 *packet, int length, struct evdns_server_port *port, struct sockaddr *addr, socklen_t addrlen)
request_reissue	evdns.c	/^request_reissue(struct request *req) {$/;"	f	file:	signature:(struct request *req)
request_submit	evdns.c	/^request_submit(struct request *const req) {$/;"	f	file:	signature:(struct request *const req)
request_submit	evdns.c	/^static void request_submit(struct request *const req);$/;"	p	file:	signature:(struct request *const req)
request_trans_id_set	evdns.c	/^request_trans_id_set(struct request *const req, const u16 trans_id) {$/;"	f	file:	signature:(struct request *const req, const u16 trans_id)
request_type	evdns.c	/^	unsigned int request_type; \/* TYPE_PTR or TYPE_A *\/$/;"	m	struct:request	file:	access:public
request_unmarshal	evrpc.h	/^	int (*request_unmarshal)(void *, struct evbuffer *);$/;"	m	struct:evrpc	access:public
requests	evrpc-internal.h	/^	TAILQ_HEAD(evrpc_requestq, evrpc_request_wrapper) requests;$/;"	m	struct:evrpc_pool	access:public
requests	http-internal.h	/^	TAILQ_HEAD(evcon_requestq, evhttp_request) requests;$/;"	m	struct:evhttp_connection	access:public
resolv_conf_parse_line	evdns.c	/^resolv_conf_parse_line(char *const start, int flags) {$/;"	f	file:	signature:(char *const start, int flags)
response	evdns.c	/^	char *response;$/;"	m	struct:server_request	file:	access:public
response_code	evhttp.h	/^	int response_code;		\/* HTTP Response code *\/$/;"	m	struct:evhttp_request	access:public
response_code_line	evhttp.h	/^	char *response_code_line;	\/* Readable response *\/$/;"	m	struct:evhttp_request	access:public
response_len	evdns.c	/^	size_t response_len;$/;"	m	struct:server_request	file:	access:public
retry_cnt	http-internal.h	/^	int retry_cnt;			\/* retry count *\/$/;"	m	struct:evhttp_connection	access:public
retry_max	http-internal.h	/^	int retry_max;			\/* maximum number of retries *\/$/;"	m	struct:evhttp_connection	access:public
roff	test/regress.c	/^static int roff;$/;"	v	file:
rpc	evrpc.h	/^	struct evrpc *rpc;$/;"	m	struct:evrpc_req_generic	typeref:struct:evrpc_req_generic::evrpc	access:public
rpc_basic_client	test/regress_rpc.c	/^rpc_basic_client(void)$/;"	f	file:	signature:(void)
rpc_basic_message	test/regress_rpc.c	/^rpc_basic_message(void)$/;"	f	file:	signature:(void)
rpc_basic_queued_client	test/regress_rpc.c	/^rpc_basic_queued_client(void)$/;"	f	file:	signature:(void)
rpc_basic_test	test/regress_rpc.c	/^rpc_basic_test(void)$/;"	f	file:	signature:(void)
rpc_client_timeout	test/regress_rpc.c	/^rpc_client_timeout(void)$/;"	f	file:	signature:(void)
rpc_hook_add_header	test/regress_rpc.c	/^rpc_hook_add_header(struct evhttp_request *req,$/;"	f	file:	signature:(struct evhttp_request *req, struct evbuffer *evbuf, void *arg)
rpc_hook_remove_header	test/regress_rpc.c	/^rpc_hook_remove_header(struct evhttp_request *req,$/;"	f	file:	signature:(struct evhttp_request *req, struct evbuffer *evbuf, void *arg)
rpc_pool_with_connection	test/regress_rpc.c	/^rpc_pool_with_connection(short port)$/;"	f	file:	signature:(short port)
rpc_postrequest_done	test/regress_rpc.c	/^rpc_postrequest_done(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
rpc_postrequest_failure	test/regress_rpc.c	/^rpc_postrequest_failure(struct evhttp_request *req, void *arg)$/;"	f	file:	signature:(struct evhttp_request *req, void *arg)
rpc_setup	test/regress_rpc.c	/^rpc_setup(struct evhttp **phttp, short *pport, struct evrpc_base **pbase)$/;"	f	file:	signature:(struct evhttp **phttp, short *pport, struct evrpc_base **pbase)
rpc_suite	test/regress.h	/^void rpc_suite(void);$/;"	p	signature:(void)
rpc_suite	test/regress_rpc.c	/^rpc_suite(void)$/;"	f	signature:(void)
rpc_suite	test/regress_rpc.c	/^void rpc_suite(void);$/;"	p	file:	signature:(void)
rpc_teardown	test/regress_rpc.c	/^rpc_teardown(struct evrpc_base *base)$/;"	f	file:	signature:(struct evrpc_base *base)
rpc_test	test/regress.c	/^rpc_test(void)$/;"	f	file:	signature:(void)
run	test/regress.gen.h	/^struct run {$/;"	s
run::base	test/regress.gen.h	/^  struct run_access_ *base;$/;"	m	struct:run	typeref:struct:run::run_access_	access:public
run::fixed_bytes_data	test/regress.gen.h	/^  uint8_t fixed_bytes_data[24];$/;"	m	struct:run	access:public
run::fixed_bytes_set	test/regress.gen.h	/^  uint8_t fixed_bytes_set;$/;"	m	struct:run	access:public
run::how_data	test/regress.gen.h	/^  char *how_data;$/;"	m	struct:run	access:public
run::how_set	test/regress.gen.h	/^  uint8_t how_set;$/;"	m	struct:run	access:public
run::some_bytes_data	test/regress.gen.h	/^  uint8_t *some_bytes_data;$/;"	m	struct:run	access:public
run::some_bytes_length	test/regress.gen.h	/^  uint32_t some_bytes_length;$/;"	m	struct:run	access:public
run::some_bytes_set	test/regress.gen.h	/^  uint8_t some_bytes_set;$/;"	m	struct:run	access:public
run_	test/regress.gen.h	/^enum run_ {$/;"	g
run_access_	test/regress.gen.h	/^struct run_access_ {$/;"	s
run_access_::fixed_bytes_assign	test/regress.gen.h	/^  int (*fixed_bytes_assign)(struct run *, const uint8_t *);$/;"	m	struct:run_access_	access:public
run_access_::fixed_bytes_get	test/regress.gen.h	/^  int (*fixed_bytes_get)(struct run *, uint8_t **);$/;"	m	struct:run_access_	access:public
run_access_::how_assign	test/regress.gen.h	/^  int (*how_assign)(struct run *, const char *);$/;"	m	struct:run_access_	access:public
run_access_::how_get	test/regress.gen.h	/^  int (*how_get)(struct run *, char * *);$/;"	m	struct:run_access_	access:public
run_access_::some_bytes_assign	test/regress.gen.h	/^  int (*some_bytes_assign)(struct run *, const uint8_t *, uint32_t);$/;"	m	struct:run_access_	access:public
run_access_::some_bytes_get	test/regress.gen.h	/^  int (*some_bytes_get)(struct run *, uint8_t * *, uint32_t *);$/;"	m	struct:run_access_	access:public
run_add	test/regress.gen.h	/^  struct run * (*run_add)(struct msg *);$/;"	m	struct:msg_access_	typeref:struct:msg_access_::run_add	access:public
run_assign	test/regress.gen.h	/^  int (*run_assign)(struct msg *, int, const struct run *);$/;"	m	struct:msg_access_	access:public
run_clear	test/regress.gen.c	/^run_clear(struct run *tmp)$/;"	f	signature:(struct run *tmp)
run_clear	test/regress.gen.h	/^void run_clear(struct run *);$/;"	p	signature:(struct run *)
run_complete	test/regress.gen.c	/^run_complete(struct run *msg)$/;"	f	signature:(struct run *msg)
run_complete	test/regress.gen.h	/^int run_complete(struct run *);$/;"	p	signature:(struct run *)
run_data	test/regress.gen.h	/^  struct run **run_data;$/;"	m	struct:msg	typeref:struct:msg::run	access:public
run_fixed_bytes_assign	test/regress.gen.c	/^run_fixed_bytes_assign(struct run *msg, const uint8_t *value)$/;"	f	signature:(struct run *msg, const uint8_t *value)
run_fixed_bytes_assign	test/regress.gen.h	/^int run_fixed_bytes_assign(struct run *, const uint8_t *);$/;"	p	signature:(struct run *, const uint8_t *)
run_fixed_bytes_get	test/regress.gen.c	/^run_fixed_bytes_get(struct run *msg, uint8_t **value)$/;"	f	signature:(struct run *msg, uint8_t **value)
run_fixed_bytes_get	test/regress.gen.h	/^int run_fixed_bytes_get(struct run *, uint8_t **);$/;"	p	signature:(struct run *, uint8_t **)
run_free	test/regress.gen.c	/^run_free(struct run *tmp)$/;"	f	signature:(struct run *tmp)
run_free	test/regress.gen.h	/^void run_free(struct run *);$/;"	p	signature:(struct run *)
run_get	test/regress.gen.h	/^  int (*run_get)(struct msg *, int, struct run * *);$/;"	m	struct:msg_access_	access:public
run_how_assign	test/regress.gen.c	/^run_how_assign(struct run *msg,$/;"	f	signature:(struct run *msg, const char * value)
run_how_assign	test/regress.gen.h	/^int run_how_assign(struct run *, const char *);$/;"	p	signature:(struct run *, const char *)
run_how_get	test/regress.gen.c	/^run_how_get(struct run *msg, char * *value)$/;"	f	signature:(struct run *msg, char * *value)
run_how_get	test/regress.gen.h	/^int run_how_get(struct run *, char * *);$/;"	p	signature:(struct run *, char * *)
run_length	test/regress.gen.h	/^  int run_length;$/;"	m	struct:msg	access:public
run_marshal	test/regress.gen.c	/^run_marshal(struct evbuffer *evbuf, const struct run *tmp){$/;"	f	signature:(struct evbuffer *evbuf, const struct run *tmp)
run_marshal	test/regress.gen.h	/^void run_marshal(struct evbuffer *, const struct run *);$/;"	p	signature:(struct evbuffer *, const struct run *)
run_new	test/regress.gen.c	/^run_new(void)$/;"	f	signature:(void)
run_new	test/regress.gen.h	/^struct run *run_new(void);$/;"	p	signature:(void)
run_num_allocated	test/regress.gen.h	/^  int run_num_allocated;$/;"	m	struct:msg	access:public
run_once	test/bench.c	/^run_once(void)$/;"	f	file:	signature:(void)
run_set	test/regress.gen.h	/^  uint8_t run_set;$/;"	m	struct:msg	access:public
run_some_bytes_assign	test/regress.gen.c	/^run_some_bytes_assign(struct run *msg, const uint8_t * value, uint32_t len)$/;"	f	signature:(struct run *msg, const uint8_t * value, uint32_t len)
run_some_bytes_assign	test/regress.gen.h	/^int run_some_bytes_assign(struct run *, const uint8_t *, uint32_t);$/;"	p	signature:(struct run *, const uint8_t *, uint32_t)
run_some_bytes_get	test/regress.gen.c	/^run_some_bytes_get(struct run *msg, uint8_t * *value, uint32_t *plen)$/;"	f	signature:(struct run *msg, uint8_t * *value, uint32_t *plen)
run_some_bytes_get	test/regress.gen.h	/^int run_some_bytes_get(struct run *, uint8_t * *, uint32_t *);$/;"	p	signature:(struct run *, uint8_t * *, uint32_t *)
run_unmarshal	test/regress.gen.c	/^run_unmarshal(struct run *tmp,  struct evbuffer *evbuf)$/;"	f	signature:(struct run *tmp, struct evbuffer *evbuf)
run_unmarshal	test/regress.gen.h	/^int run_unmarshal(struct run *, struct evbuffer *);$/;"	p	signature:(struct run *, struct evbuffer *)
s6_addr	evdns.c	/^	u8 s6_addr[16];$/;"	m	struct:in6_addr	file:	access:public
sbindir	Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	sample/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	test/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
search_domain	evdns.c	/^struct search_domain {$/;"	s	file:
search_domain::len	evdns.c	/^	int len;$/;"	m	struct:search_domain	file:	access:public
search_domain::next	evdns.c	/^	struct search_domain *next;$/;"	m	struct:search_domain	typeref:struct:search_domain::search_domain	file:	access:public
search_flags	evdns.c	/^	int search_flags;$/;"	m	struct:request	file:	access:public
search_index	evdns.c	/^	int search_index;$/;"	m	struct:request	file:	access:public
search_make_new	evdns.c	/^search_make_new(const struct search_state *const state, int n, const char *const base_name) {$/;"	f	file:	signature:(const struct search_state *const state, int n, const char *const base_name)
search_origname	evdns.c	/^	char *search_origname;  \/* needs to be free()ed *\/$/;"	m	struct:request	file:	access:public
search_postfix_add	evdns.c	/^search_postfix_add(const char *domain) {$/;"	f	file:	signature:(const char *domain)
search_postfix_clear	evdns.c	/^search_postfix_clear(void) {$/;"	f	file:	signature:(void)
search_request_finished	evdns.c	/^search_request_finished(struct request *const req) {$/;"	f	file:	signature:(struct request *const req)
search_request_finished	evdns.c	/^static void search_request_finished(struct request *const);$/;"	p	file:	signature:(struct request *const)
search_request_new	evdns.c	/^search_request_new(int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg) {$/;"	f	file:	signature:(int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg)
search_request_new	evdns.c	/^static int search_request_new(int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg);$/;"	p	file:	signature:(int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg)
search_reverse	evdns.c	/^search_reverse(void) {$/;"	f	file:	signature:(void)
search_set_from_hostname	evdns.c	/^search_set_from_hostname(void) {$/;"	f	file:	signature:(void)
search_state	evdns.c	/^	struct search_state *search_state;$/;"	m	struct:request	typeref:struct:request::search_state	file:	access:public
search_state	evdns.c	/^struct search_state {$/;"	s	file:
search_state::head	evdns.c	/^	struct search_domain *head;$/;"	m	struct:search_state	typeref:struct:search_state::search_domain	file:	access:public
search_state::ndots	evdns.c	/^	int ndots;$/;"	m	struct:search_state	file:	access:public
search_state::num_domains	evdns.c	/^	int num_domains;$/;"	m	struct:search_state	file:	access:public
search_state::refcount	evdns.c	/^	int refcount;$/;"	m	struct:search_state	file:	access:public
search_state_decref	evdns.c	/^search_state_decref(struct search_state *const state) {$/;"	f	file:	signature:(struct search_state *const state)
search_state_new	evdns.c	/^search_state_new(void) {$/;"	f	file:	signature:(void)
search_try_next	evdns.c	/^search_try_next(struct request *const req) {$/;"	f	file:	signature:(struct request *const req)
search_try_next	evdns.c	/^static int search_try_next(struct request *const req);$/;"	p	file:	signature:(struct request *const req)
select_add	select.c	/^select_add(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
select_add	select.c	/^static int select_add		(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
select_dealloc	select.c	/^select_dealloc(struct event_base *base, void *arg)$/;"	f	file:	signature:(struct event_base *base, void *arg)
select_dealloc	select.c	/^static void select_dealloc     (struct event_base *, void *);$/;"	p	file:	signature:(struct event_base *, void *)
select_del	select.c	/^select_del(void *arg, struct event *ev)$/;"	f	file:	signature:(void *arg, struct event *ev)
select_del	select.c	/^static int select_del		(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
select_dispatch	select.c	/^select_dispatch(struct event_base *base, void *arg, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, void *arg, struct timeval *tv)
select_dispatch	select.c	/^static int select_dispatch	(struct event_base *, void *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, void *, struct timeval *)
select_init	select.c	/^select_init(struct event_base *base)$/;"	f	file:	signature:(struct event_base *base)
select_init	select.c	/^static void *select_init	(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
select_resize	select.c	/^select_resize(struct selectop *sop, int fdsz)$/;"	f	file:	signature:(struct selectop *sop, int fdsz)
select_resize	select.c	/^static int select_resize(struct selectop *sop, int fdsz);$/;"	p	file:	signature:(struct selectop *sop, int fdsz)
selectop	select.c	/^struct selectop {$/;"	s	file:
selectop::event_fds	select.c	/^	int event_fds;		\/* Highest fd in fd set *\/$/;"	m	struct:selectop	file:	access:public
selectop::event_fdsz	select.c	/^	int event_fdsz;$/;"	m	struct:selectop	file:	access:public
selectop::event_r_by_fd	select.c	/^	struct event **event_r_by_fd;$/;"	m	struct:selectop	typeref:struct:selectop::event	file:	access:public
selectop::event_readset_in	select.c	/^	fd_set *event_readset_in;$/;"	m	struct:selectop	file:	access:public
selectop::event_readset_out	select.c	/^	fd_set *event_readset_out;$/;"	m	struct:selectop	file:	access:public
selectop::event_w_by_fd	select.c	/^	struct event **event_w_by_fd;$/;"	m	struct:selectop	typeref:struct:selectop::event	file:	access:public
selectop::event_writeset_in	select.c	/^	fd_set *event_writeset_in;$/;"	m	struct:selectop	file:	access:public
selectop::event_writeset_out	select.c	/^	fd_set *event_writeset_out;$/;"	m	struct:selectop	file:	access:public
selectops	select.c	/^const struct eventop selectops = {$/;"	v	typeref:struct:eventop
server_head	evdns.c	/^static struct nameserver *server_head = NULL;$/;"	v	typeref:struct:nameserver	file:
server_port_flush	evdns.c	/^server_port_flush(struct evdns_server_port *port)$/;"	f	file:	signature:(struct evdns_server_port *port)
server_port_free	evdns.c	/^server_port_free(struct evdns_server_port *port)$/;"	f	file:	signature:(struct evdns_server_port *port)
server_port_free	evdns.c	/^static void server_port_free(struct evdns_server_port *port);$/;"	p	file:	signature:(struct evdns_server_port *port)
server_port_read	evdns.c	/^server_port_read(struct evdns_server_port *s) {$/;"	f	file:	signature:(struct evdns_server_port *s)
server_port_ready_callback	evdns.c	/^server_port_ready_callback(int fd, short events, void *arg) {$/;"	f	file:	signature:(int fd, short events, void *arg)
server_port_ready_callback	evdns.c	/^static void server_port_ready_callback(int fd, short events, void *arg);$/;"	p	file:	signature:(int fd, short events, void *arg)
server_reply_item	evdns.c	/^struct server_reply_item {$/;"	s	file:
server_reply_item::class	evdns.c	/^	u16 class : 16; \/* The RR class (usually CLASS_INET) *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::data	evdns.c	/^	void *data; \/* The contents of the RR *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::datalen	evdns.c	/^	u16 datalen; \/* Length of data; -1 if data is a label *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::is_name	evdns.c	/^	char is_name; \/* True iff data is a label *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::name	evdns.c	/^	char *name; \/* name part of the RR *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::next	evdns.c	/^	struct server_reply_item *next; \/* next item in sequence. *\/$/;"	m	struct:server_reply_item	typeref:struct:server_reply_item::server_reply_item	file:	access:public
server_reply_item::ttl	evdns.c	/^	u32 ttl; \/* The RR TTL *\/$/;"	m	struct:server_reply_item	file:	access:public
server_reply_item::type	evdns.c	/^	u16 type : 16; \/* The RR type *\/$/;"	m	struct:server_reply_item	file:	access:public
server_request	evdns.c	/^struct server_request {$/;"	s	file:
server_request::additional	evdns.c	/^	struct server_reply_item *additional; \/* linked list of additional RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
server_request::addr	evdns.c	/^	struct sockaddr_storage addr; \/* Where to send the response *\/$/;"	m	struct:server_request	typeref:struct:server_request::sockaddr_storage	file:	access:public
server_request::addrlen	evdns.c	/^	socklen_t addrlen; \/* length of addr *\/$/;"	m	struct:server_request	file:	access:public
server_request::answer	evdns.c	/^	struct server_reply_item *answer; \/* linked list of answer RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
server_request::authority	evdns.c	/^	struct server_reply_item *authority; \/* linked list of authority RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:	access:public
server_request::base	evdns.c	/^	struct evdns_server_request base;$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_request	file:	access:public
server_request::n_additional	evdns.c	/^	int n_additional; \/* how many additional RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
server_request::n_answer	evdns.c	/^	int n_answer; \/* how many answer RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
server_request::n_authority	evdns.c	/^	int n_authority; \/* how many authority RRs have been set? *\/$/;"	m	struct:server_request	file:	access:public
server_request::next_pending	evdns.c	/^	struct server_request *next_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:	access:public
server_request::port	evdns.c	/^	struct evdns_server_port *port; \/* Which port received this request on? *\/$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_port	file:	access:public
server_request::prev_pending	evdns.c	/^	struct server_request *prev_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:	access:public
server_request::response	evdns.c	/^	char *response;$/;"	m	struct:server_request	file:	access:public
server_request::response_len	evdns.c	/^	size_t response_len;$/;"	m	struct:server_request	file:	access:public
server_request::trans_id	evdns.c	/^	u16 trans_id; \/* Transaction id. *\/$/;"	m	struct:server_request	file:	access:public
server_request_free	evdns.c	/^server_request_free(struct server_request *req)$/;"	f	file:	signature:(struct server_request *req)
server_request_free	evdns.c	/^static int server_request_free(struct server_request *req);$/;"	p	file:	signature:(struct server_request *req)
server_request_free_answers	evdns.c	/^server_request_free_answers(struct server_request *req)$/;"	f	file:	signature:(struct server_request *req)
server_request_free_answers	evdns.c	/^static void server_request_free_answers(struct server_request *req);$/;"	p	file:	signature:(struct server_request *req)
setup	test/test.sh	/^setup () {$/;"	f
setup_test	test/regress.c	/^setup_test(const char *name)$/;"	f	file:	signature:(const char *name)
sh_old	evsignal.h	/^	ev_sighandler_t **sh_old;$/;"	m	struct:evsignal_info	access:public
sh_old	evsignal.h	/^	struct sigaction **sh_old;$/;"	m	struct:evsignal_info	typeref:struct:evsignal_info::sigaction	access:public
sh_old_max	evsignal.h	/^	int sh_old_max;$/;"	m	struct:evsignal_info	access:public
sharedstatedir	Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	sample/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	test/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sig	event-internal.h	/^	struct evsignal_info sig;$/;"	m	struct:event_base	typeref:struct:event_base::evsignal_info	access:public
signal_add	event.h	509;"	d
signal_caught	WIN32-Code/win32.c	/^volatile sig_atomic_t signal_caught = 0;$/;"	v
signal_cb	sample/signal-test.c	/^signal_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
signal_cb	test/regress.c	/^signal_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
signal_cb_sa	test/regress.c	/^signal_cb_sa(int sig)$/;"	f	file:	signature:(int sig)
signal_del	event.h	512;"	d
signal_initialized	event.h	514;"	d
signal_pending	event.h	513;"	d
signal_set	event.h	510;"	d
signal_test_DEPENDENCIES	sample/Makefile	/^signal_test_DEPENDENCIES = ..\/libevent.la$/;"	m
signal_test_LDADD	sample/Makefile	/^signal_test_LDADD = $(LDADD)$/;"	m
signal_test_OBJECTS	sample/Makefile	/^signal_test_OBJECTS = signal-test.$(OBJEXT)$/;"	m
signal_test_SOURCES	sample/Makefile	/^signal_test_SOURCES = signal-test.c$/;"	m
signal_test_sources	sample/Makefile	/^signal_test_sources = signal-test.c$/;"	m
simple_read_cb	test/regress.c	/^simple_read_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
simple_write_cb	test/regress.c	/^simple_write_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
sock	WIN32-Code/win32.c	/^	SOCKET sock;$/;"	m	struct:event_entry	file:	access:public
socket	evdns.c	/^	int socket;  \/* a connected UDP socket *\/$/;"	m	struct:nameserver	file:	access:public
socket	evdns.c	/^	int socket; \/* socket we use to read queries and write replies. *\/$/;"	m	struct:evdns_server_port	file:	access:public
socket_connect	http.c	/^socket_connect(int fd, const char *address, unsigned short port)$/;"	f	file:	signature:(int fd, const char *address, unsigned short port)
socket_connect	http.c	/^static int socket_connect(int fd, const char *address, unsigned short port);$/;"	p	file:	signature:(int fd, const char *address, unsigned short port)
sockets	http-internal.h	/^	TAILQ_HEAD(boundq, evhttp_bound_socket) sockets;$/;"	m	struct:evhttp	access:public
socklen_t	WIN32-Code/config.h	231;"	d
some_bytes_assign	test/regress.gen.h	/^  int (*some_bytes_assign)(struct run *, const uint8_t *, uint32_t);$/;"	m	struct:run_access_	access:public
some_bytes_data	test/regress.gen.h	/^  uint8_t *some_bytes_data;$/;"	m	struct:run	access:public
some_bytes_get	test/regress.gen.h	/^  int (*some_bytes_get)(struct run *, uint8_t * *, uint32_t *);$/;"	m	struct:run_access_	access:public
some_bytes_length	test/regress.gen.h	/^  uint32_t some_bytes_length;$/;"	m	struct:run	access:public
some_bytes_set	test/regress.gen.h	/^  uint8_t some_bytes_set;$/;"	m	struct:run	access:public
srcdir	Makefile	/^srcdir = .$/;"	m
srcdir	sample/Makefile	/^srcdir = .$/;"	m
srcdir	test/Makefile	/^srcdir = .$/;"	m
state	evdns.c	/^	char state;  \/* zero if we think that this server is down *\/$/;"	m	struct:nameserver	file:	access:public
state	http-internal.h	/^	enum evhttp_connection_state state;$/;"	m	struct:evhttp_connection	typeref:enum:evhttp_connection::evhttp_connection_state	access:public
stathz	compat/sys/_time.h	/^	int	stathz;		\/* statistics clock frequency *\/$/;"	m	struct:clockinfo	access:public
strcasecmp	http.c	93;"	d	file:
strdup	evdns.c	146;"	d	file:
strdup	http.c	95;"	d	file:
string_num_dots	evdns.c	/^string_num_dots(const char *s) {$/;"	f	file:	signature:(const char *s)
strlcpy	strlcpy-internal.h	15;"	d
strncasecmp	http.c	94;"	d	file:
strsep	http.c	/^strsep(char **s, const char *del)$/;"	f	file:	signature:(char **s, const char *del)
strtoint	evdns.c	/^static int strtoint(const char *const str);$/;"	p	file:	signature:(const char *const str)
strtoint	evdns.c	/^strtoint(const char *const str) {$/;"	f	file:	signature:(const char *const str)
strtoint_clipped	evdns.c	/^strtoint_clipped(const char *const str, int min, int max)$/;"	f	file:	signature:(const char *const str, int min, int max)
strtok_r	evdns.c	/^strtok_r(char *s, const char *delim, char **state) {$/;"	f	file:	signature:(char *s, const char *delim, char **state)
subdir	Makefile	/^subdir = .$/;"	m
subdir	sample/Makefile	/^subdir = sample$/;"	m
subdir	test/Makefile	/^subdir = test$/;"	m
sysconfdir	Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	sample/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	test/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z$/;"	m
tardir	Makefile	/^	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma$/;"	m
target_alias	Makefile	/^target_alias = $/;"	m
target_alias	sample/Makefile	/^target_alias = $/;"	m
target_alias	test/Makefile	/^target_alias = $/;"	m
tcalled	test/regress.c	/^static struct timeval tcalled;$/;"	v	typeref:struct:timeval	file:
test	test/test.sh	/^test () {$/;"	f
test_bufferevent	test/regress.c	/^test_bufferevent(void)$/;"	f	file:	signature:(void)
test_bufferevent_watermarks	test/regress.c	/^test_bufferevent_watermarks(void)$/;"	f	file:	signature:(void)
test_combined	test/regress.c	/^test_combined(void)$/;"	f	file:	signature:(void)
test_eof_DEPENDENCIES	test/Makefile	/^test_eof_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_eof_LDADD	test/Makefile	/^test_eof_LDADD = ..\/libevent_core.la$/;"	m
test_eof_OBJECTS	test/Makefile	/^test_eof_OBJECTS = $(am_test_eof_OBJECTS)$/;"	m
test_eof_SOURCES	test/Makefile	/^test_eof_SOURCES = test-eof.c$/;"	m
test_evbuffer	test/regress.c	/^test_evbuffer(void) {$/;"	f	file:	signature:(void)
test_evbuffer_find	test/regress.c	/^test_evbuffer_find(void)$/;"	f	file:	signature:(void)
test_event_base_new	test/regress.c	/^test_event_base_new(void)$/;"	f	file:	signature:(void)
test_evutil_strtoll	test/regress.c	/^test_evutil_strtoll(void)$/;"	f	file:	signature:(void)
test_fork	test/regress.c	/^test_fork(void)$/;"	f	file:	signature:(void)
test_free_active_base	test/regress.c	/^test_free_active_base(void)$/;"	f	file:	signature:(void)
test_immediatesignal	test/regress.c	/^test_immediatesignal(void)$/;"	f	file:	signature:(void)
test_init_DEPENDENCIES	test/Makefile	/^test_init_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_init_LDADD	test/Makefile	/^test_init_LDADD = ..\/libevent_core.la$/;"	m
test_init_OBJECTS	test/Makefile	/^test_init_OBJECTS = $(am_test_init_OBJECTS)$/;"	m
test_init_SOURCES	test/Makefile	/^test_init_SOURCES = test-init.c$/;"	m
test_loopbreak	test/regress.c	/^test_loopbreak(void)$/;"	f	file:	signature:(void)
test_loopexit	test/regress.c	/^test_loopexit(void)$/;"	f	file:	signature:(void)
test_loopexit_multiple	test/regress.c	/^test_loopexit_multiple(void)$/;"	f	file:	signature:(void)
test_multiple	test/regress.c	/^test_multiple(void)$/;"	f	file:	signature:(void)
test_multiple_cb	test/regress.c	/^test_multiple_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
test_multiple_events_for_same_fd	test/regress.c	/^test_multiple_events_for_same_fd(void)$/;"	f	file:	signature:(void)
test_multiplesignal	test/regress.c	/^test_multiplesignal(void)$/;"	f	file:	signature:(void)
test_ok	test/regress.c	/^int test_ok;$/;"	v
test_okay	test/test-eof.c	/^int test_okay = 1;$/;"	v
test_okay	test/test-weof.c	/^int test_okay = 1;$/;"	v
test_persistent	test/regress.c	/^test_persistent(void)$/;"	f	file:	signature:(void)
test_pri_event	test/regress.c	/^struct test_pri_event {$/;"	s	file:
test_pri_event::count	test/regress.c	/^	int count;$/;"	m	struct:test_pri_event	file:	access:public
test_pri_event::ev	test/regress.c	/^	struct event ev;$/;"	m	struct:test_pri_event	typeref:struct:test_pri_event::event	file:	access:public
test_priorities	test/regress.c	/^test_priorities(int npriorities)$/;"	f	file:	signature:(int npriorities)
test_priorities_cb	test/regress.c	/^test_priorities_cb(int fd, short what, void *arg)$/;"	f	file:	signature:(int fd, short what, void *arg)
test_signal_assert	test/regress.c	/^test_signal_assert(void)$/;"	f	file:	signature:(void)
test_signal_dealloc	test/regress.c	/^test_signal_dealloc(void)$/;"	f	file:	signature:(void)
test_signal_pipeloss	test/regress.c	/^test_signal_pipeloss(void)$/;"	f	file:	signature:(void)
test_signal_restore	test/regress.c	/^test_signal_restore(void)$/;"	f	file:	signature:(void)
test_signal_switchbase	test/regress.c	/^test_signal_switchbase(void)$/;"	f	file:	signature:(void)
test_simpleread	test/regress.c	/^test_simpleread(void)$/;"	f	file:	signature:(void)
test_simplesignal	test/regress.c	/^test_simplesignal(void)$/;"	f	file:	signature:(void)
test_simpletimeout	test/regress.c	/^test_simpletimeout(void)$/;"	f	file:	signature:(void)
test_simplewrite	test/regress.c	/^test_simplewrite(void)$/;"	f	file:	signature:(void)
test_time_DEPENDENCIES	test/Makefile	/^test_time_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_time_LDADD	test/Makefile	/^test_time_LDADD = ..\/libevent_core.la$/;"	m
test_time_OBJECTS	test/Makefile	/^test_time_OBJECTS = $(am_test_time_OBJECTS)$/;"	m
test_time_SOURCES	test/Makefile	/^test_time_SOURCES = test-time.c$/;"	m
test_want_only_once	test/regress.c	/^test_want_only_once(void)$/;"	f	file:	signature:(void)
test_weof_DEPENDENCIES	test/Makefile	/^test_weof_DEPENDENCIES = ..\/libevent_core.la$/;"	m
test_weof_LDADD	test/Makefile	/^test_weof_LDADD = ..\/libevent_core.la$/;"	m
test_weof_OBJECTS	test/Makefile	/^test_weof_OBJECTS = $(am_test_weof_OBJECTS)$/;"	m
test_weof_SOURCES	test/Makefile	/^test_weof_SOURCES = test-weof.c$/;"	m
tick	compat/sys/_time.h	/^	int	tick;		\/* micro-seconds per hz tick *\/$/;"	m	struct:clockinfo	access:public
tickadj	compat/sys/_time.h	/^	int	tickadj;	\/* clock skew rate for adjtime() *\/$/;"	m	struct:clockinfo	access:public
time_cb	test/test-time.c	/^time_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
time_test_DEPENDENCIES	sample/Makefile	/^time_test_DEPENDENCIES = ..\/libevent.la$/;"	m
time_test_LDADD	sample/Makefile	/^time_test_LDADD = $(LDADD)$/;"	m
time_test_OBJECTS	sample/Makefile	/^time_test_OBJECTS = time-test.$(OBJEXT)$/;"	m
time_test_SOURCES	sample/Makefile	/^time_test_SOURCES = time-test.c$/;"	m
time_test_sources	sample/Makefile	/^time_test_sources = time-test.c$/;"	m
timedout	evdns.c	/^	int timedout;  \/* number of times in a row a request has timed out *\/$/;"	m	struct:nameserver	file:	access:public
timeheap	event-internal.h	/^	struct min_heap timeheap;$/;"	m	struct:event_base	typeref:struct:event_base::min_heap	access:public
timeout	evrpc-internal.h	/^	int timeout;$/;"	m	struct:evrpc_pool	access:public
timeout	http-internal.h	/^	int timeout;			\/* timeout in seconds for events *\/$/;"	m	struct:evhttp_connection	access:public
timeout	http-internal.h	/^        int timeout;$/;"	m	struct:evhttp	access:public
timeout_add	event.h	486;"	d
timeout_cb	sample/time-test.c	/^timeout_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
timeout_cb	test/regress.c	/^timeout_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
timeout_correct	event.c	/^static void	timeout_correct(struct event_base *, struct timeval *);$/;"	p	file:	signature:(struct event_base *, struct timeval *)
timeout_correct	event.c	/^timeout_correct(struct event_base *base, struct timeval *tv)$/;"	f	file:	signature:(struct event_base *base, struct timeval *tv)
timeout_del	event.h	504;"	d
timeout_event	evdns.c	/^	struct event timeout_event;  \/* used to keep the timeout for *\/$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:	access:public
timeout_event	evdns.c	/^	struct event timeout_event;$/;"	m	struct:request	typeref:struct:request::event	file:	access:public
timeout_initialized	event.h	507;"	d
timeout_initialized	http.c	83;"	d	file:
timeout_next	event.c	/^static int	timeout_next(struct event_base *, struct timeval **);$/;"	p	file:	signature:(struct event_base *, struct timeval **)
timeout_next	event.c	/^timeout_next(struct event_base *base, struct timeval **tv_p)$/;"	f	file:	signature:(struct event_base *base, struct timeval **tv_p)
timeout_pending	event.h	506;"	d
timeout_pending	http.c	82;"	d	file:
timeout_process	event.c	/^static void	timeout_process(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
timeout_process	event.c	/^timeout_process(struct event_base *base)$/;"	f	signature:(struct event_base *base)
timeout_read	event.h	/^	int timeout_read;	\/* in seconds *\/$/;"	m	struct:bufferevent	access:public
timeout_set	event.h	496;"	d
timeout_write	event.h	/^	int timeout_write;	\/* in seconds *\/$/;"	m	struct:bufferevent	access:public
timeradd	compat/sys/_time.h	85;"	d
timerclear	compat/sys/_time.h	79;"	d
timercmp	compat/sys/_time.h	81;"	d
timerisset	compat/sys/_time.h	80;"	d
timersub	compat/sys/_time.h	94;"	d
timespec	compat/sys/_time.h	/^struct timespec {$/;"	s
timespec::tv_nsec	compat/sys/_time.h	/^	long	tv_nsec;	\/* and nanoseconds *\/$/;"	m	struct:timespec	access:public
timespec::tv_sec	compat/sys/_time.h	/^	time_t	tv_sec;		\/* seconds *\/$/;"	m	struct:timespec	access:public
timespecadd	compat/sys/_time.h	111;"	d
timespecclear	compat/sys/_time.h	105;"	d
timespeccmp	compat/sys/_time.h	107;"	d
timespecisset	compat/sys/_time.h	106;"	d
timespecsub	compat/sys/_time.h	120;"	d
timeval	compat/sys/_time.h	/^struct timeval {$/;"	s
timeval::tv_sec	compat/sys/_time.h	/^	long	tv_sec;		\/* seconds *\/$/;"	m	struct:timeval	access:public
timeval::tv_usec	compat/sys/_time.h	/^	long	tv_usec;	\/* and microseconds *\/$/;"	m	struct:timeval	access:public
timeval_to_ms	WIN32-Code/win32.c	/^timeval_to_ms(struct timeval *tv)$/;"	f	file:	signature:(struct timeval *tv)
timezone	compat/sys/_time.h	/^struct timezone {$/;"	s
timezone::tz_dsttime	compat/sys/_time.h	/^	int	tz_dsttime;	\/* type of dst correction *\/$/;"	m	struct:timezone	access:public
timezone::tz_minuteswest	compat/sys/_time.h	/^	int	tz_minuteswest;	\/* minutes west of Greenwich *\/$/;"	m	struct:timezone	access:public
to_name_assign	test/regress.gen.h	/^  int (*to_name_assign)(struct msg *, const char *);$/;"	m	struct:msg_access_	access:public
to_name_data	test/regress.gen.h	/^  char *to_name_data;$/;"	m	struct:msg	access:public
to_name_get	test/regress.gen.h	/^  int (*to_name_get)(struct msg *, char * *);$/;"	m	struct:msg_access_	access:public
to_name_set	test/regress.gen.h	/^  uint8_t to_name_set;$/;"	m	struct:msg	access:public
top_builddir	Makefile	/^top_builddir = .$/;"	m
top_builddir	sample/Makefile	/^top_builddir = ..$/;"	m
top_builddir	test/Makefile	/^top_builddir = ..$/;"	m
top_distdir	Makefile	/^top_distdir = $(distdir)$/;"	m
top_srcdir	Makefile	/^top_srcdir = .$/;"	m
top_srcdir	sample/Makefile	/^top_srcdir = ..$/;"	m
top_srcdir	test/Makefile	/^top_srcdir = ..$/;"	m
totallen	event.h	/^	size_t totallen;$/;"	m	struct:evbuffer	access:public
trans_id	evdns.c	/^	u16 trans_id;  \/* the transaction id *\/$/;"	m	struct:request	file:	access:public
trans_id	evdns.c	/^	u16 trans_id; \/* Transaction id. *\/$/;"	m	struct:server_request	file:	access:public
trans_id_function	evdns.c	/^static ev_uint16_t (*trans_id_function)(void) = default_transaction_id_fn;$/;"	v	file:
transaction_id_pick	evdns.c	/^static u16 transaction_id_pick(void);$/;"	p	file:	signature:(void)
transaction_id_pick	evdns.c	/^transaction_id_pick(void) {$/;"	f	file:	signature:(void)
transform	Makefile	/^transform = $(program_transform_name)$/;"	m
transform	sample/Makefile	/^transform = $(program_transform_name)$/;"	m
transform	test/Makefile	/^transform = $(program_transform_name)$/;"	m
transmit_me	evdns.c	/^	char transmit_me;  \/* needs to be transmitted *\/$/;"	m	struct:request	file:	access:public
tset	test/regress.c	/^static struct timeval tset;$/;"	v	typeref:struct:timeval	file:
ttl	evdns.c	/^	u32 ttl; \/* The RR TTL *\/$/;"	m	struct:server_reply_item	file:	access:public
tv_cache	event-internal.h	/^	struct timeval tv_cache;$/;"	m	struct:event_base	typeref:struct:event_base::timeval	access:public
tv_nsec	compat/sys/_time.h	/^	long	tv_nsec;	\/* and nanoseconds *\/$/;"	m	struct:timespec	access:public
tv_sec	compat/sys/_time.h	/^	long	tv_sec;		\/* seconds *\/$/;"	m	struct:timeval	access:public
tv_sec	compat/sys/_time.h	/^	time_t	tv_sec;		\/* seconds *\/$/;"	m	struct:timespec	access:public
tv_usec	compat/sys/_time.h	/^	long	tv_usec;	\/* and microseconds *\/$/;"	m	struct:timeval	access:public
tx_count	evdns.c	/^	int tx_count;  \/* the number of times that this packet has been sent *\/$/;"	m	struct:request	file:	access:public
type	evdns.c	/^	u16 type : 16; \/* The RR type *\/$/;"	m	struct:server_reply_item	file:	access:public
type	evdns.c	/^	unsigned int type;$/;"	m	struct:reply	file:	access:public
type	evdns.h	/^	int type;$/;"	m	struct:evdns_server_question	access:public
type	evhttp.h	/^	enum evhttp_cmd_type type;$/;"	m	struct:evhttp_request	typeref:enum:evhttp_request::evhttp_cmd_type	access:public
tz_dsttime	compat/sys/_time.h	/^	int	tz_dsttime;	\/* type of dst correction *\/$/;"	m	struct:timezone	access:public
tz_minuteswest	compat/sys/_time.h	/^	int	tz_minuteswest;	\/* minutes west of Greenwich *\/$/;"	m	struct:timezone	access:public
u16	evdns.c	139;"	d	file:
u32	evdns.c	138;"	d	file:
u64	evdns.c	137;"	d	file:
u8	evdns.c	140;"	d	file:
u_char	evdns.c	/^typedef ev_uint8_t u_char;$/;"	t	file:
u_char	event.h	/^typedef unsigned char u_char;$/;"	t
u_short	event.h	/^typedef unsigned short u_short;$/;"	t
uint	evdns.c	/^typedef unsigned int uint;$/;"	t	file:
uint16_t	WIN32-Code/config.h	234;"	d
uint32_t	WIN32-Code/config.h	237;"	d
uint64_t	WIN32-Code/config.h	240;"	d
uint8_t	WIN32-Code/config.h	243;"	d
uri	evhttp.h	/^	char *uri;			\/* uri after HTTP request was parsed *\/$/;"	m	struct:evhttp_request	access:public
uri	evrpc.h	/^	const char* uri;$/;"	m	struct:evrpc	access:public
uri_chars	http.c	/^static const char uri_chars[256] = {$/;"	v	file:
use_monotonic	event.c	/^static int use_monotonic;$/;"	v	file:
usepersist	test/regress.c	/^static int usepersist;$/;"	v	file:
user_callback	evdns.c	/^	evdns_callback_type user_callback;$/;"	m	struct:request	file:	access:public
user_callback	evdns.c	/^	evdns_request_callback_fn_type user_callback; \/* Fn to handle requests *\/$/;"	m	struct:evdns_server_port	file:	access:public
user_data	evdns.c	/^	void *user_data; \/* Opaque pointer passed to user_callback *\/$/;"	m	struct:evdns_server_port	file:	access:public
user_pointer	evdns.c	/^	void *user_pointer;  \/* the pointer given to us for this request *\/$/;"	m	struct:request	file:	access:public
v	evdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:	access:public
va_copy	buffer.c	154;"	d	file:
value	event.h	/^	char *value;$/;"	m	struct:evkeyval	access:public
wbuf	test/regress.c	/^static char wbuf[4096];$/;"	v	file:
weapon_assign	test/regress.gen.h	/^  int (*weapon_assign)(struct kill *, const char *);$/;"	m	struct:kill_access_	access:public
weapon_data	test/regress.gen.h	/^  char *weapon_data;$/;"	m	struct:kill	access:public
weapon_get	test/regress.gen.h	/^  int (*weapon_get)(struct kill *, char * *);$/;"	m	struct:kill_access_	access:public
weapon_set	test/regress.gen.h	/^  uint8_t weapon_set;$/;"	m	struct:kill	access:public
what	http-internal.h	/^	char *what;$/;"	m	struct:evhttp_cb	access:public
white	event_rpcgen.py	/^white = re.compile(r'^\\s+')$/;"	v
win32_dealloc	WIN32-Code/win32.c	/^void win32_dealloc	(struct event_base *, void *);$/;"	p	file:	signature:(struct event_base *, void *)
win32_dealloc	WIN32-Code/win32.c	/^win32_dealloc(struct event_base *_base, void *arg)$/;"	f	signature:(struct event_base *_base, void *arg)
win32_del	WIN32-Code/win32.c	/^int win32_del	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
win32_del	WIN32-Code/win32.c	/^win32_del(void *op, struct event *ev)$/;"	f	signature:(void *op, struct event *ev)
win32_dispatch	WIN32-Code/win32.c	/^int win32_dispatch	(struct event_base *base, void *, struct timeval *);$/;"	p	file:	signature:(struct event_base *base, void *, struct timeval *)
win32_dispatch	WIN32-Code/win32.c	/^win32_dispatch(struct event_base *base, void *op,$/;"	f	signature:(struct event_base *base, void *op, struct timeval *tv)
win32_init	WIN32-Code/win32.c	/^void *win32_init	(struct event_base *);$/;"	p	file:	signature:(struct event_base *)
win32_init	WIN32-Code/win32.c	/^win32_init(struct event_base *_base)$/;"	f	signature:(struct event_base *_base)
win32_insert	WIN32-Code/win32.c	/^int win32_insert	(void *, struct event *);$/;"	p	file:	signature:(void *, struct event *)
win32_insert	WIN32-Code/win32.c	/^win32_insert(void *op, struct event *ev)$/;"	f	signature:(void *op, struct event *ev)
win32op	WIN32-Code/win32.c	/^struct win32op {$/;"	s	file:
win32op::RB_HEAD	WIN32-Code/win32.c	/^	RB_HEAD(event_map, event_entry) event_root;$/;"	p	struct:win32op	file:	access:public
win32op::exset_out	WIN32-Code/win32.c	/^	struct win_fd_set *exset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32op::fd_setsz	WIN32-Code/win32.c	/^	int fd_setsz;$/;"	m	struct:win32op	file:	access:public
win32op::readset_in	WIN32-Code/win32.c	/^	struct win_fd_set *readset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32op::readset_out	WIN32-Code/win32.c	/^	struct win_fd_set *readset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32op::writeset_in	WIN32-Code/win32.c	/^	struct win_fd_set *writeset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32op::writeset_out	WIN32-Code/win32.c	/^	struct win_fd_set *writeset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
win32ops	WIN32-Code/win32.c	/^struct eventop win32ops = {$/;"	v	typeref:struct:eventop
win_fd_set	WIN32-Code/win32.c	/^struct win_fd_set {$/;"	s	file:
win_fd_set::fd_array	WIN32-Code/win32.c	/^	SOCKET fd_array[1];$/;"	m	struct:win_fd_set	file:	access:public
win_fd_set::fd_count	WIN32-Code/win32.c	/^	u_int fd_count;$/;"	m	struct:win_fd_set	file:	access:public
wm_errorcb	test/regress.c	/^wm_errorcb(struct bufferevent *bev, short what, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, short what, void *arg)
wm_read	event.h	/^	struct event_watermark wm_read;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
wm_readcb	test/regress.c	/^wm_readcb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
wm_write	event.h	/^	struct event_watermark wm_write;$/;"	m	struct:bufferevent	typeref:struct:bufferevent::event_watermark	access:public
wm_writecb	test/regress.c	/^wm_writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
woff	test/regress.c	/^static int woff;$/;"	v	file:
write	test/regress.c	88;"	d	file:
write_cb	test/test-weof.c	/^write_cb(int fd, short event, void *arg)$/;"	f	file:	signature:(int fd, short event, void *arg)
write_event	WIN32-Code/win32.c	/^	struct event *write_event;$/;"	m	struct:event_entry	typeref:struct:event_entry::event	file:	access:public
write_pos	WIN32-Code/win32.c	/^	int write_pos;$/;"	m	struct:event_entry	file:	access:public
write_waiting	evdns.c	/^	char write_waiting;  \/* true if we are waiting for EV_WRITE events *\/$/;"	m	struct:nameserver	file:	access:public
writecb	event.h	/^	evbuffercb writecb;$/;"	m	struct:bufferevent	access:public
writecb	test/regress.c	/^writecb(struct bufferevent *bev, void *arg)$/;"	f	file:	signature:(struct bufferevent *bev, void *arg)
writes	test/bench.c	/^static int count, writes, fired;$/;"	v	file:
writeset_in	WIN32-Code/win32.c	/^	struct win_fd_set *writeset_in;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
writeset_out	WIN32-Code/win32.c	/^	struct win_fd_set *writeset_out;$/;"	m	struct:win32op	typeref:struct:win32op::win_fd_set	file:	access:public
